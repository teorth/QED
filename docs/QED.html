<!DOCTYPE HTML>
<html>
<head>
    <title>QED</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Latest compiled and minified CSS -->
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">

<!-- Optional theme -->
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap-theme.min.css" integrity="sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjduW9SVrLvRYooPp2bWYgmgJQIXwl/Sp" crossorigin="anonymous">

<style>
        * {
            box-sizing: border-box;
        }

    .wrapper {
    display: grid;
    grid-auto-columns: 32%;
    grid-gap: 10px;
    }

    .box {
        padding: 10px;
    }

    .root {
        grid-column: 1;
        grid-row: 1;
    }
    .term {
        grid-column: 1;
        grid-row: 2;
    }
    .formula {
        grid-column: 2;
        grid-row: 1;
    }
    .deductions {
        grid-column: 3;
        grid-row: 1/4;
    }

    .operators {
        grid-column: 2;
        grid-row: 2;
    }

        .halfbox {
            float: left;
            width: 50%;
            padding: 1px;
        }

        .clearfix::after {
            content: "";
            clear: both;
            display: table;
        }

        .clickable {
            box-shadow: 0 0 2px 1px rgba(0,0,0,0.2);
            border-radius: 2px;
        }
        .clickable:hover {
            box-shadow: 0 1px 2px 1px rgba(0,0,0,0.5);
        }

        table {
    font-family: arial, sans-serif;
    border-collapse: collapse;
    width: 100%;
}

td, th {
    border: 1px solid #dddddd;
    text-align: left;
    padding: 8px;
}

tr:nth-child(even) {
    background-color: #dddddd;
}
</style>


<script src="logic.js"></script>
<script src="gui.js"></script>


</head>
<body>

<div class="container">

<header>
        <h2>QED - an interactive textbook</h2>
</header>


<div class="clearfix" id="exercise button box"><b>Sections and exercises</b><div id="exercise button subbox"></div></div>
<br>
<div class="clearfix" id="exercise"><UL>
    <LI> Welcome to QED, a short interactive text in <A HREF="https://en.wikipedia.org/wiki/Propositional_calculus" target="_blank">propositional logic</A> arranged in the format of a computer game.  </LI>
    <LI> Propositional logic is the logic of <A HREF="https://en.wikipedia.org/wiki/Atomic_sentence" target="_blank">atomic propositions</A> (which in this text are given names such as <I>A</I>, <I>B</I>, or <I>C</I>) and the statements one can form from these propositions using logical connectives such as AND, OR, and IMPLIES.  It is a subset of <A HREF="https://en.wikipedia.org/wiki/First-order_logic" target="_blank">first-order logic</A>, which is the main form of logic used in mathematics. </LI>
    <LI> The objective of this "game" is to prove statements in propositional logic from the given hypotheses by clicking and dragging on statements that one has already deduced.  By solving exercises in this game, you should develop a greater understanding of propositional logic.</LI>
    <LI> Expand the "Sections and exercises" section above and then click on the "Exercise 1.1" button to begin the text and start the sequence of exercises!</LI>
</UL>
</div>
<br>
<div class="wrapper">
    <div class="box root" id="root environment"></div>
    <div class="box term" id="term window"></div>
    <div class="box formula" id="formula window"></div>
    <div class="box deductions" id="deductions box"></div>
    <div class="box operators" id="operators window"></div>
</div>

<div class="clearfix" id="proof box" style="background-color:#ddd"></div>
<div class="clearfix">
    <div class="halfbox" id="achievement box" style="background-color:#bbb">
    </div>
    <div class="halfbox" id="notification box" style="background-color:#ccc">
    </div>
  </div>

<button id="undo button">IMMEDIATE UNDO</button>
<button id="restart button">RESTART EXERCISE</button>
<button id="reset button">RESET QED</button>

<p></p>
    <H4 id="version header"> The current version is 2.1.2.</H4>
    <UL id="version notes">
        <LI> Version 2.1.2 (released Aug 23, 2018)  Further bugfix with circularity detection.  New record for 9.2(a).
        <LI> Version 2.1.1 (released Aug 23, 2018)  Some quotes added to text; new exercise (IFF is reflexive, Exercise 10.2(c))</LI>
        <LI> Version 2.1 (released Aug 23, 2018)  New exercises (Russell's paradox, Exercise 23.2, no largest natural number, Exercise 23.3, and a Lewis Carroll logic puzzle, Exercise 22.8) added. Fixed a bug with alternate versions of deduction laws being interpreted as circular.</LI>
		<LI> Version 2.0.3 (released Aug 22, 2018)  Minified CSS.  Some code moved from QED.html file to logic.js file (and some moved from logic.js to gui.js) to make the latter stand-alone.
        <LI> Version 2.0.2 (released Aug 21, 2018)  Code moved to Github, now under an MIT license. </LI>
        <LI> Version 2.0.1 (released Aug 20, 2018)  Meta-key now has same functionality as CTRL-key (for Mac users).  (Thanks to Jacob H. for the suggestion.)</LI>
        <LI> Version 2.0 (released Aug 18, 2018)  Cleaned up version of Version 1.17, hopefully stable release.</LI>
        <LI> Version 1.17 (released Aug 16, 2018)  Alpha version of Section 24, introducing the equality relation.</LI>
        <LI> Version 1.16.1 (released Aug 15, 2018)  New records for 22.4(ae), using some additional formulas that were not previously available until the predicates and operators window was unlocked. (These formulas have since been added to the problem.)</LI>
        <LI> Version 1.16 (released Aug 13, 2018)  Alpha version of Section 23, introducing the predicates and operators window.</LI>
        <LI> Version 1.15.5 (released Aug 13, 2018) New record for 22.6(b).  Spelling corrections.</LI>
        <LI> Version 1.15.4 (released Aug 13, 2018)  Text for Exercise 22.4(ce) and 22.5(a) fixed (thanks to Anders Kaseorg for pointing out the issue).  Three new exercises added to Section 22.</LI>
        <LI> Version 1.15.3 (released Aug 12, 2018)  New records for Exercises 22.4(acd), 22.5(c).  Text for Exercise 22.4(c) fixed.</LI>
	<LI> Version 1.15.2 (released Aug 12, 2018)  New records for Exercises 18.4, 22.2.  Further bug in universal specification legality checking patched (thanks to Andre Maute for reporting the error), as well as a technical bug in the search-and-replace code.  UI for pull (arbitrary variables) changed.
        <LI> Version 1.15.1 (released Aug 12, 2018)  Bug with variable matching fixed (thanks to dP dt and Andre Maute for reporting the error).  Also patched bugs in universal specification and universal introduction (thanks to dP dt for reporting the first error).</LI>
		<LI> Version 1.15 (released Aug 11, 2018)  Alpha version of Section 22, introducing the existential introduction law (the first law in which one can have multiple deductions from a single choice of inputs for reasons other than permutation of the inputs).  Several "invisible" changes to data structures.  Some helper exercises in earlier sections added.
        <LI> Version 1.14.3 (released Aug 9, 2018)  Sections and exercises layout revamped (thanks to dP dt for the suggestion).  Exercises now come with the section title as well.</LI>
        <LI> Version 1.14.2 (released Aug 9, 2018)  Instructions for Exercise 21.1 corrected (thanks to Andrew Lei for pointing out the error).  Link to blog post added at bottom of page (thanks to dP dt for the suggestion).
        <LI> Version 1.14.1 (released Aug 9, 2018)  More accurate discussion of boolean duality in Exercise 12.5(d). New record for Exercise 18.6.  Enforced a further requirement in the law of universal specification, namely that the term one specifies also cannot use free variables that are not recognised by the current environment (thanks to Pranjal Vachaspati for discovering this issue).</I>
        <LI> Version 1.14 (released Aug 9, 2018)  Alpha versions of Sections 20, 21 added, introducing a "pull" law and also an existence law to rule out empty domains of discourse. Section 13 rearranged and expanded, with a new helper exercise (13.2(b)) that shortens some subsequent proofs.  Enforced an important requirement in the law of universal specification, namely that the term one specifies to cannot involve bound variables.</LI>
        <LI> Version 1.13.1 (released Aug 8, 2018) Text of Exercise 19.1 fixed.  Double push exercise added in Exercise 15.2.  Deductions resulting in ill-formed statements will now be displayed but grayed out, rather than hidden completely (thanks to Keith Winstein for this suggestion).  Layout of main windows rearranged.</LI>
        <LI> Version 1.13 (released Aug 7, 2018) Alpha version of Section 19 added, introducing the existential quantifier and the ability to instantiate an existential statement using a "setting" environment.  Section 10 reorganised with a new exercise intended to shorten the proofs of subsequent exercises proving IFF statements (in particular, several exercises in Section 10 onwards (particularly those whose conclusion involves IFF) now have shorter proofs). New hotkeys: 'n' for first available unsolved exercise, 'N' for last available unsolved exercise.  New record for 9.5(a).  Bug with new free and bound variables in Exercise 18.2(a) fixed, as well as incorrect text for Exercise 18.4 (thanks to Keith Winstein for reporting these bugs).</LI>
        <LI> Version 1.12 (released Aug 7, 2018)  Alpha version of Section 18 added, introducing the ability to specialise a universal statement to a term.  Primitive terms also introduced.</LI>
        <LI> Version 1.11 (released Aug 7, 2018)  Alpha version of Section 17 added, introducing the ability to introduce a universal quantifier over a bound variables (which is now equipped with a button to generate such variables).  Some bugs with finding available deductions fixed.  Alternate push law functionality added in which one can push to an environment not yet created by dragging to a formula rather than to the environment. (As a consequence, Exercises 7.1 and 7.2 now have shorter proofs.) Bad hyperlink (to idempotence) fixed.</LI>
        <LI> Version 1.10.1 (released Aug 6, 2018) An exploit involving enabling a deduction, undoing the previous deduction, then selecting a (now unjustified) deduction has been patched (thanks to Keith Winstein for finding the exploit).  Some rewording for the Exercise 1.1 text (following suggestions by arch1).</LI>
        <LI> Version 1.10 (released Aug 5, 2018)  Alpha version of Section 16 added, introducing the ability to introduce free variables from a new Term window (which is also equipped with a button to generate new variables).  Code separated into logic.js, which contains the GUI-independent components of the code, and gui.js, which contains the GUI-dependent components (for future modularity).</LI>
        <LI> Version 1.9 (released Aug 4, 2018)  Environments now clickable.  Hotkeys "u" for immediate undo and "r" for restart. Alpha version of Sections 14, 15 added, introducing free variable environments and atomic sentences involving predicates and free variables, and a new PUSH law.  Some bad hyperlinks (reported by Mauricio de Oliveira) repaired. Fixed a bug (reported by Matthew Steffen) regarding whether cloned laws qualified for non-circular proofs.  Some laws taking a target environment as an input now have that environment removed in view of the clone functionality.</LI>
        <LI> Version 1.8.1 (released Aug 4, 2018)  Error in PUSH law (and other laws involving a non-root environment) fixed.  (Thanks to Andre Maute for reporting the bug.) </LI>
        <LI> Version 1.8 (released Aug 3, 2018)  Restart exercise button added.  Further "under the hood" changes.  Laws with root environment default now come with a "clone" with one additional hypothesis that allows one to select the root environment.</LI>
        <LI> Version 1.7.1 (released Aug 2, 2018)  Can now use ctrl-click to select items, in particular allowing for more than two items to be selected.  The numbers 1-9 are now keyboard shortcuts for the first 9 deductions in the Available deductions window.</LI>
        <LI> Version 1.7 (released Aug 2, 2018).  Dragging X to Y now also checks for laws available from dragging Y to X.  Exercise 1.1 changed (so legacy players may artificially have beaten the shortest length now for this exercise).  Various "under the hood" code changes in preparation for extension to first order logic.  Various sections of game now collapsed by default.</LI>
        <LI> Version 1.6.2 (released Aug 1, 2018).  New records for Exercises 9.5(b), 10.1(b), 13.2(a), 13.3(a), 13.3(d). Duplicate unlocking of laws prevented.  Table of boolean duality added to Exercise 12.5(d). Typo corrections.</LI>
        <LI> Version 1.6.1 (released July 31, 2018).  New records for Exercises 9.5(a), 13.3(a), 13.3(d).</LI>
        <LI> Version 1.6 (released July 31, 2018).  New 0-ary operators TRUE and FALSE; new exercises (and a new section) added.           </LI>
        <LI> Version 1.5.3 (released July 31, 2018).  Rules appearing in text at or after an exercise can still be used, but have an asterisk attached to them and no longer trigger records.</LI>
        <LI> Version 1.5.2 (released July 30, 2018).  New record for Exercise 10.4.</LI>
        <LI> Version 1.5.1 (released July 30, 2018).  New record for Exercise 9.3(d).  Improved backwards capability (game states from prior versions should now be able to re-unlock exercises and laws).</LI>
        <LI> Version 1.5 (released July 30, 2018).  Completing all exercises allows one to reveal the shortest known proofs.  Some inaccuracies in the shortest known proofs corrected.  A bug regarding the interaction between the UNDO button and the number of lines of the proof has been fixed.</LI>
        <LI> Version 1.4 (released July 30, 2018).  Exercises organised by section.  Solved exercises are now green or blue depending on whether the shortest length was achieved.  HTML links now open in a new tab so as not to disrupt game state.  Immediate UNDO button added.</LI>
        <LI> Version 1.3.2 (released July 30, 2018).  New records for Exercises 2.2(b), 12.5(c). Clarifications and typo fixes to text.</LI>
        <LI> Version 1.3.1 (released July 30, 2018).  Implemented the styling suggestions of redblobgames.</LI>
        <LI> Version 1.3 (released July 30, 2018).  Newer record for Exercise 12.6(a).  Bad hyperlink (pointed out by Andrew Lei) fixed.  Successful proofs can now be expanded and collapsed in the notifications window.</LI>
        <LI> Version 1.2.2 (released July 29, 2018).  New record for Exercise 12.6(a).  A typo causing exercises to not load beyond 12.2(b) has been repaired. (Thanks to William Chargin for pointing out the issue and providing a fix.)</LI>
        <LI> Version 1.2.1 (released July 29, 2018).  New records for Exercises 7.2, 9.2(a), 12.2(b), 12.2(c), 12.4(b), 12.6(c).  Some incorrect proof lengths fixed.</LI>
        <LI> Version 1.2 (released July 29, 2018).  Achievements and notifications windows now side-by side.  Achievements now list from newest to oldest rather than vice versa.  "No available deductions" response added. Clicking on deductions twice no longer creates duplicates (thanks to ahartel for this suggestion).  Some clarifications added to text.  Best known proof lengths added. Exercises 5.1 and 12.1(c) corrected; other minor corrections.  Some new exercises added.</LI>
        <LI> Version 1.1 (released July 29, 2018).  Tests if local storage is supported. Exercise 7.2 repaired (and all subsequent exercises now accessible).  All exercise buttons now visible (not just unlocked ones).  Spelling corrections.</LI>
        <LI> Version 1.0 (released July 28, 2018).  Beta release.</LI>
</UL>

If the text has updated to a new version since your last session, you may need to reset the text in order for it to work correctly, or at least redo some of the exercises that unlock certain laws.  This page works best when viewed on a large screen and with the ability to drag-and-drop; in particular, this page is unlikely to be all that functional on a cell phone.  Also one may need a recently updated browser in order for the page to work properly (in particular, grid layouts and local storage should be supported for the best experience).
<P>
</P>
Further discussion of this text may be found at <A HREF="https://terrytao.wordpress.com/2018/07/28/gamifying-propositional-logic-qed-an-interactive-textbook/" target="_blank">this blog post</A>.
<footer>
    Originally written by Terence Tao.  Now <A HREF="https://github.com/teorth/QED">on github</A> under a MIT license.
</footer>

</div>

<script>

 createExerciseButtonBox();
 createExerciseBox();
 createRootEnvironment();
 createFormulaWindow();
 createDeductionsBox();
 createProofBox();
 createTermWindow();
 createAchievementsBox();
 createNotificationsBox();
 createOperatorsWindow();
 createUndoButton();
 createRestartButton();
 createResetButton();
 getElement("version header").appendChild(newCollapseButton(getElement("version notes"), false));
 document.body.setAttribute("onkeydown", "keydown(event)");


 newSection("1", "Conjunction introduction");

 var LawConjunction1 = new Law('<A HREF="https://en.wikipedia.org/wiki/Conjunction_introduction" target="_blank">CONJUNCTION INTRODUCTION</A>', [A, B], AND(A,B));
 var Exercise11 = new Exercise("1.1", "", [A, B], AND(AND(B,A),B),5);
 Exercise11.unlocks(LawConjunction1);
 Exercise11.notes = '<UL> <LI>  The <B>Root environment</B> window below contains all the statements that one already knows to be true for the given exercise (which, in this case, are <I>A</I> and <I>B</I>).  Initially this window will just contain the given hypotheses of the exercise.  <LI> Statements can be <A HREF="https://en.wikipedia.org/wiki/Atomic_formula" target="_blank">atomic formulas</A> such as <I>A</I>, <I>B</I>, and <I>C</I>, or compound formulas formed from the atomic formulas and logical connectives such as AND, OR, and NOT.  For instance, (<I>A</I> AND <I>B</I>) OR <I>C</I> is a compound formula, and thus a potential statement in one\'s argument.<LI>  If one drags one statement to another, the <B>Available deductions</B> window below will show what conclusions one can draw from these statements using the available <A HREF="https://en.wikipedia.org/wiki/Rule_of_inference" target="_blank">deduction rules</A>; if any conclusions can be drawn, one can add them to the <B>Root environment</B> window by clicking on the button containing the conclusion.</LI>  <LI> For instance, to solve this level one drags the <I>B</I> statement onto the <I>A</I> statement (or vice versa), clicks on the button marked "<I>B</I> AND <I>A</I>" to add that statement to the <B>Root environment</B>, drags the nw <I>B</I> AND <I>A</I> statement onto the <I>B</I> statement (or vice versa), and then clicks on the button containing the desired conclusion.  <LI> By opening the first exercise of Section 1 (Exercise 1.1), you unlocked the rule of <A HREF="https://en.wikipedia.org/wiki/Conjunction_introduction" target="_blank">conjunction introduction</A>.  This asserts that if a statement <I>A</I> is known, and the statement <I>B</I> is known, then one can deduce the compound statement <I>A</I> AND <I>B</I>.  This is the only rule one starts with, but more deductive rules will be unlocked whenever one begins a new section of the textbook. <LI> Progress is recorded in the <B>Achievements</B> and <B>Notifications</B> windows below.  This progress will be saved between sessions (assuming your browser supports local storage), unless you reset this interactive text completely using the button at the bottom of the page.<LI> Your deductions will be recorded as a human-readable proof in the <B>Proof</B> window below.  This window is not absolutely necessary in order to play the game, but should help you understand and interpret the moves you are making.<LI> The exercise is completed when you have managed to obtain the desired conclusion (in this case, (<I>B</I> AND <I>A</I>) AND <I>B</I>) in the <B>Root environment</B> window.  This will unlock further exercises and sections of the textbook, turning the exercise buttons from gray to yellow.</UL>';
 Exercise11.completionMsg = 'Congratulations, you solved your first exercise!  Now two more exercises will be unlocked, as well as the next section of the text.  (For subsequent exercises, we will notify you of an exercise being solved by changing the color of the exercise and its proof to either green or blue, depending on whether you found the shortest known proof or not.  We also add a QED symbol (standing for "quod erat demonstrandum", or "what was to be demonstrated") to the end of the proof.)';
 Exercise11.proof = '<li><span><em>A</em>. <i>[given]</i></span></li><li><span><em>B</em>. <i>[given]</i></span></li><li><span>From <em>B</em>, <em>A</em>: deduce <em>B</em> AND <em>A</em>. <i>[<a<li><span><em>A</em>. <i>[given]</i></span></li><li><span><em>B</em>. <i>[given]</i></span></li><li><span>From <em>B</em>, <em>A</em>: deduce <em>B</em> AND <em>A</em>. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_introduction" target=" _blank">CONJUNCTION INTRODUCTION</a>]</i></span></li><li><span>From <em>B</em> AND <em>A</em>, <em>B</em>: deduce (<em>B</em> AND <em>A</em>) AND <em>B</em>. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_introduction" target=" _blank">CONJUNCTION INTRODUCTION</a>]</i></span></li><li><span>QED!</span></li>';
 activateExerciseButton(Exercise11);

 var Exercise12 = new Exercise("1.2", 'AND IS <A HREF="https://en.wikipedia.org/wiki/Idempotence" target="_blank">IDEMPOTENT</A>', [A], AND(A,A),3);
 Exercise12.unlockedBy(Exercise11);
 Exercise12.notes = '<UL> <LI> It is permissible to drag a statement onto itself.</LI> <LI> <Q>Each problem that I solved became a rule, which served afterwards to solve other problems</Q> - <A HREF="https://en.wikiquote.org/wiki/Ren%C3%A9_Descartes" target="_blank">Ren√© Descartes</A>.  Each exercise solved in this text becomes a new deduction rule that you may use in subsequent exercises.  The <B>Achievements</B> window lists all the rules of inference one has available, either through being unlocked by opening the appropriate exercise, or by proving that rule as one of the exercises.</LI><LI> One can also use the numbers \'1\' through \'9\' as hotkeys for the available eductions (or the first 9 of them, at any rate).</LI></UL>';
 Exercise12.proof = '<li><span><em>A</em> AND <em>B</em>. <i>[given]</i></span></li><li><span>From <em>A</em> AND <em>B</em>: deduce <em>A</em>. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_elimination" target="_blank">CONJUNCTION ELIMINATION</a> (left)]</i></span></li><li><span>From <em>A</em> AND <em>B</em>: deduce <em>B</em>. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_elimination" target="_blank">CONJUNCTION ELIMINATION</a> (right)]</i></span></li><li><span>From <em>B</em>, <em>A</em>: deduce <em>B</em> AND <em>A</em>. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_introduction" target=" _blank">CONJUNCTION INTRODUCTION</a>]</i></span></li><li><span>QED!</span></li>';

 newSection("2", "Conjunction elimination");

 var LawConjunction2 = new Law('<A HREF="https://en.wikipedia.org/wiki/Conjunction_elimination" target="_blank">CONJUNCTION ELIMINATION</A> (left)', [AND(A,B)], A);
 var LawConjunction3 = new Law('<A HREF="https://en.wikipedia.org/wiki/Conjunction_elimination" target="_blank">CONJUNCTION ELIMINATION</A> (right)', [AND(A,B)], B);
 var Exercise21 = new Exercise("2.1", 'AND IS <A HREF="https://en.wikipedia.org/wiki/Commutative_property" target="_blank">COMMUTATIVE</A>', [AND(A,B)], AND(B,A),5);
 Exercise21.unlocks(LawConjunction2);
 Exercise21.unlocks(LawConjunction3);
 Exercise21.unlockedBy(Exercise11);
 Exercise21.notes = '<UL><LI>The rules of <A HREF="https://en.wikipedia.org/wiki/Conjunction_elimination">conjunction elimination</A> have been unlocked.  These rules assert that if a conjunction statement such as <I>A</I> AND <I>B</I> is known, then one can deduce either of the two individual statements <I>A</I> or <I>B</I> of that statement separately.<LI> To activate this rule, click on a compound statement of the form <I>A</I> AND <I>B</I>.</UL>';
Exercise21.proof = '<li><span><em>A</em> AND <em>B</em>. <i>[given]</i></span></li><li><span>From <em>A</em> AND <em>B</em>: deduce <em>A</em>. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_elimination" target="_blank">CONJUNCTION ELIMINATION</a> (left)]</i></span></li><li><span>From <em>A</em> AND <em>B</em>: deduce <em>B</em>. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_elimination" target="_blank">CONJUNCTION ELIMINATION</a> (right)]</i></span></li><li><span>From <em>B</em>, <em>A</em>: deduce <em>B</em> AND <em>A</em>. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_introduction" target=" _blank">CONJUNCTION INTRODUCTION</a>]</i></span></li><li><span>QED!</span></li>';

 var Exercise22 = new Exercise("2.2(a)", 'AND IS <A HREF="https://en.wikipedia.org/wiki/Associative_property" target="_blank">ASSOCIATIVE</A> (left)', [AND(AND(A,B),C)], AND(A,AND(B,C)),8);
 Exercise22.unlockedBy(Exercise21);
 Exercise22.notes = '<UL> <LI> One can think of a deduction rule as a template in which the <A HREF="https://en.wikipedia.org/wiki/Atomic_formula" target="_blank">atomic formulas</A> of the deduction rule (such as <I>A</I> or <I>B</I>) can be replaced by compound formulas (e.g. "<I>A</I> AND <I>B</I>").  This can greatly increase the power of such laws. <LI> There are no "wrong" moves in the QED game - every move you make is a valid deduction!  However, you may end up making "useless" moves - moves that are logically valid, but do not bring one closer to the desired conclusion.  If you are finding the deduction environment to be getting too cluttered, you can click on the exercise button (in this case, Exercise 2.2(a)) to start from the beginning; one can also press the "RESTART QUESTION" (or presses "r") at the bottom of the page.<LI> One can also "UNDO" a deduction if one presses the "IMMEDIATE UNDO" button at the bottom of this page (or presses "u") immediately after making a deduction.  This feature is not available if the deduction solves the exercise, or if one has performed any action between the deduction and the undo.</UL>';
Exercise22.proof = '<li><span>(<em>A</em> AND <em>B</em>) AND <em>C</em>. <i>[given]</i></span></li><li><span>From (<em>A</em> AND <em>B</em>) AND <em>C</em>: deduce <em>A</em> AND <em>B</em>. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_elimination" target="_blank">CONJUNCTION ELIMINATION</a> (left)]</i></span></li><li><span>From (<em>A</em> AND <em>B</em>) AND <em>C</em>: deduce <em>C</em>. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_elimination" target="_blank">CONJUNCTION ELIMINATION</a> (right)]</i></span></li><li><span>From <em>A</em> AND <em>B</em>: deduce <em>A</em>. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_elimination" target="_blank">CONJUNCTION ELIMINATION</a> (left)]</i></span></li><li><span>From <em>A</em> AND <em>B</em>: deduce <em>B</em>. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_elimination" target="_blank">CONJUNCTION ELIMINATION</a> (right)]</i></span></li><li><span>From <em>B</em>, <em>C</em>: deduce <em>B</em> AND <em>C</em>. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_introduction" target=" _blank">CONJUNCTION INTRODUCTION</a>]</i></span></li><li><span>From <em>A</em>, <em>B</em> AND <em>C</em>: deduce <em>A</em> AND (<em>B</em> AND <em>C</em>). <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_introduction" target=" _blank">CONJUNCTION INTRODUCTION</a>]</i></span></li><li><span>QED!</span></li>';


 var Exercise22b = new Exercise("2.2(b)", 'AND IS <A HREF="https://en.wikipedia.org/wiki/Associative_property" target="_blank">ASSOCIATIVE</A> (right)', [AND(A,AND(B,C))], AND(AND(A,B),C),7);
 Exercise22b.unlockedBy(Exercise21);
 Exercise22b.notes = 'Thanks to Stijn Vanhee and Siddhartha Srivastava for supplying a short proof.';
Exercise22b.proof = '<li><span><em>A</em> AND (<em>B</em> AND <em>C</em>). <i>[given]</i></span></li><li><span>From <em>A</em> AND (<em>B</em> AND <em>C</em>): deduce (<em>B</em> AND <em>C</em>) AND <em>A</em>. <i>[AND IS <a href="https://en.wikipedia.org/wiki/Commutative_property" target="_blank">COMMUTATIVE</a>]</i></span></li><li><span>From (<em>B</em> AND <em>C</em>) AND <em>A</em>: deduce <em>B</em> AND (<em>C</em> AND <em>A</em>). <i>[AND IS <a href="https://en.wikipedia.org/wiki/Associative_property" target="_blank">ASSOCIATIVE</a> (left)]</i></span></li><li><span>From <em>B</em> AND (<em>C</em> AND <em>A</em>): deduce (<em>C</em> AND <em>A</em>) AND <em>B</em>. <i>[AND IS <a href="https://en.wikipedia.org/wiki/Commutative_property" target="_blank">COMMUTATIVE</a>]</i></span></li><li><span>From (<em>C</em> AND <em>A</em>) AND <em>B</em>: deduce <em>C</em> AND (<em>A</em> AND <em>B</em>). <i>[AND IS <a href="https://en.wikipedia.org/wiki/Associative_property" target="_blank">ASSOCIATIVE</a> (left)]</i></span></li><li><span>From <em>C</em> AND (<em>A</em> AND <em>B</em>): deduce (<em>A</em> AND <em>B</em>) AND <em>C</em>. <i>[AND IS <a href="https://en.wikipedia.org/wiki/Commutative_property" target="_blank">COMMUTATIVE</a>]</i></span></li><li><span>QED!</span></li>';


newSection("3", "Disjunction introduction");

 var LawDisjunction1 = new Law('<A HREF="https://en.wikipedia.org/wiki/Disjunction_introduction" target="_blank">DISJUNCTION INTRODUCTION</A> (left)', [formulaContext(B), A], OR(A,B));
 var LawDisjunction2 = new Law('<A HREF="https://en.wikipedia.org/wiki/Disjunction_introduction" target="_blank">DISJUNCTION INTRODUCTION</A> (right)', [formulaContext(B), A], OR(B,A));
 var Exercise31 = new Exercise("3.1(a)", "", [A, formulaContext(B), formulaContext(C)], OR(C,OR(A,B)),4);
 Exercise31.unlocks(LawDisjunction1);
 Exercise31.unlocks(LawDisjunction2);
 Exercise31.unlockedBy(Exercise21);
 Exercise31.revealFormulaWindow = true;
 Exercise31.notes = '<UL><LI>Some deductive rules use formulas (also known as <A HREF="https://en.wikipedia.org/wiki/Well-formed_formula" target="_blank">well-formed formulas</A>) as input.<LI>  Formulas look the same as statements, but whereas statements in the root environment are known to be true, a formula could be either true or false.  As such, we place them in a separate <B>Formulas</B> window, which is now unlocked for use.  For instance, in this exercise, the formulas <I>B</I> and <I>C</I> are <i>not</i> known to be true, but are still available for use in some rules of inference.  The formula <I>A</I> is known to be true, so it can belong to both the <B>Root environment</B> and <B>Formulas</B> windows.<LI> In mathematical logic, the logical connective OR (also known as <A HREF="https://en.wikipedia.org/wiki/Logical_disjunction" target="_blank">disjunction</A>) is interpreted as an <I>inclusive</I> or; the statement "<I>A</I> OR <I>B</I>" asserts that <I>at least one</I> of <I>A</I> and <I>B</I> are true, and in particular will remain true if <I>both</I> of <I>A</I> and <I>B</I> are true. This feature of OR is captured in part by the laws of <A HREF="https://en.wikipedia.org/wiki/Disjunction_introduction" target="_blank">disjunction introduction</A> that have just been unlocked.<LI> To use one of these laws, drag a formula from the <B>Formulas</B> window to a sentence in the <B>Root environment</B> window (or drag a sentence in the <B>Root environment</B> window to a formula in the <B>Formulas</B> window).</UL>';
Exercise31.proof = '<li><span><em>A</em>. <i>[given]</i></span></li><li><span>From <em>A</em>: deduce <em>A</em> OR <em>B</em>. <i>[<a href="https://en.wikipedia.org/wiki/Disjunction_introduction" target="_blank">DISJUNCTION INTRODUCTION</a> (left)]</i></span></li><li><span>From <em>A</em> OR <em>B</em>: deduce <em>C</em> OR (<em>A</em> OR <em>B</em>). <i>[<a href="https://en.wikipedia.org/wiki/Disjunction_introduction" target="_blank">DISJUNCTION INTRODUCTION</a> (right)]</i></span></li><li><span>QED!</span></li>';

 var Exercise31b = new Exercise("3.1(b)", 'OR IS <A HREF="https://en.wikipedia.org/wiki/Idempotence" target="_blank">IDEMPOTENT</A> (left)', [A], OR(A,A),3);
 Exercise31b.unlockedBy(Exercise31);
 Exercise31b.notes = 'The reverse implication (deducing <I>A</I> from <I>A</I> OR <I>A</I>) is true, but will be deferred to Exercise 9.1(b), as we first need to introduce the important concept of an assumption and then introduce some further laws of disjunction.';
Exercise31b.proof = '<li><span><em>A</em>. <i>[given]</i></span></li><li><span>From <em>A</em>: deduce <em>A</em> OR <em>A</em>. <i>[<a href="https://en.wikipedia.org/wiki/Disjunction_introduction" target="_blank">DISJUNCTION INTRODUCTION</a> (left)]</i></span></li><li><span>QED!</span></li>';


 newSection("4", "Assumption");

 var LawAssumption = new Law('IMPLICATION INTRODUCTION', [formulaContext(A)], assuming(A,A));
 var Exercise41 = new Exercise("4.1", "", [formulaContext(A)], assuming(AND(A,A),A),3);
 Exercise41.unlocks(LawAssumption);
 Exercise41.unlockedBy(Exercise31);
 Exercise41.notes = '<UL><LI> The <B>Root environment</B> window holds all the statements that are known to be true under the given hypothesis.  But sometimes in an argument, we also need to consider statements that are only <I>conditionally</I> known to be true, under one or more assumptions.  For instance, we might not know that a statement <I>A</I> is true unconditionally, but instead know that <I>A</I> is conditionally true under the assumption of a second statement <I>B</I>.  <LI> In this interactive text, assumptions are depicted as subwindows of the <B>Root environment</B> window.  For instance, to depict the knowledge of <I>A</I> conditionally under the assumption of <I>B</I>, one would form a subwindow of <B>Root environment</B> titled "<B>Assume <I>B</I></B>", and place <I>A</I> inside that window. <LI> The <A HREF="https://en.wikipedia.org/wiki/Conditional_proof" target="_blank">law of assumption</A> (or <I>implication introduction</I>) asserts that if <I>A</I> is a formula, then it will be true if we first make an assumption that <I>A</I> holds.  <LI>  Try dragging the formula <I>A</I> to the <B>Root environment</B> window (or clicking on the formula) to make such an assumption! <LI> Every deductive rule that one can apply in the root environment, one can also apply in a sub-environment.  This is the key to solving the current exercise (and to many subsequent exercises).</UL>';
Exercise41.proof = '<li><span>Deduce <em>A</em> [assuming <em>A</em>]. <i>[IMPLICATION INTRODUCTION]</i></span></li><li><span>From <em>A</em> [assuming <em>A</em>], <em>A</em> [assuming <em>A</em>]: deduce <em>A</em> AND <em>A</em> [assuming <em>A</em>]. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_introduction" target=" _blank">CONJUNCTION INTRODUCTION</a>]</i></span></li><li><span>QED!</span></li>';


newSection("5", "Logical connectives");

 var formAnd = new Law('AND', [formulaContext(A), formulaContext(B)], formulaContext(AND(A,B)));
 var formOr = new Law('OR', [formulaContext(A), formulaContext(B)], formulaContext(OR(A,B)));
 var Exercise51 = new Exercise("5.1", "", [formulaContext(A), formulaContext(B), formulaContext(C)], assuming(OR(AND(A,B),C), OR(AND(A,B),C)),2);
 Exercise51.unlocks(formAnd);
 Exercise51.unlocks(formOr);
 Exercise51.unlockedBy(Exercise41);
 Exercise51.notes = '<UL> <LI> One can combine formulas together to create compound formulas.  <LI> For binary logical connectives such as AND and OR, this is done here by dragging formulas together in the <B>Formulas</B> window.  <LI> See what happens if one drags the formula <I>A</I> onto the formula <I>B</I> or vice versa!<LI> For the purposes of recording proof length, the creation of new formulas is considered to be a "free move" in this text, in that it does not use up any lines of the proof.</LI> </UL>';
Exercise51.proof = '<li><span>Deduce (<em>A</em> AND <em>B</em>) OR <em>C</em> [assuming (<em>A</em> AND <em>B</em>) OR <em>C</em>]. <i>[IMPLICATION INTRODUCTION]</i></span></li><li><span>QED!</span></li>';


 var Exercise52 = new Exercise("5.2", "", [formulaContext(A), formulaContext(B)], assuming(assuming(A,A),B),3);
 Exercise52.unlockedBy(Exercise51);
 Exercise52.notes = '<UL><LI>Assumptions can be nested.</LI>  <LI>The statement "<I>A</I>, assuming <I>B</I>, <I>A</I>" asserts that if one assumes <I>B</I>, and then subsequently assumes <I>A</I>, then the statement <I>A</I> will be true under these two assumptions.</LI> <LI>As with Exercise 4.1, the key to solving this exercise is in using the fact that any deductive rule that is applicable in the root environment, can also be applied in any sub-environment.</LI></UL>';
Exercise52.proof = '<li><span>Deduce <em>B</em> [assuming <em>B</em>]. <i>[IMPLICATION INTRODUCTION]</i></span></li><li><span>Deduce <em>A</em> [assuming <em>B</em>, <em>A</em>]. <i>[IMPLICATION INTRODUCTION]</i></span></li><li><span>QED!</span></li>';

newSection("6", "Deduction theorem");

 var formImplies = new Law('IMPLIES', [formulaContext(A), formulaContext(B)], formulaContext(IMPLIES(A,B)));
 var LawImplication = new Law('<A HREF="https://en.wikipedia.org/wiki/Deduction_theorem" target="_blank">DEDUCTION THEOREM</A>', [assuming(B,A), rootEnvironmentContext()], IMPLIES(A,B));
 var Exercise61 = new Exercise("6.1(a)", 'IMPLIES IS <A HREF=https://en.wikipedia.org/wiki/Idempotence" target="_blank">IDEMPOTENT</A>', [formulaContext(A)], IMPLIES(A,A),3);
 Exercise61.unlocks(formImplies);
 Exercise61.unlocks(LawImplication);
 Exercise61.unlockedBy(Exercise51);
 Exercise61.notes = '<UL><LI>The logical connective IMPLIES is also known as <A HREF="https://en.wikipedia.org/wiki/Material_conditional" target="_blank">material implication</A> (or the <I>conditional</I>); informally, one can think of the assertion IMPLIES(<I>A</I>, <I>B</I>) as the assertion that <I>B</I> is "at least as true as" <I>A</I>.  (But they do not need to be <I>equally</I> true: in particular, if <I>A</I> is false and <I>B</I> is true, then it turns out that <I>A</I> IMPLIES <I>B</I> is true.<LI> The statement <I>A</I> IMPLIES <I>B</I> can also be written as IF <I>A</I>, THEN <I>B</I>.<LI>  The <A HREF="https://en.wikipedia.org/wiki/Deduction_theorem" target="_blank">deduction theorem</A> asserts that if you can prove a statement <I>B</I> under the assumption of another statement <I>A</I>, then you can deduce the compound statement <I>A</I> IMPLIES <I>B</I>. It is very commonly used in mathematics to prove implication statements.<LI> To use the deduction theorem, take a statement that is known under some hypothesis, and drag it out of the window corresponding to that hypothesis. <LI> In some proof systems for propositional calculus, the deduction theorem is not one of the given laws of inference, but actually has to be proven as a theorem, which explains the name.  However, in this text, we will take the deduction theorem as a primitive inference rule.</UL>';
Exercise61.proof = '<li><span>Deduce <em>A</em> [assuming <em>A</em>]. <i>[IMPLICATION INTRODUCTION]</i></span></li><li><span>From <em>A</em> [assuming <em>A</em>]: deduce <em>A</em> IMPLIES <em>A</em>. <i>[<a href="https://en.wikipedia.org/wiki/Deduction_theorem" target="_blank">DEDUCTION THEOREM</a>]</i></span></li><li><span>QED!</span></li>';


 var Exercise61b = new Exercise("6.1(b)", "", [formulaContext(A), formulaContext(B)], IMPLIES(AND(A,OR(A,B)),A),4);
 Exercise61b.unlockedBy(Exercise61);
 Exercise61b.notes = 'To prove an implication of the form <I>X</I> IMPLIES <I>Y</I>, first create <I>X</I> as a formula in the <B>Formulas</B> window, drag it to the <B>Root environment</B> window to use it as an assumption, and then try to establish <I>Y</I> inside the window corresponding to that assumption.  Then use the deduction theorem.';
Exercise61b.proof = '<li><span>Deduce <em>A</em> AND (<em>A</em> OR <em>B</em>) [assuming <em>A</em> AND (<em>A</em> OR <em>B</em>)]. <i>[IMPLICATION INTRODUCTION]</i></span></li><li><span>From <em>A</em> AND (<em>A</em> OR <em>B</em>) [assuming <em>A</em> AND (<em>A</em> OR <em>B</em>)]: deduce <em>A</em> [assuming <em>A</em> AND (<em>A</em> OR <em>B</em>)]. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_elimination" target="_blank">CONJUNCTION ELIMINATION</a> (left)]</i></span></li><li><span>From <em>A</em> [assuming <em>A</em> AND (<em>A</em> OR <em>B</em>)]: deduce (<em>A</em> AND (<em>A</em> OR <em>B</em>)) IMPLIES <em>A</em>. <i>[<a href="https://en.wikipedia.org/wiki/Deduction_theorem" target="_blank">DEDUCTION THEOREM</a>]</i></span></li><li><span>QED!</span></li>';

 var Exercise62 = new Exercise("6.2", 'DOUBLE <A HREF="https://en.wikipedia.org/wiki/Deduction_theorem" target="_blank">DEDUCTION THEOREM</A>', [assuming(assuming(C,B),A), rootEnvironmentContext()], IMPLIES(A,IMPLIES(B,C)),4);
 Exercise62.unlockedBy(Exercise61);
 Exercise62.notes = '<UL><LI> This exercise easily follows from two applications of the deduction theorem, but is convenient for use in later exercises.</LI> <LI>The appearance of [root environment] in the list of assumptions is not needed to <i>solve</i> the exercise; but it affects the user interface for <I>applying</I> the exercise.  Namely, to invoke this theorem in the future, one should drag a statement "up" two levels, undoing two levels of assumption.  (Without [root environment], one would instead click on the statement rather than drag it up two levels.)</LI></UL>';
Exercise62.proof = '<li><span><em>C</em> [assuming <em>A</em>, <em>B</em>]. <i>[given]</i></span></li><li><span>From <em>C</em> [assuming <em>A</em>, <em>B</em>]: deduce <em>B</em> IMPLIES <em>C</em> [assuming <em>A</em>]. <i>[<a href="https://en.wikipedia.org/wiki/Deduction_theorem" target="_blank">DEDUCTION THEOREM</a>]</i></span></li><li><span>From <em>B</em> IMPLIES <em>C</em> [assuming <em>A</em>]: deduce <em>A</em> IMPLIES (<em>B</em> IMPLIES <em>C</em>). <i>[<a href="https://en.wikipedia.org/wiki/Deduction_theorem" target="_blank">DEDUCTION THEOREM</a>]</i></span></li><li><span>QED!</span></li>';

newSection("7", "Push");


 var Push = new Law('PUSH', [A, environmentContext([B])], assuming(A,B));
 var PushAlt = new Law('PUSH (alternate form)', [A, formulaContext(B)], assuming(A,B));
  var Exercise71 = new Exercise("7.1", "", [formulaContext(A), formulaContext(B)], IMPLIES(A, IMPLIES(B,A)),4);
  Exercise71.unlocks(Push);
  Exercise71.unlocks(PushAlt);
 Exercise71.unlockedBy(Exercise61);
 Exercise71.notes = '<UL><LI> If a statement is known without an assumption, then it can be "pushed" into an enviroment with that assumption.  For instance, if <I>A</I> is known to be true unconditionally, then it is also known to be true assuming <I>B</I>. </LI> <LI> The push law is also known as "weakening" or <A HREF="https://en.wikipedia.org/wiki/Monotonicity_of_entailment" target = "_blank">monotonicity of entailment</A>.<LI> To apply a push, drag a statement into an assumption environment that shares the same parent environment as the original statement.  (Alternatively, if this environment has not yet been created, drag the statement onto a formula containing the assumption, or vice versa.)</UL>';
Exercise71.proof = '<li><span>Deduce <em>A</em> [assuming <em>A</em>]. <i>[IMPLICATION INTRODUCTION]</i></span></li><li><span>From <em>A</em> [assuming <em>A</em>]: deduce <em>A</em> [assuming <em>A</em>, <em>B</em>]. <i>[PUSH (alternate form)]</i></span></li><li><span>From <em>A</em> [assuming <em>A</em>, <em>B</em>]: deduce <em>A</em> IMPLIES (<em>B</em> IMPLIES <em>A</em>). <i>[DOUBLE <a href="https://en.wikipedia.org/wiki/Deduction_theorem" target="_blank">DEDUCTION THEOREM</a>]</i></span></li><li><span>QED! (again)</span></li>';


var Exercise72 = new Exercise("7.2", "DOUBLE PUSH", [A, environmentContext([B,C])], assuming(assuming(A,C),B),4);
Exercise72.unlockedBy(Exercise71);
Exercise72.notes = '<UL><LI> This exercise easily follows from two applications of the push law, but turns out to be convenient in some subsequent exercises. </LI> <LI> The presence of the assumption environment [assuming <I>B</I>, <I>C</I>] is needed for two technical reasons.  Firstly, it populates the formula window with the atomic formulas <I>B</I>, <I>C</I>, which otherwise would not be present.  Secondly, it affects the user interface for applying the double push rule.  Namely, to invoke this law, one should push a statement "down" two levels, into an assumption window that is two levels nested below the one that the statement lies in.</LI><LI>Thanks to Steve Trout for contributing a short proof.</LI></UL>';
Exercise72.proof = '<li><span><em>A</em>. <i>[given]</i></span></li><li><span>From <em>A</em>: deduce <em>A</em> [assuming <em>B</em>]. <i>[PUSH (alternate form)]</i></span></li><li><span>From <em>A</em> [assuming <em>B</em>]: deduce <em>A</em> [assuming <em>B</em>, <em>C</em>]. <i>[PUSH (alternate form)]</i></span></li><li><span>QED!</span></li>';

newSection("8", "Modus ponens");

 var ModusPonens = new Law('<A HREF="https://en.wikipedia.org/wiki/Modus_ponens" target="_blank">MODUS PONENS</A>', [A, IMPLIES(A,B)], B);
 var Exercise81 = new Exercise("8.1(a)", '<A HREF="https://en.wikipedia.org/wiki/Modus_ponens" target="_blank">MODUS PONENS</A> (ASSUMPTION FORM)', [A, assuming(B,A)], B,5);
 Exercise81.unlocks(ModusPonens);
 Exercise81.unlockedBy(Exercise71);
 Exercise81.notes = '<UL><LI><A HREF="https://en.wikipedia.org/wiki/Modus_ponens" target="_blank">Modus ponens</A> is one of the most famous deductive rules.  It asserts that if a statement <I>A</I> is known to be true, and it is also known that <I>A</I> IMPLIES <I>B</I>, then one can conclude that <I>B</I> is also true.<LI> To apply this rule, drag the hypothesis <I>A</I> of an implication onto the implication <I>A</I> IMPLIES <I>B</I>.  The two statements must lie in the same assumption window for the law to be applied.<LI> Incidentally, this exercise (the "assumption" form of Modus ponens) is a useful tool for several subsequent exercises in this text, so keep it in mind.  To apply this exercise, drag a hypothesis <I>A</I> to a conclusion <I>B</I> that has already been obtained under the assumption of <I>A</I>.</UL>';
Exercise81.proof = '<li><span><em>A</em>. <i>[given]</i></span></li><li><span><em>B</em> [assuming <em>A</em>]. <i>[given]</i></span></li><li><span>From <em>B</em> [assuming <em>A</em>]: deduce <em>A</em> IMPLIES <em>B</em>. <i>[<a href="https://en.wikipedia.org/wiki/Deduction_theorem" target="_blank">DEDUCTION THEOREM</a>]</i></span></li><li><span>From <em>A</em>, <em>A</em> IMPLIES <em>B</em>: deduce <em>B</em>. <i>[<a href="https://en.wikipedia.org/wiki/Modus_ponens" target="_blank">MODUS PONENS</a>]</i></span></li><li><span>QED!</span></li>';

 var Exercise81b = new Exercise("8.1(b)", 'REVERSE <A HREF="https://en.wikipedia.org/wiki/Deduction_theorem" target="_blank">DEDUCTION THEOREM</A>', [IMPLIES(A,B)], assuming(B,A),5);
 Exercise81b.unlockedBy(Exercise81);
 Exercise81b.notes = 'This exercise will be useful in some later exercises.  To apply it, click on an implication statement such as <I>A</I> IMPLIES <I>B</I>.';
Exercise81b.proof = '<li><span><em>A</em> IMPLIES <em>B</em>. <i>[given]</i></span></li><li><span>Deduce <em>A</em> [assuming <em>A</em>]. <i>[IMPLICATION INTRODUCTION]</i></span></li><li><span>From <em>A</em> IMPLIES <em>B</em>: deduce <em>A</em> IMPLIES <em>B</em> [assuming <em>A</em>]. <i>[PUSH]</i></span></li><li><span>From <em>A</em> [assuming <em>A</em>], <em>A</em> IMPLIES <em>B</em> [assuming <em>A</em>]: deduce <em>B</em> [assuming <em>A</em>]. <i>[<a href="https://en.wikipedia.org/wiki/Modus_ponens" target="_blank">MODUS PONENS</a>]</i></span></li><li><span>QED!</span></li>';

 var Exercise82 = new Exercise("8.2", 'IMPLIES IS <A HREF="https://en.wikipedia.org/wiki/Transitive_relation" target="_blank">TRANSITIVE</A>', [IMPLIES(A,B), IMPLIES(B,C)], IMPLIES(A,C),7);
 Exercise82.unlockedBy(Exercise81);
Exercise82.proof = '<li><span><em>A</em> IMPLIES <em>B</em>. <i>[given]</i></span></li><li><span><em>B</em> IMPLIES <em>C</em>. <i>[given]</i></span></li><li><span>From <em>A</em> IMPLIES <em>B</em>: deduce <em>B</em> [assuming <em>A</em>]. <i>[REVERSE <a href="https://en.wikipedia.org/wiki/Deduction_theorem" target="_blank">DEDUCTION THEOREM</a>]</i></span></li><li><span>From <em>B</em> IMPLIES <em>C</em>: deduce <em>B</em> IMPLIES <em>C</em> [assuming <em>A</em>]. <i>[PUSH]</i></span></li><li><span>From <em>B</em> [assuming <em>A</em>], <em>B</em> IMPLIES <em>C</em> [assuming <em>A</em>]: deduce <em>C</em> [assuming <em>A</em>]. <i>[<a href="https://en.wikipedia.org/wiki/Modus_ponens" target="_blank">MODUS PONENS</a>]</i></span></li><li><span>From <em>C</em> [assuming <em>A</em>]: deduce <em>A</em> IMPLIES <em>C</em>. <i>[<a href="https://en.wikipedia.org/wiki/Deduction_theorem" target="_blank">DEDUCTION THEOREM</a>]</i></span></li><li><span>QED!</span></li>';

 var Exercise83 = new Exercise("8.3", "", [formulaContext(A), formulaContext(B)], IMPLIES(AND(A,B),AND(B,A)),4);
 Exercise83.unlockedBy(Exercise81);
 Exercise83.notes = "The fact that AND is commutative, proven in Exercise 2.1, will be helpful here.";
Exercise83.proof = '<li><span>Deduce <em>A</em> AND <em>B</em> [assuming <em>A</em> AND <em>B</em>]. <i>[IMPLICATION INTRODUCTION]</i></span></li><li><span>From <em>A</em> AND <em>B</em> [assuming <em>A</em> AND <em>B</em>]: deduce <em>B</em> AND <em>A</em> [assuming <em>A</em> AND <em>B</em>]. <i>[AND IS <a href="https://en.wikipedia.org/wiki/Commutative_property" target="_blank">COMMUTATIVE</a>]</i></span></li><li><span>From <em>B</em> AND <em>A</em> [assuming <em>A</em> AND <em>B</em>]: deduce (<em>A</em> AND <em>B</em>) IMPLIES (<em>B</em> AND <em>A</em>). <i>[<a href="https://en.wikipedia.org/wiki/Deduction_theorem" target="_blank">DEDUCTION THEOREM</a>]</i></span></li><li><span>QED!</span></li>';

 var Exercise84 = new Exercise("8.4(a)", "", [IMPLIES(A,IMPLIES(B,C))], IMPLIES(AND(A,B),C),9);
 Exercise84.unlockedBy(Exercise81);
 Exercise84.notes = 'General tip: one can press "n" to advance to the next available unsolved exercise, or "N" to advance to the last available unsolved exercise (which will usually be the first exercise of the section after the last solved exercise).';
Exercise84.proof = '<li><span><em>A</em> IMPLIES (<em>B</em> IMPLIES <em>C</em>). <i>[given]</i></span></li><li><span>Deduce <em>A</em> AND <em>B</em> [assuming <em>A</em> AND <em>B</em>]. <i>[IMPLICATION INTRODUCTION]</i></span></li><li><span>From <em>A</em> AND <em>B</em> [assuming <em>A</em> AND <em>B</em>]: deduce <em>A</em> [assuming <em>A</em> AND <em>B</em>]. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_elimination" target="_blank">CONJUNCTION ELIMINATION</a> (left)]</i></span></li><li><span>From <em>A</em> IMPLIES (<em>B</em> IMPLIES <em>C</em>): deduce <em>A</em> IMPLIES (<em>B</em> IMPLIES <em>C</em>) [assuming <em>A</em> AND <em>B</em>]. <i>[PUSH]</i></span></li><li><span>From <em>A</em> [assuming <em>A</em> AND <em>B</em>], <em>A</em> IMPLIES (<em>B</em> IMPLIES <em>C</em>) [assuming <em>A</em> AND <em>B</em>]: deduce <em>B</em> IMPLIES <em>C</em> [assuming <em>A</em> AND <em>B</em>]. <i>[<a href="https://en.wikipedia.org/wiki/Modus_ponens" target="_blank">MODUS PONENS</a>]</i></span></li><li><span>From <em>A</em> AND <em>B</em> [assuming <em>A</em> AND <em>B</em>]: deduce <em>B</em> [assuming <em>A</em> AND <em>B</em>]. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_elimination" target="_blank">CONJUNCTION ELIMINATION</a> (right)]</i></span></li><li><span>From <em>B</em> [assuming <em>A</em> AND <em>B</em>], <em>B</em> IMPLIES <em>C</em> [assuming <em>A</em> AND <em>B</em>]: deduce <em>C</em> [assuming <em>A</em> AND <em>B</em>]. <i>[<a href="https://en.wikipedia.org/wiki/Modus_ponens" target="_blank">MODUS PONENS</a>]</i></span></li><li><span>From <em>C</em> [assuming <em>A</em> AND <em>B</em>]: deduce (<em>A</em> AND <em>B</em>) IMPLIES <em>C</em>. <i>[<a href="https://en.wikipedia.org/wiki/Deduction_theorem" target="_blank">DEDUCTION THEOREM</a>]</i></span></li><li><span>QED!</span></li>';


 var Exercise84b = new Exercise("8.4(b)", "", [IMPLIES(AND(A,B),C)], IMPLIES(A,IMPLIES(B,C)),9);
 Exercise84b.unlockedBy(Exercise81);
Exercise84b.proof = '<li><span>(<em>A</em> AND <em>B</em>) IMPLIES <em>C</em>. <i>[given]</i></span></li><li><span>Deduce <em>A</em> [assuming <em>A</em>]. <i>[IMPLICATION INTRODUCTION]</i></span></li><li><span>Deduce <em>B</em> [assuming <em>A</em>, <em>B</em>]. <i>[IMPLICATION INTRODUCTION]</i></span></li><li><span>From <em>A</em> [assuming <em>A</em>]: deduce <em>A</em> [assuming <em>A</em>, <em>B</em>]. <i>[PUSH]</i></span></li><li><span>From <em>A</em> [assuming <em>A</em>, <em>B</em>], <em>B</em> [assuming <em>A</em>, <em>B</em>]: deduce <em>A</em> AND <em>B</em> [assuming <em>A</em>, <em>B</em>]. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_introduction" target=" _blank">CONJUNCTION INTRODUCTION</a>]</i></span></li><li><span>From (<em>A</em> AND <em>B</em>) IMPLIES <em>C</em>: deduce (<em>A</em> AND <em>B</em>) IMPLIES <em>C</em> [assuming <em>A</em>, <em>B</em>]. <i>[DOUBLE PUSH]</i></span></li><li><span>From <em>A</em> AND <em>B</em> [assuming <em>A</em>, <em>B</em>], (<em>A</em> AND <em>B</em>) IMPLIES <em>C</em> [assuming <em>A</em>, <em>B</em>]: deduce <em>C</em> [assuming <em>A</em>, <em>B</em>]. <i>[<a href="https://en.wikipedia.org/wiki/Modus_ponens" target="_blank">MODUS PONENS</a>]</i></span></li><li><span>From <em>C</em> [assuming <em>A</em>, <em>B</em>]: deduce <em>A</em> IMPLIES (<em>B</em> IMPLIES <em>C</em>). <i>[DOUBLE <a href="https://en.wikipedia.org/wiki/Deduction_theorem" target="_blank">DEDUCTION THEOREM</a>]</i></span></li><li><span>QED!</span></li>';

 var Exercise84c = new Exercise("8.4(c)", "", [IMPLIES(A,IMPLIES(B,C))], IMPLIES(B,IMPLIES(A,C)),6);
 Exercise84c.unlockedBy(Exercise81);
 Exercise84c.notes = "Thanks to William Chargin and Junghyeon Park for a short proof.";
 Exercise84c.proof = '<li><span><em>A</em> IMPLIES (<em>B</em> IMPLIES <em>C</em>). <i>[given]</i></span></li><li><span>From <em>A</em> IMPLIES (<em>B</em> IMPLIES <em>C</em>): deduce (<em>A</em> AND <em>B</em>) IMPLIES <em>C</em>. <i>[EXERCISE 8.4(a)]</i></span></li><li><span>Deduce (<em>B</em> AND <em>A</em>) IMPLIES (<em>A</em> AND <em>B</em>). <i>[EXERCISE 8.3]</i></span></li><li><span>From (<em>B</em> AND <em>A</em>) IMPLIES (<em>A</em> AND <em>B</em>), (<em>A</em> AND <em>B</em>) IMPLIES <em>C</em>: deduce (<em>B</em> AND <em>A</em>) IMPLIES <em>C</em>. <i>[IMPLIES IS <a href="https://en.wikipedia.org/wiki/Transitive_relation" target="_blank">TRANSITIVE</a>]</i></span></li><li><span>From (<em>B</em> AND <em>A</em>) IMPLIES <em>C</em>: deduce <em>B</em> IMPLIES (<em>A</em> IMPLIES <em>C</em>). <i>[EXERCISE 8.4(b)]</i></span></li><li><span>QED!</span></li>';

 var Exercise85 = new Exercise("8.5", '<A HREF="https://en.wikipedia.org/wiki/Absorption_(logic)" target="_blank">ABSORPTION</A>', [IMPLIES(A,B)], IMPLIES(A, AND(A,B)),6);
 Exercise85.unlockedBy(Exercise81);
Exercise84.proof = '<li><span><em>A</em> IMPLIES <em>B</em>. <i>[given]</i></span></li><li><span>From <em>A</em> IMPLIES <em>B</em>: deduce <em>B</em> [assuming <em>A</em>]. <i>[REVERSE <a href="https://en.wikipedia.org/wiki/Deduction_theorem" target="_blank">DEDUCTION THEOREM</a>]</i></span></li><li><span>Deduce <em>A</em> [assuming <em>A</em>]. <i>[IMPLICATION INTRODUCTION]</i></span></li><li><span>From <em>A</em> [assuming <em>A</em>], <em>B</em> [assuming <em>A</em>]: deduce <em>A</em> AND <em>B</em> [assuming <em>A</em>]. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_introduction" target=" _blank">CONJUNCTION INTRODUCTION</a>]</i></span></li><li><span>From <em>A</em> AND <em>B</em> [assuming <em>A</em>]: deduce <em>A</em> IMPLIES (<em>A</em> AND <em>B</em>). <i>[<a href="https://en.wikipedia.org/wiki/Deduction_theorem" target="_blank">DEDUCTION THEOREM</a>]</i></span></li><li><span>QED!</span></li>';

newSection("9", "Case analysis");

 var caseAnalysis = new Law('<A HREF="https://en.wikipedia.org/wiki/Proof_by_exhaustion" target="_blank">CASE ANALYSIS</A>', [assuming(C,A), assuming(C,B)], assuming(C,OR(A,B)),8);
 var Exercise91 = new Exercise("9.1(a)", "OR IS COMMUTATIVE", [OR(A,B)], OR(B,A),8);
 Exercise91.unlocks(caseAnalysis);
 Exercise91.unlockedBy(Exercise81);
 Exercise91.notes = '<UL><LI> We now return to the laws of disjunction (i.e., the laws of the "OR" connective).  <LI> To complement the laws of <A HREF="https://en.wikipedia.org/wiki/Disjunction_introduction" target="_blank">disjunction introduction</A> from Section 3, one has the law of <A HREF="https://en.wikipedia.org/wiki/Proof_by_exhaustion" target="_blank">case analysis</A>: if a statement <I>C</I> is known to be true under the assumption <I>A</I>, and also known to be true under the assumption <I>B</I>, then it is true under the assumption <I>A</I> OR <I>B</I>.  <LI> For instance, to solve the current exercise, first establish <I>B</I> OR <I>A</I> under the assumption of <I>A</I>, and then separately establish <I>B</I> OR <I>A</I> under the assumption of <I>B</I>.  Then drag the two conclusions together! <LI> Splitting into cases is a common technique in mathematics.  For instance, to prove a statement <I>A</I> involving a natural number <i>n</i>, one might first prove the statement <I>A</I> assuming <i>n</I> is odd, and then prove it assuming <I>n</I> is even.  Since <i>n</I> has to be odd or even, the law of case analysis then establishes the statement <I>A</I> unconditionally.';
Exercise91.proof = '<li><span><em>A</em> OR <em>B</em>. <i>[given]</i></span></li><li><span>Deduce <em>A</em> [assuming <em>A</em>]. <i>[IMPLICATION INTRODUCTION]</i></span></li><li><span>From <em>A</em> [assuming <em>A</em>]: deduce <em>B</em> OR <em>A</em> [assuming <em>A</em>]. <i>[<a href="https://en.wikipedia.org/wiki/Disjunction_introduction" target="_blank">DISJUNCTION INTRODUCTION</a> (right)]</i></span></li><li><span>Deduce <em>B</em> [assuming <em>B</em>]. <i>[IMPLICATION INTRODUCTION]</i></span></li><li><span>From <em>B</em> [assuming <em>B</em>]: deduce <em>B</em> OR <em>A</em> [assuming <em>B</em>]. <i>[<a href="https://en.wikipedia.org/wiki/Disjunction_introduction" target="_blank">DISJUNCTION INTRODUCTION</a> (left)]</i></span></li><li><span>From <em>B</em> OR <em>A</em> [assuming <em>A</em>], <em>B</em> OR <em>A</em> [assuming <em>B</em>]: deduce <em>B</em> OR <em>A</em> [assuming <em>A</em> OR <em>B</em>]. <i>[<a href="https://en.wikipedia.org/wiki/Proof_by_exhaustion" target="_blank">CASE ANALYSIS</a>]</i></span></li><li><span>From <em>A</em> OR <em>B</em>, <em>B</em> OR <em>A</em> [assuming <em>A</em> OR <em>B</em>]: deduce <em>B</em> OR <em>A</em>. <i>[<a href="https://en.wikipedia.org/wiki/Modus_ponens" target="_blank">MODUS PONENS</a> (ASSUMPTION FORM)]</i></span></li><li><span>QED!</span></li>';

var Exercise91b = new Exercise("9.1(b)", 'OR IS <A HREF="https://en.wikipedia.org/wiki/Idempotence" target="_blank">IDEMPOTENT</A> (right)', [OR(A,A)], A,5);
 Exercise91b.unlockedBy(Exercise91);
 Exercise91b.notes = "This is the reverse of Exercise 3.1(b).";
Exercise91b.proof = '<li><span><em>A</em> OR <em>A</em>. <i>[given]</i></span></li><li><span>Deduce <em>A</em> [assuming <em>A</em>]. <i>[IMPLICATION INTRODUCTION]</i></span></li><li><span>From <em>A</em> [assuming <em>A</em>], <em>A</em> [assuming <em>A</em>]: deduce <em>A</em> [assuming <em>A</em> OR <em>A</em>]. <i>[<a href="https://en.wikipedia.org/wiki/Proof_by_exhaustion" target="_blank">CASE ANALYSIS</a>]</i></span></li><li><span>From <em>A</em> OR <em>A</em>, <em>A</em> [assuming <em>A</em> OR <em>A</em>]: deduce <em>A</em>. <i>[<a href="https://en.wikipedia.org/wiki/Modus_ponens" target="_blank">MODUS PONENS</a> (ASSUMPTION FORM)]</i></span></li><li><span>QED!</span></li>';

 var Exercise92 = new Exercise("9.2(a)", 'OR IS <A HREF="https://en.wikipedia.org/wiki/Associative_property" target="_blank">ASSOCIATIVE</A> (left)', [OR(OR(A,B),C)], OR(A,OR(B,C)),12);
 Exercise92.unlockedBy(Exercise91);
 Exercise92.notes = "<UL><LI> From this point onwards, the solutions will begin to be somewhat lengthy.</LI> <LI> Thanks to Steve Trout, William Chargin, Daniel Spivak, and Keith Winstein for contributing a (relatively) short proof, and Anders Kaseorg for an even shorter proof.</LI></UL>";
Exercise92.proof = '<li><span>(<em>A</em> OR <em>B</em>) OR <em>C</em>. <i>[given]</i></span></li><li><span>Deduce <em>A</em> [assuming <em>A</em>]. <i>[IMPLICATION INTRODUCTION]</i></span></li><li><span>From <em>A</em> [assuming <em>A</em>]: deduce <em>A</em> OR (<em>B</em> OR <em>C</em>) [assuming <em>A</em>]. <i>[<a href="https://en.wikipedia.org/wiki/Disjunction_introduction" target="_blank">DISJUNCTION INTRODUCTION</a> (left)]</i></span></li><li><span>Deduce <em>B</em> [assuming <em>B</em>]. <i>[IMPLICATION INTRODUCTION]</i></span></li><li><span>From <em>B</em> [assuming <em>B</em>]: deduce <em>A</em> OR (<em>B</em> OR <em>C</em>) [assuming <em>B</em>]. <i>[EXERCISE 3.1(a)]</i></span></li><li><span>Deduce <em>C</em> [assuming <em>C</em>]. <i>[IMPLICATION INTRODUCTION]</i></span></li><li><span>From <em>C</em> [assuming <em>C</em>]: deduce <em>B</em> OR <em>C</em> [assuming <em>C</em>]. <i>[<a href="https://en.wikipedia.org/wiki/Disjunction_introduction" target="_blank">DISJUNCTION INTRODUCTION</a> (right)]</i></span></li><li><span>From <em>B</em> OR <em>C</em> [assuming <em>C</em>]: deduce <em>A</em> OR (<em>B</em> OR <em>C</em>) [assuming <em>C</em>]. <i>[<a href="https://en.wikipedia.org/wiki/Disjunction_introduction" target="_blank">DISJUNCTION INTRODUCTION</a> (right)]</i></span></li><li><span>From <em>A</em> OR (<em>B</em> OR <em>C</em>) [assuming <em>A</em>], <em>A</em> OR (<em>B</em> OR <em>C</em>) [assuming <em>B</em>]: deduce <em>A</em> OR (<em>B</em> OR <em>C</em>) [assuming <em>A</em> OR <em>B</em>]. <i>[<a href="https://en.wikipedia.org/wiki/Proof_by_exhaustion" target="_blank">CASE ANALYSIS</a>]</i></span></li><li><span>From <em>A</em> OR (<em>B</em> OR <em>C</em>) [assuming <em>A</em> OR <em>B</em>], <em>A</em> OR (<em>B</em> OR <em>C</em>) [assuming <em>C</em>]: deduce <em>A</em> OR (<em>B</em> OR <em>C</em>) [assuming (<em>A</em> OR <em>B</em>) OR <em>C</em>]. <i>[<a href="https://en.wikipedia.org/wiki/Proof_by_exhaustion" target="_blank">CASE ANALYSIS</a>]</i></span></li><li><span>From (<em>A</em> OR <em>B</em>) OR <em>C</em>, <em>A</em> OR (<em>B</em> OR <em>C</em>) [assuming (<em>A</em> OR <em>B</em>) OR <em>C</em>]: deduce <em>A</em> OR (<em>B</em> OR <em>C</em>). <i>[<a href="https://en.wikipedia.org/wiki/Modus_ponens" target="_blank">MODUS PONENS</a> (ASSUMPTION FORM)]</i></span></li><li><span>QED! (again)</span></li>';

 var Exercise92b = new Exercise("9.2(b)", 'OR IS <A HREF="https://en.wikipedia.org/wiki/Associative_property" target="_blank">ASSOCIATIVE</A> (right)', [OR(A,OR(B,C))], OR(OR(A,B),C),7);
 Exercise92b.unlockedBy(Exercise91);
 Exercise92b.notes = "Thanks to William Chargin for a short proof.";
Exercise92b.proof = '<li><span><em>A</em> OR (<em>B</em> OR <em>C</em>). <i>[given]</i></span></li><li><span>From <em>A</em> OR (<em>B</em> OR <em>C</em>): deduce (<em>B</em> OR <em>C</em>) OR <em>A</em>. <i>[OR IS COMMUTATIVE]</i></span></li><li><span>From (<em>B</em> OR <em>C</em>) OR <em>A</em>: deduce <em>B</em> OR (<em>C</em> OR <em>A</em>). <i>[OR IS <a href="https://en.wikipedia.org/wiki/Associative_property" target="_blank">ASSOCIATIVE</a> (left)]</i></span></li><li><span>From <em>B</em> OR (<em>C</em> OR <em>A</em>): deduce (<em>C</em> OR <em>A</em>) OR <em>B</em>. <i>[OR IS COMMUTATIVE]</i></span></li><li><span>From (<em>C</em> OR <em>A</em>) OR <em>B</em>: deduce <em>C</em> OR (<em>A</em> OR <em>B</em>). <i>[OR IS <a href="https://en.wikipedia.org/wiki/Associative_property" target="_blank">ASSOCIATIVE</a> (left)]</i></span></li><li><span>From <em>C</em> OR (<em>A</em> OR <em>B</em>): deduce (<em>A</em> OR <em>B</em>) OR <em>C</em>. <i>[OR IS COMMUTATIVE]</i></span></li><li><span>QED!</span></li>';

 var Exercise93 = new Exercise("9.3(a)", 'OR <A HREF="https://en.wikipedia.org/wiki/Distributive_property" target="_blank">DISTRIBUTES</A> OVER AND (left)', [OR(A, AND(B,C))], AND(OR(A,B), OR(A,C)),14);
 Exercise93.unlockedBy(Exercise91);
Exercise93.proof = '<li><span><em>A</em> OR (<em>B</em> AND <em>C</em>). <i>[given]</i></span></li><li><span>Deduce <em>A</em> [assuming <em>A</em>]. <i>[IMPLICATION INTRODUCTION]</i></span></li><li><span>From <em>A</em> [assuming <em>A</em>]: deduce <em>A</em> OR <em>B</em> [assuming <em>A</em>]. <i>[<a href="https://en.wikipedia.org/wiki/Disjunction_introduction" target="_blank">DISJUNCTION INTRODUCTION</a> (left)]</i></span></li><li><span>From <em>A</em> [assuming <em>A</em>]: deduce <em>A</em> OR <em>C</em> [assuming <em>A</em>]. <i>[<a href="https://en.wikipedia.org/wiki/Disjunction_introduction" target="_blank">DISJUNCTION INTRODUCTION</a> (left)]</i></span></li><li><span>From <em>A</em> OR <em>B</em> [assuming <em>A</em>], <em>A</em> OR <em>C</em> [assuming <em>A</em>]: deduce (<em>A</em> OR <em>B</em>) AND (<em>A</em> OR <em>C</em>) [assuming <em>A</em>]. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_introduction" target=" _blank">CONJUNCTION INTRODUCTION</a>]</i></span></li><li><span>Deduce <em>B</em> AND <em>C</em> [assuming <em>B</em> AND <em>C</em>]. <i>[IMPLICATION INTRODUCTION]</i></span></li><li><span>From <em>B</em> AND <em>C</em> [assuming <em>B</em> AND <em>C</em>]: deduce <em>B</em> [assuming <em>B</em> AND <em>C</em>]. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_elimination" target="_blank">CONJUNCTION ELIMINATION</a> (left)]</i></span></li><li><span>From <em>B</em> AND <em>C</em> [assuming <em>B</em> AND <em>C</em>]: deduce <em>C</em> [assuming <em>B</em> AND <em>C</em>]. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_elimination" target="_blank">CONJUNCTION ELIMINATION</a> (right)]</i></span></li><li><span>From <em>B</em> [assuming <em>B</em> AND <em>C</em>]: deduce <em>A</em> OR <em>B</em> [assuming <em>B</em> AND <em>C</em>]. <i>[<a href="https://en.wikipedia.org/wiki/Disjunction_introduction" target="_blank">DISJUNCTION INTRODUCTION</a> (right)]</i></span></li><li><span>From <em>C</em> [assuming <em>B</em> AND <em>C</em>]: deduce <em>A</em> OR <em>C</em> [assuming <em>B</em> AND <em>C</em>]. <i>[<a href="https://en.wikipedia.org/wiki/Disjunction_introduction" target="_blank">DISJUNCTION INTRODUCTION</a> (right)]</i></span></li><li><span>From <em>A</em> OR <em>B</em> [assuming <em>B</em> AND <em>C</em>], <em>A</em> OR <em>C</em> [assuming <em>B</em> AND <em>C</em>]: deduce (<em>A</em> OR <em>B</em>) AND (<em>A</em> OR <em>C</em>) [assuming <em>B</em> AND <em>C</em>]. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_introduction" target=" _blank">CONJUNCTION INTRODUCTION</a>]</i></span></li><li><span>From (<em>A</em> OR <em>B</em>) AND (<em>A</em> OR <em>C</em>) [assuming <em>A</em>], (<em>A</em> OR <em>B</em>) AND (<em>A</em> OR <em>C</em>) [assuming <em>B</em> AND <em>C</em>]: deduce (<em>A</em> OR <em>B</em>) AND (<em>A</em> OR <em>C</em>) [assuming <em>A</em> OR (<em>B</em> AND <em>C</em>)]. <i>[<a href="https://en.wikipedia.org/wiki/Proof_by_exhaustion" target="_blank">CASE ANALYSIS</a>]</i></span></li><li><span>From <em>A</em> OR (<em>B</em> AND <em>C</em>), (<em>A</em> OR <em>B</em>) AND (<em>A</em> OR <em>C</em>) [assuming <em>A</em> OR (<em>B</em> AND <em>C</em>)]: deduce (<em>A</em> OR <em>B</em>) AND (<em>A</em> OR <em>C</em>). <i>[<a href="https://en.wikipedia.org/wiki/Modus_ponens" target="_blank">MODUS PONENS</a> (ASSUMPTION FORM)]</i></span></li><li><span>QED!</span></li>';

 var Exercise93b = new Exercise("9.3(b)", 'AND <A HREF="https://en.wikipedia.org/wiki/Distributive_property" target="_blank">DISTRIBUTES</A> OVER OR (left)', [AND(A, OR(B,C))], OR(AND(A,B), AND(A,C)),14);
Exercise93b.unlockedBy(Exercise91);
Exercise93b.proof = '<li><span><em>A</em> AND (<em>B</em> OR <em>C</em>). <i>[given]</i></span></li><li><span>From <em>A</em> AND (<em>B</em> OR <em>C</em>): deduce <em>A</em>. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_elimination" target="_blank">CONJUNCTION ELIMINATION</a> (left)]</i></span></li><li><span>From <em>A</em> AND (<em>B</em> OR <em>C</em>): deduce <em>B</em> OR <em>C</em>. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_elimination" target="_blank">CONJUNCTION ELIMINATION</a> (right)]</i></span></li><li><span>Deduce <em>B</em> [assuming <em>B</em>]. <i>[IMPLICATION INTRODUCTION]</i></span></li><li><span>From <em>A</em>: deduce <em>A</em> [assuming <em>B</em>]. <i>[PUSH]</i></span></li><li><span>From <em>A</em> [assuming <em>B</em>], <em>B</em> [assuming <em>B</em>]: deduce <em>A</em> AND <em>B</em> [assuming <em>B</em>]. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_introduction" target=" _blank">CONJUNCTION INTRODUCTION</a>]</i></span></li><li><span>From <em>A</em> AND <em>B</em> [assuming <em>B</em>]: deduce (<em>A</em> AND <em>B</em>) OR (<em>A</em> AND <em>C</em>) [assuming <em>B</em>]. <i>[<a href="https://en.wikipedia.org/wiki/Disjunction_introduction" target="_blank">DISJUNCTION INTRODUCTION</a> (left)]</i></span></li><li><span>Deduce <em>C</em> [assuming <em>C</em>]. <i>[IMPLICATION INTRODUCTION]</i></span></li><li><span>From <em>A</em>: deduce <em>A</em> [assuming <em>C</em>]. <i>[PUSH]</i></span></li><li><span>From <em>A</em> [assuming <em>C</em>], <em>C</em> [assuming <em>C</em>]: deduce <em>A</em> AND <em>C</em> [assuming <em>C</em>]. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_introduction" target=" _blank">CONJUNCTION INTRODUCTION</a>]</i></span></li><li><span>From <em>A</em> AND <em>C</em> [assuming <em>C</em>]: deduce (<em>A</em> AND <em>B</em>) OR (<em>A</em> AND <em>C</em>) [assuming <em>C</em>]. <i>[<a href="https://en.wikipedia.org/wiki/Disjunction_introduction" target="_blank">DISJUNCTION INTRODUCTION</a> (right)]</i></span></li><li><span>From (<em>A</em> AND <em>B</em>) OR (<em>A</em> AND <em>C</em>) [assuming <em>B</em>], (<em>A</em> AND <em>B</em>) OR (<em>A</em> AND <em>C</em>) [assuming <em>C</em>]: deduce (<em>A</em> AND <em>B</em>) OR (<em>A</em> AND <em>C</em>) [assuming <em>B</em> OR <em>C</em>]. <i>[<a href="https://en.wikipedia.org/wiki/Proof_by_exhaustion" target="_blank">CASE ANALYSIS</a>]</i></span></li><li><span>From <em>B</em> OR <em>C</em>, (<em>A</em> AND <em>B</em>) OR (<em>A</em> AND <em>C</em>) [assuming <em>B</em> OR <em>C</em>]: deduce (<em>A</em> AND <em>B</em>) OR (<em>A</em> AND <em>C</em>). <i>[<a href="https://en.wikipedia.org/wiki/Modus_ponens" target="_blank">MODUS PONENS</a> (ASSUMPTION FORM)]</i></span></li><li><span>QED!</span></li>';

 var Exercise93c = new Exercise("9.3(c)", 'AND <A HREF="https://en.wikipedia.org/wiki/Distributive_property" target="_blank">DISTRIBUTES</A> OVER OR (right)', [OR(AND(A,B), AND(A,C))], AND(A, OR(B,C)) ,14);
Exercise93c.unlockedBy(Exercise91);
Exercise93c.proof = '<li><span>(<em>A</em> AND <em>B</em>) OR (<em>A</em> AND <em>C</em>). <i>[given]</i></span></li><li><span>Deduce <em>A</em> AND <em>B</em> [assuming <em>A</em> AND <em>B</em>]. <i>[IMPLICATION INTRODUCTION]</i></span></li><li><span>From <em>A</em> AND <em>B</em> [assuming <em>A</em> AND <em>B</em>]: deduce <em>A</em> [assuming <em>A</em> AND <em>B</em>]. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_elimination" target="_blank">CONJUNCTION ELIMINATION</a> (left)]</i></span></li><li><span>From <em>A</em> AND <em>B</em> [assuming <em>A</em> AND <em>B</em>]: deduce <em>B</em> [assuming <em>A</em> AND <em>B</em>]. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_elimination" target="_blank">CONJUNCTION ELIMINATION</a> (right)]</i></span></li><li><span>From <em>B</em> [assuming <em>A</em> AND <em>B</em>]: deduce <em>B</em> OR <em>C</em> [assuming <em>A</em> AND <em>B</em>]. <i>[<a href="https://en.wikipedia.org/wiki/Disjunction_introduction" target="_blank">DISJUNCTION INTRODUCTION</a> (left)]</i></span></li><li><span>From <em>A</em> [assuming <em>A</em> AND <em>B</em>], <em>B</em> OR <em>C</em> [assuming <em>A</em> AND <em>B</em>]: deduce <em>A</em> AND (<em>B</em> OR <em>C</em>) [assuming <em>A</em> AND <em>B</em>]. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_introduction" target=" _blank">CONJUNCTION INTRODUCTION</a>]</i></span></li><li><span>Deduce <em>A</em> AND <em>C</em> [assuming <em>A</em> AND <em>C</em>]. <i>[IMPLICATION INTRODUCTION]</i></span></li><li><span>From <em>A</em> AND <em>C</em> [assuming <em>A</em> AND <em>C</em>]: deduce <em>A</em> [assuming <em>A</em> AND <em>C</em>]. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_elimination" target="_blank">CONJUNCTION ELIMINATION</a> (left)]</i></span></li><li><span>From <em>A</em> AND <em>C</em> [assuming <em>A</em> AND <em>C</em>]: deduce <em>C</em> [assuming <em>A</em> AND <em>C</em>]. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_elimination" target="_blank">CONJUNCTION ELIMINATION</a> (right)]</i></span></li><li><span>From <em>C</em> [assuming <em>A</em> AND <em>C</em>]: deduce <em>B</em> OR <em>C</em> [assuming <em>A</em> AND <em>C</em>]. <i>[<a href="https://en.wikipedia.org/wiki/Disjunction_introduction" target="_blank">DISJUNCTION INTRODUCTION</a> (right)]</i></span></li><li><span>From <em>A</em> [assuming <em>A</em> AND <em>C</em>], <em>B</em> OR <em>C</em> [assuming <em>A</em> AND <em>C</em>]: deduce <em>A</em> AND (<em>B</em> OR <em>C</em>) [assuming <em>A</em> AND <em>C</em>]. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_introduction" target=" _blank">CONJUNCTION INTRODUCTION</a>]</i></span></li><li><span>From <em>A</em> AND (<em>B</em> OR <em>C</em>) [assuming <em>A</em> AND <em>B</em>], <em>A</em> AND (<em>B</em> OR <em>C</em>) [assuming <em>A</em> AND <em>C</em>]: deduce <em>A</em> AND (<em>B</em> OR <em>C</em>) [assuming (<em>A</em> AND <em>B</em>) OR (<em>A</em> AND <em>C</em>)]. <i>[<a href="https://en.wikipedia.org/wiki/Proof_by_exhaustion" target="_blank">CASE ANALYSIS</a>]</i></span></li><li><span>From (<em>A</em> AND <em>B</em>) OR (<em>A</em> AND <em>C</em>), <em>A</em> AND (<em>B</em> OR <em>C</em>) [assuming (<em>A</em> AND <em>B</em>) OR (<em>A</em> AND <em>C</em>)]: deduce <em>A</em> AND (<em>B</em> OR <em>C</em>). <i>[<a href="https://en.wikipedia.org/wiki/Modus_ponens" target="_blank">MODUS PONENS</a> (ASSUMPTION FORM)]</i></span></li><li><span>QED!</span></li>';

 var Exercise93d = new Exercise("9.3(d)", 'OR <A HREF="https://en.wikipedia.org/wiki/Distributive_property" target="_blank">DISTRIBUTES</A> OVER AND (right)', [AND(OR(A,B), OR(A,C))], OR(A, AND(B,C)) ,16);
 Exercise93d.unlockedBy(Exercise91);
 Exercise93d.notes = "Thanks to Jan Wieners for the short proof.";
 Exercise93d.proof = '<li><span>(<em>A</em> OR <em>B</em>) AND (<em>A</em> OR <em>C</em>). <i>[given]</i></span></li><li><span>Deduce <em>B</em> [assuming <em>B</em>]. <i>[IMPLICATION INTRODUCTION]</i></span></li><li><span>From (<em>A</em> OR <em>B</em>) AND (<em>A</em> OR <em>C</em>): deduce <em>A</em> OR <em>C</em>. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_elimination" target="_blank">CONJUNCTION ELIMINATION</a> (right)]</i></span></li><li><span>From <em>A</em> OR <em>C</em>: deduce <em>A</em> OR <em>C</em> [assuming <em>B</em>]. <i>[PUSH]</i></span></li><li><span>From <em>B</em> [assuming <em>B</em>], <em>A</em> OR <em>C</em> [assuming <em>B</em>]: deduce <em>B</em> AND (<em>A</em> OR <em>C</em>) [assuming <em>B</em>]. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_introduction" target=" _blank">CONJUNCTION INTRODUCTION</a>]</i></span></li><li><span>From <em>B</em> AND (<em>A</em> OR <em>C</em>) [assuming <em>B</em>]: deduce (<em>B</em> AND <em>A</em>) OR (<em>B</em> AND <em>C</em>) [assuming <em>B</em>]. <i>[AND <a href="https://en.wikipedia.org/wiki/Distributive_property" target="_blank">DISTRIBUTES</a> OVER OR (left)]</i></span></li><li><span>Deduce <em>A</em> [assuming <em>A</em>]. <i>[IMPLICATION INTRODUCTION]</i></span></li><li><span>From <em>A</em> [assuming <em>A</em>]: deduce <em>A</em> OR (<em>B</em> AND <em>C</em>) [assuming <em>A</em>]. <i>[<a href="https://en.wikipedia.org/wiki/Disjunction_introduction" target="_blank">DISJUNCTION INTRODUCTION</a> (left)]</i></span></li><li><span>From (<em>B</em> AND <em>A</em>) OR (<em>B</em> AND <em>C</em>) [assuming <em>B</em>]: deduce (<em>B</em> AND <em>C</em>) OR (<em>B</em> AND <em>A</em>) [assuming <em>B</em>]. <i>[OR IS COMMUTATIVE]</i></span></li><li><span>From (<em>B</em> AND <em>C</em>) OR (<em>B</em> AND <em>A</em>) [assuming <em>B</em>]: deduce ((<em>B</em> AND <em>C</em>) OR <em>B</em>) AND ((<em>B</em> AND <em>C</em>) OR <em>A</em>) [assuming <em>B</em>]. <i>[OR <a href="https://en.wikipedia.org/wiki/Distributive_property" target="_blank">DISTRIBUTES</a> OVER AND (left)]</i></span></li><li><span>From ((<em>B</em> AND <em>C</em>) OR <em>B</em>) AND ((<em>B</em> AND <em>C</em>) OR <em>A</em>) [assuming <em>B</em>]: deduce (<em>B</em> AND <em>C</em>) OR <em>A</em> [assuming <em>B</em>]. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_elimination" target="_blank">CONJUNCTION ELIMINATION</a> (right)]</i></span></li><li><span>From (<em>B</em> AND <em>C</em>) OR <em>A</em> [assuming <em>B</em>]: deduce <em>A</em> OR (<em>B</em> AND <em>C</em>) [assuming <em>B</em>]. <i>[OR IS COMMUTATIVE]</i></span></li><li><span>From <em>A</em> OR (<em>B</em> AND <em>C</em>) [assuming <em>A</em>], <em>A</em> OR (<em>B</em> AND <em>C</em>) [assuming <em>B</em>]: deduce <em>A</em> OR (<em>B</em> AND <em>C</em>) [assuming <em>A</em> OR <em>B</em>]. <i>[<a href="https://en.wikipedia.org/wiki/Proof_by_exhaustion" target="_blank">CASE ANALYSIS</a>]</i></span></li><li><span>From (<em>A</em> OR <em>B</em>) AND (<em>A</em> OR <em>C</em>): deduce <em>A</em> OR <em>B</em>. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_elimination" target="_blank">CONJUNCTION ELIMINATION</a> (left)]</i></span></li><li><span>From <em>A</em> OR <em>B</em>, <em>A</em> OR (<em>B</em> AND <em>C</em>) [assuming <em>A</em> OR <em>B</em>]: deduce <em>A</em> OR (<em>B</em> AND <em>C</em>). <i>[<a href="https://en.wikipedia.org/wiki/Modus_ponens" target="_blank">MODUS PONENS</a> (ASSUMPTION FORM)]</i></span></li><li><span>QED!</span></li>';

 var Exercise94 = new Exercise("9.4(a)", '<A HREF="https://en.wikipedia.org/wiki/Constructive_dilemma" target="_blank">CONSTRUCTIVE DILEMMA</A> (left)', [OR(A,B), IMPLIES(A,C)], OR(C,B),9);
 Exercise94.unlockedBy(Exercise91);
Exercise94.proof = '<li><span><em>A</em> OR <em>B</em>. <i>[given]</i></span></li><li><span><em>A</em> IMPLIES <em>C</em>. <i>[given]</i></span></li><li><span>From <em>A</em> IMPLIES <em>C</em>: deduce <em>C</em> [assuming <em>A</em>]. <i>[REVERSE <a href="https://en.wikipedia.org/wiki/Deduction_theorem" target="_blank">DEDUCTION THEOREM</a>]</i></span></li><li><span>From <em>C</em> [assuming <em>A</em>]: deduce <em>C</em> OR <em>B</em> [assuming <em>A</em>]. <i>[<a href="https://en.wikipedia.org/wiki/Disjunction_introduction" target="_blank">DISJUNCTION INTRODUCTION</a> (left)]</i></span></li><li><span>Deduce <em>B</em> [assuming <em>B</em>]. <i>[IMPLICATION INTRODUCTION]</i></span></li><li><span>From <em>B</em> [assuming <em>B</em>]: deduce <em>C</em> OR <em>B</em> [assuming <em>B</em>]. <i>[<a href="https://en.wikipedia.org/wiki/Disjunction_introduction" target="_blank">DISJUNCTION INTRODUCTION</a> (right)]</i></span></li><li><span>From <em>C</em> OR <em>B</em> [assuming <em>A</em>], <em>C</em> OR <em>B</em> [assuming <em>B</em>]: deduce <em>C</em> OR <em>B</em> [assuming <em>A</em> OR <em>B</em>]. <i>[<a href="https://en.wikipedia.org/wiki/Proof_by_exhaustion" target="_blank">CASE ANALYSIS</a>]</i></span></li><li><span>From <em>A</em> OR <em>B</em>, <em>C</em> OR <em>B</em> [assuming <em>A</em> OR <em>B</em>]: deduce <em>C</em> OR <em>B</em>. <i>[<a href="https://en.wikipedia.org/wiki/Modus_ponens" target="_blank">MODUS PONENS</a> (ASSUMPTION FORM)]</i></span></li><li><span>QED!</span></li>';

 var Exercise94b = new Exercise("9.4(b)", '<A HREF="https://en.wikipedia.org/wiki/Constructive_dilemma" target="_blank">CONSTRUCTIVE DILEMMA</A> (right)', [OR(A,B), IMPLIES(B,C)], OR(A,C),6);
 Exercise94b.unlockedBy(Exercise91);
 Exercise94b.notes = "Thanks to William Chargin for a short proof.";
Exercise94b.proof = '<li><span><em>A</em> OR <em>B</em>. <i>[given]</i></span></li><li><span><em>B</em> IMPLIES <em>C</em>. <i>[given]</i></span></li><li><span>From <em>A</em> OR <em>B</em>: deduce <em>B</em> OR <em>A</em>. <i>[OR IS COMMUTATIVE]</i></span></li><li><span>From <em>B</em> OR <em>A</em>, <em>B</em> IMPLIES <em>C</em>: deduce <em>C</em> OR <em>A</em>. <i>[<a href="https://en.wikipedia.org/wiki/Constructive_dilemma" target="_blank">CONSTRUCTIVE DILEMMA</a> (left)]</i></span></li><li><span>From <em>C</em> OR <em>A</em>: deduce <em>A</em> OR <em>C</em>. <i>[OR IS COMMUTATIVE]</i></span></li><li><span>QED!</span></li>';

 var Exercise94c = new Exercise("9.4(c)", '<A HREF="https://en.wikipedia.org/wiki/Constructive_dilemma" target="_blank">CONSTRUCTIVE DILEMMA</A> (both)', [OR(A,B), IMPLIES(A,C), IMPLIES(B,D)], OR(C,D),6);
 Exercise94c.unlockedBy(Exercise91);
 Exercise94c.notes = "<UL> <LI> This exercise involves three hypotheses, so it cannot be directly invoked by clicking or dragging on these hypotheses.  However, if one drags the first hypothesis to the second and then CTRL-clicks the third, or if one clicks the first and then CTRL-clicks the next two, one will be able to apply this exercise (once it is proven), of course.  Alternatively, one can use the two halves of this dilemma in Exercise 19(a) and Exercise 19(b) as a substitute. <LI> This exercise can be solved quickly if one uses Exercises 9.4(a) and 9.4(b).  (Of course, you must then solve these exercises first!)</UL>";
Exercise94c.proof = '<li><span><em>A</em> OR <em>B</em>. <i>[given]</i></span></li><li><span><em>A</em> IMPLIES <em>C</em>. <i>[given]</i></span></li><li><span><em>B</em> IMPLIES <em>D</em>. <i>[given]</i></span></li><li><span>From <em>A</em> OR <em>B</em>, <em>A</em> IMPLIES <em>C</em>: deduce <em>C</em> OR <em>B</em>. <i>[<a href="https://en.wikipedia.org/wiki/Constructive_dilemma" target="_blank">CONSTRUCTIVE DILEMMA</a> (left)]</i></span></li><li><span>From <em>C</em> OR <em>B</em>, <em>B</em> IMPLIES <em>D</em>: deduce <em>C</em> OR <em>D</em>. <i>[<a href="https://en.wikipedia.org/wiki/Constructive_dilemma" target="_blank">CONSTRUCTIVE DILEMMA</a> (right)]</i></span></li><li><span>QED!</span></li>';

var Exercise95 = new Exercise("9.5(a)", '<A HREF="https://en.wikipedia.org/wiki/Monotonic_function" target="_blank">MONOTONICITY</A> OF AND', [formulaContext(C), IMPLIES(A,B)], IMPLIES(AND(A,C), AND(B,C)),6);
Exercise95.unlockedBy(Exercise91);
Exercise95.notes = 'Thanks to dP dt for the short proof, and Anders Kaseorg for a shorter proof (located using computer search!).';
Exercise95.proof = '<li><span><em>A</em> IMPLIES <em>B</em>. <i>[given]</i></span></li><li><span>Deduce (<em>B</em> AND <em>C</em>) IMPLIES (<em>B</em> AND <em>C</em>). <i>[IMPLIES IS <a href="https://en.wikipedia.org/wiki/Idempotence&quot;" target="_blank">IDEMPOTENT</a>]</i></span></li><li><span>From (<em>B</em> AND <em>C</em>) IMPLIES (<em>B</em> AND <em>C</em>): deduce <em>B</em> IMPLIES (<em>C</em> IMPLIES (<em>B</em> AND <em>C</em>)). <i>[EXERCISE 8.4(b)]</i></span></li><li><span>From <em>A</em> IMPLIES <em>B</em>, <em>B</em> IMPLIES (<em>C</em> IMPLIES (<em>B</em> AND <em>C</em>)): deduce <em>A</em> IMPLIES (<em>C</em> IMPLIES (<em>B</em> AND <em>C</em>)). <i>[IMPLIES IS <a href="https://en.wikipedia.org/wiki/Transitive_relation" target="_blank">TRANSITIVE</a>]</i></span></li><li><span>From <em>A</em> IMPLIES (<em>C</em> IMPLIES (<em>B</em> AND <em>C</em>)): deduce (<em>A</em> AND <em>C</em>) IMPLIES (<em>B</em> AND <em>C</em>). <i>[EXERCISE 8.4(a)]</i></span></li><li><span>QED!</span></li>';

var Exercise95b = new Exercise("9.5(b)", '<A HREF="https://en.wikipedia.org/wiki/Monotonic_function" target="_blank">MONOTONICITY</A> OF OR', [formulaContext(C), IMPLIES(A,B)], IMPLIES(OR(A,C), OR(B,C)),6);
Exercise95b.unlockedBy(Exercise91);
Exercise95b.notes = 'Thanks to Pace Nielsen, Andrew Liftin, Alan Lu, and Ephim Kolmogorov for the short proof.';
Exercise95b.proof = '<li><span><em>A</em> IMPLIES <em>B</em>. <i>[given]</i></span></li><li><span>Deduce <em>A</em> OR <em>C</em> [assuming <em>A</em> OR <em>C</em>]. <i>[IMPLICATION INTRODUCTION]</i></span></li><li><span>From <em>A</em> IMPLIES <em>B</em>: deduce <em>A</em> IMPLIES <em>B</em> [assuming <em>A</em> OR <em>C</em>]. <i>[PUSH]</i></span></li><li><span>From <em>A</em> OR <em>C</em> [assuming <em>A</em> OR <em>C</em>], <em>A</em> IMPLIES <em>B</em> [assuming <em>A</em> OR <em>C</em>]: deduce <em>B</em> OR <em>C</em> [assuming <em>A</em> OR <em>C</em>]. <i>[<a href="https://en.wikipedia.org/wiki/Constructive_dilemma" target="_blank">CONSTRUCTIVE DILEMMA</a> (left)]</i></span></li><li><span>From <em>B</em> OR <em>C</em> [assuming <em>A</em> OR <em>C</em>]: deduce (<em>A</em> OR <em>C</em>) IMPLIES (<em>B</em> OR <em>C</em>). <i>[<a href="https://en.wikipedia.org/wiki/Deduction_theorem" target="_blank">DEDUCTION THEOREM</a>]</i></span></li><li><span>QED!</span></li>';

newSection("10", "The biconditional");

 var formIFF = new Law('IFF', [formulaContext(A), formulaContext(B)], formulaContext(IFF(A,B)));
 var BiconditionalIntroduction = new Law('BICONDITIONAL INTRODUCTION', [IMPLIES(A,B), IMPLIES(B,A)], IFF(A,B));
 var BiconditionalElimination1 = new Law('BICONDITIONAL ELIMINATION (left)', [IFF(A,B)], IMPLIES(A,B));
 var BiconditionalElimination2 = new Law('BICONDITIONAL ELIMINATION (right)', [IFF(A,B)], IMPLIES(B,A));
 var Exercise101 = new Exercise("10.1(a)", "SUBSTITUTION", [A, IFF(A,B)], B,5);
 Exercise101.unlocks(formIFF);
 Exercise101.unlocks(BiconditionalIntroduction);
 Exercise101.unlocks(BiconditionalElimination1);
 Exercise101.unlocks(BiconditionalElimination2);
 Exercise101.unlockedBy(Exercise91);
 Exercise101.notes = '<UL><LI> The logical connective IFF (short for "IF AND ONLY IF") is also known as the <A HREF="https://en.wikipedia.org/wiki/Logical_biconditional" target="_blank">biconditional</A>. </LI> <LI> As the laws of biconditional assert, the statement <I>A</I> IFF <I>B</I> is equivalent to the statements <I>A</I> IMPLIES <I>B</I> and <I>B</I> IMPLIES <I>A</I> both being true.</LI> <LI> Another way of thinking about it is that the statement <I>A</I> IFF <I>B</I> asserts that <I>A</I> and <I>B</I> are <I>equally</I> true.</LI> <LI> To use the laws, either click on a statement of the form <I>A</I> IFF <I>B</I> to be able to apply biconditional elimination to deduce <I>A</I> IMPLIES <I>B</I> or <I>B</I> IMPLIES <I>A</I>, or drag <I>A</I> IMPLIES <I>B</I> and <I>B</I> IMPLIES <I>A</I> together to form <I>A</I> IFF <I>B</I> (or <I>B</I> IFF <I>A</I>) via the law of biconditional introduction.</LI> </UL>';
Exercise101.proof = '<li><span><em>A</em>. <i>[given]</i></span></li><li><span><em>A</em> IFF <em>B</em>. <i>[given]</i></span></li><li><span>From <em>A</em> IFF <em>B</em>: deduce <em>A</em> IMPLIES <em>B</em>. <i>[BICONDITIONAL ELIMINATION (left)]</i></span></li><li><span>From <em>A</em>, <em>A</em> IMPLIES <em>B</em>: deduce <em>B</em>. <i>[<a href="https://en.wikipedia.org/wiki/Modus_ponens" target="_blank">MODUS PONENS</a>]</i></span></li><li><span>QED!</span></li>';

 var Exercise101b = new Exercise("10.1(b)", "SUBSTITUTION FOR AND (left)", [AND(A,B), IFF(A,C)], AND(C,B),6);
 Exercise101b.unlockedBy(Exercise101);
 Exercise101b.notes = 'Thanks to Wilson Cheang and Alan Lu for the short proof.';
Exercise101b.proof = '<li><span><em>A</em> AND <em>B</em>. <i>[given]</i></span></li><li><span><em>A</em> IFF <em>C</em>. <i>[given]</i></span></li><li><span>From <em>A</em> IFF <em>C</em>: deduce <em>A</em> IMPLIES <em>C</em>. <i>[BICONDITIONAL ELIMINATION (left)]</i></span></li><li><span>From <em>A</em> IMPLIES <em>C</em>: deduce (<em>A</em> AND <em>B</em>) IMPLIES (<em>C</em> AND <em>B</em>). <i>[<a href="https://en.wikipedia.org/wiki/Monotonic_function" target="_blank">MONOTONICITY</a> OF AND]</i></span></li><li><span>From <em>A</em> AND <em>B</em>, (<em>A</em> AND <em>B</em>) IMPLIES (<em>C</em> AND <em>B</em>): deduce <em>C</em> AND <em>B</em>. <i>[<a href="https://en.wikipedia.org/wiki/Modus_ponens" target="_blank">MODUS PONENS</a>]</i></span></li><li><span>QED!</span></li>';

 var Exercise101c = new Exercise("10.1(c)", "SUBSTITUTION FOR AND (right)", [AND(A,B), IFF(B,C)], AND(A,C),6);
 Exercise101c.unlockedBy(Exercise101);
 Exercise101c.notes;
 Exercise101c.proof = '<li><span><em>A</em> AND <em>B</em>. <i>[given]</i></span></li><li><span><em>B</em> IFF <em>C</em>. <i>[given]</i></span></li><li><span>From <em>A</em> AND <em>B</em>: deduce <em>B</em> AND <em>A</em>. <i>[AND IS <a href="https://en.wikipedia.org/wiki/Commutative_property" target="_blank">COMMUTATIVE</a>]</i></span></li><li><span>From <em>B</em> AND <em>A</em>, <em>B</em> IFF <em>C</em>: deduce <em>C</em> AND <em>A</em>. <i>[SUBSTITUTION FOR AND (left)]</i></span></li><li><span>From <em>C</em> AND <em>A</em>: deduce <em>A</em> AND <em>C</em>. <i>[AND IS <a href="https://en.wikipedia.org/wiki/Commutative_property" target="_blank">COMMUTATIVE</a>]</i></span></li><li><span>QED!</span></li>';

 var Exercise101d = new Exercise("10.1(d)", "SUBSTITUTION FOR OR (left)", [OR(A,B), IFF(A,C)], OR(C,B),5);
 Exercise101d.unlockedBy(Exercise101);
Exercise101d.proof = '<li><span><em>A</em> OR <em>B</em>. <i>[given]</i></span></li><li><span><em>A</em> IFF <em>C</em>. <i>[given]</i></span></li><li><span>From <em>A</em> IFF <em>C</em>: deduce <em>A</em> IMPLIES <em>C</em>. <i>[BICONDITIONAL ELIMINATION (left)]</i></span></li><li><span>From <em>A</em> OR <em>B</em>, <em>A</em> IMPLIES <em>C</em>: deduce <em>C</em> OR <em>B</em>. <i>[<a href="https://en.wikipedia.org/wiki/Constructive_dilemma" target="_blank">CONSTRUCTIVE DILEMMA</a> (left)]</i></span></li><li><span>QED!</span></li>';

 var Exercise101e = new Exercise("10.1(e)", "SUBSTITUTION FOR OR (right)", [OR(A,B), IFF(B,C)], OR(A,C),5);
 Exercise101e.unlockedBy(Exercise101);
Exercise101e.proof = '<li><span><em>A</em> OR <em>B</em>. <i>[given]</i></span></li><li><span><em>B</em> IFF <em>C</em>. <i>[given]</i></span></li><li><span>From <em>B</em> IFF <em>C</em>: deduce <em>B</em> IMPLIES <em>C</em>. <i>[BICONDITIONAL ELIMINATION (left)]</i></span></li><li><span>From <em>A</em> OR <em>B</em>, <em>B</em> IMPLIES <em>C</em>: deduce <em>A</em> OR <em>C</em>. <i>[<a href="https://en.wikipedia.org/wiki/Constructive_dilemma" target="_blank">CONSTRUCTIVE DILEMMA</a> (right)]</i></span></li><li><span>QED!</span></li>';

 var Exercise101f = new Exercise("10.1(f)", "SUBSTITUTION FOR IMPLIES (left)", [IMPLIES(A,B), IFF(A,C)], IMPLIES(C,B),5);
 Exercise101f.unlockedBy(Exercise101);
Exercise101f.proof = '<li><span><em>A</em> IMPLIES <em>B</em>. <i>[given]</i></span></li><li><span><em>A</em> IFF <em>C</em>. <i>[given]</i></span></li><li><span>From <em>A</em> IFF <em>C</em>: deduce <em>C</em> IMPLIES <em>A</em>. <i>[BICONDITIONAL ELIMINATION (right)]</i></span></li><li><span>From <em>C</em> IMPLIES <em>A</em>, <em>A</em> IMPLIES <em>B</em>: deduce <em>C</em> IMPLIES <em>B</em>. <i>[IMPLIES IS <a href="https://en.wikipedia.org/wiki/Transitive_relation" target="_blank">TRANSITIVE</a>]</i></span></li><li><span>QED!</span></li>';

 var Exercise101g = new Exercise("10.1(g)", "SUBSTITUTION FOR IMPLIES (right)", [IMPLIES(A,B), IFF(B,C)], IMPLIES(A,C),5);
 Exercise101g.unlockedBy(Exercise101);
Exercise101g.proof = '<li><span><em>A</em> IMPLIES <em>B</em>. <i>[given]</i></span></li><li><span><em>B</em> IFF <em>C</em>. <i>[given]</i></span></li><li><span>From <em>B</em> IFF <em>C</em>: deduce <em>B</em> IMPLIES <em>C</em>. <i>[BICONDITIONAL ELIMINATION (left)]</i></span></li><li><span>From <em>A</em> IMPLIES <em>B</em>, <em>B</em> IMPLIES <em>C</em>: deduce <em>A</em> IMPLIES <em>C</em>. <i>[IMPLIES IS <a href="https://en.wikipedia.org/wiki/Transitive_relation" target="_blank">TRANSITIVE</a>]</i></span></li><li><span>QED!</span></li>';


 var Exercise102 = new Exercise("10.2(a)", 'IFF IS <A HREF="https://en.wikipedia.org/wiki/Symmetric_relation" target="_blank">SYMMETRIC</A>', [IFF(A,B)], IFF(B,A),5);
 Exercise102.unlockedBy(Exercise101);
Exercise102.proof = '<li><span><em>A</em> IFF <em>B</em>. <i>[given]</i></span></li><li><span>From <em>A</em> IFF <em>B</em>: deduce <em>A</em> IMPLIES <em>B</em>. <i>[BICONDITIONAL ELIMINATION (left)]</i></span></li><li><span>From <em>A</em> IFF <em>B</em>: deduce <em>B</em> IMPLIES <em>A</em>. <i>[BICONDITIONAL ELIMINATION (right)]</i></span></li><li><span>From <em>B</em> IMPLIES <em>A</em>, <em>A</em> IMPLIES <em>B</em>: deduce <em>B</em> IFF <em>A</em>. <i>[BICONDITIONAL INTRODUCTION]</i></span></li><li><span>QED!</span></li>';

 var Exercise102b = new Exercise("10.2(b)", 'IFF IS <A HREF="https://en.wikipedia.org/wiki/Transitive_relation" target="_blank">TRANSITIVE</A>', [IFF(A,B), IFF(B,C)], IFF(A,C),8);
 Exercise102b.unlockedBy(Exercise101);
Exercise102b.proof = '<li><span><em>A</em> IFF <em>B</em>. <i>[given]</i></span></li><li><span><em>B</em> IFF <em>C</em>. <i>[given]</i></span></li><li><span>From <em>A</em> IFF <em>B</em>: deduce <em>A</em> IMPLIES <em>B</em>. <i>[BICONDITIONAL ELIMINATION (left)]</i></span></li><li><span>From <em>A</em> IMPLIES <em>B</em>, <em>B</em> IFF <em>C</em>: deduce <em>A</em> IMPLIES <em>C</em>. <i>[SUBSTITUTION FOR IMPLIES (right)]</i></span></li><li><span>From <em>A</em> IFF <em>B</em>: deduce <em>B</em> IMPLIES <em>A</em>. <i>[BICONDITIONAL ELIMINATION (right)]</i></span></li><li><span>From <em>B</em> IMPLIES <em>A</em>, <em>B</em> IFF <em>C</em>: deduce <em>C</em> IMPLIES <em>A</em>. <i>[SUBSTITUTION FOR IMPLIES (left)]</i></span></li><li><span>From <em>A</em> IMPLIES <em>C</em>, <em>C</em> IMPLIES <em>A</em>: deduce <em>A</em> IFF <em>C</em>. <i>[BICONDITIONAL INTRODUCTION]</i></span></li><li><span>QED!</span></li>';

var Exercise102c = new Exercise("10.2(c)", 'IFF IS <A HREF="https://en.wikipedia.org/wiki/Reflexive_relation" target="_blank">REFLEXIVE</A>', [formulaContext(A)], IFF(A,A), 3);
Exercise102c.unlockedBy(Exercise101);
Exercise102c.notes = '"<I>if it was so, it might be; and if it were so, it would be; but as it isn\'t, it ain\'t. That\'s logic.</I>" - Tweedledee, "Through the Looking Glass"';
Exercise102c.proof = '<li><span>Deduce <em>A</em> IMPLIES <em>A</em>. <i>[IMPLIES IS <a href="https://en.wikipedia.org/wiki/Idempotence&quot;" target="_blank">IDEMPOTENT</a>]</i></span></li><li><span>From <em>A</em> IMPLIES <em>A</em>, <em>A</em> IMPLIES <em>A</em>: deduce <em>A</em> IFF <em>A</em>. <i>[BICONDITIONAL INTRODUCTION]</i></span></li><li><span>QED!</span></li>';

var Exercise103 = new Exercise("10.3", "BICONDITIONAL INTRODUCTION (ASSUMPTION FORM)", [assuming(A,B), assuming(B,A)], IFF(A,B), 6);
Exercise103.unlockedBy(Exercise101);
Exercise103.notes = 'This form of biconditional introduction is convenient in some later exercises, as it can shorten proofs slightly.';

 var Exercise104 = new Exercise("10.4", 'OR IS <A HREF="<A HREF="https://en.wikipedia.org/wiki/Idempotence" target="_blank">IDEMPOTENT</A> (biconditional form)', [formulaContext(A)], IFF(A, OR(A,A)),5);
 Exercise104.unlockedBy(Exercise101);
 Exercise104.notes = '<UL><LI>The left and right idempotence of OR, proven in Exercise 3.1(b) and Exercise 9.1(b) respectively, will be useful here.</LI> <LI> Thanks to Chen Xu and JP Sugarbroad for the short proof.</LI></UL>';
Exercise104.proof = '<li><span>Deduce <em>A</em> [assuming <em>A</em>]. <i>[IMPLICATION INTRODUCTION]</i></span></li><li><span>From <em>A</em> [assuming <em>A</em>], <em>A</em> [assuming <em>A</em>]: deduce <em>A</em> [assuming <em>A</em> OR <em>A</em>]. <i>[<a href="https://en.wikipedia.org/wiki/Proof_by_exhaustion" target="_blank">CASE ANALYSIS</a>]</i></span></li><li><span>From <em>A</em> [assuming <em>A</em>]: deduce <em>A</em> OR <em>A</em> [assuming <em>A</em>]. <i>[<a href="https://en.wikipedia.org/wiki/Disjunction_introduction" target="_blank">DISJUNCTION INTRODUCTION</a> (left)]</i></span></li><li><span>From <em>A</em> [assuming <em>A</em> OR <em>A</em>], <em>A</em> OR <em>A</em> [assuming <em>A</em>]: deduce <em>A</em> IFF (<em>A</em> OR <em>A</em>). <i>[BICONDITIONAL INTRODUCTION (ASSUMPTION FORM)]</i></span></li><li><span>QED!</span></li>';

 var Exercise105 = new Exercise("10.5", "", [formulaContext(A), formulaContext(B), formulaContext(C)], IFF(AND(AND(A,B),C),AND(A,AND(B,C))),6);
 Exercise105.unlockedBy(Exercise101);
 Exercise105.notes = 'The fact that AND is associative, proven in Exercise 2.2(a) and Exercise 2.2(b) will be useful here.'
Exercise105.proof = '<li><span>Deduce (<em>A</em> AND <em>B</em>) AND <em>C</em> [assuming (<em>A</em> AND <em>B</em>) AND <em>C</em>]. <i>[IMPLICATION INTRODUCTION]</i></span></li><li><span>From (<em>A</em> AND <em>B</em>) AND <em>C</em> [assuming (<em>A</em> AND <em>B</em>) AND <em>C</em>]: deduce <em>A</em> AND (<em>B</em> AND <em>C</em>) [assuming (<em>A</em> AND <em>B</em>) AND <em>C</em>]. <i>[AND IS <a href="https://en.wikipedia.org/wiki/Associative_property" target="_blank">ASSOCIATIVE</a> (left)]</i></span></li><li><span>Deduce <em>A</em> AND (<em>B</em> AND <em>C</em>) [assuming <em>A</em> AND (<em>B</em> AND <em>C</em>)]. <i>[IMPLICATION INTRODUCTION]</i></span></li><li><span>From <em>A</em> AND (<em>B</em> AND <em>C</em>) [assuming <em>A</em> AND (<em>B</em> AND <em>C</em>)]: deduce (<em>A</em> AND <em>B</em>) AND <em>C</em> [assuming <em>A</em> AND (<em>B</em> AND <em>C</em>)]. <i>[AND IS <a href="https://en.wikipedia.org/wiki/Associative_property" target="_blank">ASSOCIATIVE</a> (right)]</i></span></li><li><span>From (<em>A</em> AND <em>B</em>) AND <em>C</em> [assuming <em>A</em> AND (<em>B</em> AND <em>C</em>)], <em>A</em> AND (<em>B</em> AND <em>C</em>) [assuming (<em>A</em> AND <em>B</em>) AND <em>C</em>]: deduce ((<em>A</em> AND <em>B</em>) AND <em>C</em>) IFF (<em>A</em> AND (<em>B</em> AND <em>C</em>)). <i>[BICONDITIONAL INTRODUCTION (ASSUMPTION FORM)]</i></span></li><li><span>QED!</span></li>';

newSection("11", "Disjunctive elimination");

 var formNot = new Law('NOT', [formulaContext(A)], formulaContext(NOT(A)));
 var caseElimination1 = new Law('<A HREF="https://en.wikipedia.org/wiki/Disjunctive_syllogism" target="_blank">DISJUNCTIVE ELIMINATION</A> (left)', [OR(A,B), NOT(A)], B);
 var caseElimination2 = new Law('<A HREF="https://en.wikipedia.org/wiki/Disjunctive_syllogism" target="_blank">DISJUNCTIVE ELIMINATION</A> (right)', [OR(A,B), NOT(B)], A);
 var Exercise111 = new Exercise("11.1", '<A HREF="https://en.wikipedia.org/wiki/Principle_of_explosion" target="_blank">EX FALSO QUODLIBET</A>', [AND(A,NOT(A)), formulaContext(B)], B,6);
 Exercise111.unlocks(formNot);
 Exercise111.unlocks(caseElimination1);
 Exercise111.unlocks(caseElimination2);
 Exercise111.unlockedBy(Exercise101);
 Exercise111.notes = '"<I>When you have eliminated the impossible, whatever remains, however improbable, must be the truth</I>" - Sherlock Holmes, "The Sign of the Four".<UL><LI> The logical connective NOT (also known as <A HREF="https://en.wikipedia.org/wiki/Negation" target="_blank">negation</A>) is a unary connective; click on a formula to find the option to build the negated formula.  A statement NOT <I>A</I> is true when <I>A</I> is false, and false when <I>A</I> is true. <LI> We have unlocked the <A HREF="https://en.wikipedia.org/wiki/Disjunctive_syllogism" target="_blank">laws of disjunctive elimination</A>.  These laws assert that if a disjunction <I>A</I> OR <I>B</I> is true, and (say) NOT <I>A</I> is known to be true (so <I>A</I> is known to be false), then <I>B</I> must be true.  <LI> To use this law, drag a disjunction such as <I>A</I> OR <I>B</I> to the negation of either <I>A</I> or <I>B</I>; one can also drag in the reversed direction.<LI> This exercise, <A HREF="https://en.wikipedia.org/wiki/Principle_of_explosion" target="_blank"><I>ex falso quodlibet</I></A>, is also known as the "principle of explosion".  Informally, it asserts that once one has arrived at a contradiction, one can obtain any conclusion one wishes.  <LI> To apply <I>ex falso quodlibet</I> in subsequent exercises, drag a sentence of the form <I>A</I> AND (NOT <I>A</I>) to a formula in the <B>Formulas</B> window (or vice versa).  </UL>';
Exercise111.proof = '<li><span><em>A</em> AND (NOT <em>A</em>). <i>[given]</i></span></li><li><span>From <em>A</em> AND (NOT <em>A</em>): deduce <em>A</em>. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_elimination" target="_blank">CONJUNCTION ELIMINATION</a> (left)]</i></span></li><li><span>From <em>A</em> AND (NOT <em>A</em>): deduce NOT <em>A</em>. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_elimination" target="_blank">CONJUNCTION ELIMINATION</a> (right)]</i></span></li><li><span>From <em>A</em>: deduce <em>A</em> OR <em>B</em>. <i>[<a href="https://en.wikipedia.org/wiki/Disjunction_introduction" target="_blank">DISJUNCTION INTRODUCTION</a> (left)]</i></span></li><li><span>From <em>A</em> OR <em>B</em>, NOT <em>A</em>: deduce <em>B</em>. <i>[<a href="https://en.wikipedia.org/wiki/Disjunctive_syllogism" target="_blank">DISJUNCTIVE ELIMINATION</a> (left)]</i></span></li><li><span>QED!</span></li>';

    newSection("12", "Law of excluded middle");

 var excludedMiddle = new Law('<A HREF="https://en.wikipedia.org/wiki/Law_of_excluded_middle" target="_blank">EXCLUDED MIDDLE</A>', [formulaContext(A)], OR(A,NOT(A)));
 var Exercise121 = new Exercise("12.1(a)", '<A HREF="https://en.wikipedia.org/wiki/Reductio_ad_absurdum" target="_blank">REDUCTIO AD ABSURDUM</A>', [assuming(AND(B,NOT(B)),A)], NOT(A),7);
 Exercise121.unlocks(excludedMiddle);
 Exercise121.unlockedBy(Exercise111);
 Exercise121.notes = '<UL><LI> The <A HREF="https://en.wikipedia.org/wiki/Law_of_excluded_middle" target="_blank">law of the excluded middle</A> is one of the most powerful rules in classical propositional logic, playing a role somewhat analogous to that of the parallel postulate in Euclidean geometry; it completes the basic set of rules of inference for propositional logic. <LI> The law asserts that for any statement <I>A</I>, one of the statements <I>A</I> and NOT <I>A</I> is true.  To apply this law, drag the formula <I>A</I> from the <B>Formulas</B> window to an assumption environment (such as the <B>Root environment</B>), or just click on <I>A</I> if one wants to use the law in the root environment. <LI>  If one removes the law of the excluded middle from classical logic (replacing it with the <I>reductio ad absurdum</I> rule of this exercise), one obtains the system of <A HREF="https://en.wikipedia.org/wiki/Intuitionistic_logic" target="_blank">constructivist logic</A> (also known as intuitionistic logic), which is deductively weaker, but (by the same token) makes a stronger assertion about the statements that it can still prove. <LI> <Q><I>Reductio ad absurdum</I> is a far finer gambit than any chess gambit: a chess player may offer the sacrifice of a pawn or even a piece, but a mathematician offers the game.</Q> - G. H. Hardy</UL>';
Exercise121.proof = '<li><span><em>B</em> AND (NOT <em>B</em>) [assuming <em>A</em>]. <i>[given]</i></span></li><li><span>From <em>B</em> AND (NOT <em>B</em>) [assuming <em>A</em>]: deduce NOT <em>A</em> [assuming <em>A</em>]. <i>[<a href="https://en.wikipedia.org/wiki/Principle_of_explosion" target="_blank">EX FALSO QUODLIBET</a>]</i></span></li><li><span>Deduce NOT <em>A</em> [assuming NOT <em>A</em>]. <i>[IMPLICATION INTRODUCTION]</i></span></li><li><span>From NOT <em>A</em> [assuming <em>A</em>], NOT <em>A</em> [assuming NOT <em>A</em>]: deduce NOT <em>A</em> [assuming <em>A</em> OR (NOT <em>A</em>)]. <i>[<a href="https://en.wikipedia.org/wiki/Proof_by_exhaustion" target="_blank">CASE ANALYSIS</a>]</i></span></li><li><span>Deduce <em>A</em> OR (NOT <em>A</em>). <i>[<a href="https://en.wikipedia.org/wiki/Law_of_excluded_middle" target="_blank">EXCLUDED MIDDLE</a>]</i></span></li><li><span>From <em>A</em> OR (NOT <em>A</em>), NOT <em>A</em> [assuming <em>A</em> OR (NOT <em>A</em>)]: deduce NOT <em>A</em>. <i>[<a href="https://en.wikipedia.org/wiki/Modus_ponens" target="_blank">MODUS PONENS</a> (ASSUMPTION FORM)]</i></span></li><li><span>QED!</span></li>';


 var Exercise121b = new Exercise("12.1(b)", '<A HREF="https://en.wikipedia.org/wiki/Reductio_ad_absurdum" target="_blank">REDUCTIO AD ABSURDUM</A> (separated form)', [assuming(B,A), assuming(NOT(B),A)], NOT(A),5);
 Exercise121b.unlockedBy(Exercise121);
 Exercise121b.notes = '<UL> <LI> This form of reductio ad absurdum is slightly more convenient to use in subsequent exercises.  To apply it, combine <I>B</I> and NOT <I>B</I> together inside an assumption environment.</LI>  </UL>';
Exercise121b.proof = '<li><span><em>B</em> [assuming <em>A</em>]. <i>[given]</i></span></li><li><span>NOT <em>B</em> [assuming <em>A</em>]. <i>[given]</i></span></li><li><span>From <em>B</em> [assuming <em>A</em>], NOT <em>B</em> [assuming <em>A</em>]: deduce <em>B</em> AND (NOT <em>B</em>) [assuming <em>A</em>]. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_introduction" target=" _blank">CONJUNCTION INTRODUCTION</a>]</i></span></li><li><span>From <em>B</em> AND (NOT <em>B</em>) [assuming <em>A</em>]: deduce NOT <em>A</em>. <i>[<a href="https://en.wikipedia.org/wiki/Reductio_ad_absurdum" target="_blank">REDUCTIO AD ABSURDUM</a>]</i></span></li><li><span>QED!</span></li>';

var Exercise121c = new Exercise("12.1(c)", '<A HREF="https://en.wikipedia.org/wiki/Law_of_excluded_middle" target="_blank">EXCLUDED MIDDLE</A> (case analysis form)', [assuming(B,A), assuming(B,NOT(A))], B,6);
Exercise121c.unlockedBy(Exercise121);
 Exercise121c.notes = 'This form of the excluded middle is slightly more convenient to use in subsequent exercises.  To apply it, combine a statement <I>B</I> (in a window assuming some formula <I>A</I>) with the same statement <I>B</I> (in a separate window assuming NOT <I>A</I>).';
Exercise121c.proof = '<li><span><em>B</em> [assuming <em>A</em>]. <i>[given]</i></span></li><li><span><em>B</em> [assuming NOT <em>A</em>]. <i>[given]</i></span></li><li><span>From <em>B</em> [assuming <em>A</em>], <em>B</em> [assuming NOT <em>A</em>]: deduce <em>B</em> [assuming <em>A</em> OR (NOT <em>A</em>)]. <i>[<a href="https://en.wikipedia.org/wiki/Proof_by_exhaustion" target="_blank">CASE ANALYSIS</a>]</i></span></li><li><span>Deduce <em>A</em> OR (NOT <em>A</em>). <i>[<a href="https://en.wikipedia.org/wiki/Law_of_excluded_middle" target="_blank">EXCLUDED MIDDLE</a>]</i></span></li><li><span>From <em>A</em> OR (NOT <em>A</em>), <em>B</em> [assuming <em>A</em> OR (NOT <em>A</em>)]: deduce <em>B</em>. <i>[<a href="https://en.wikipedia.org/wiki/Modus_ponens" target="_blank">MODUS PONENS</a> (ASSUMPTION FORM)]</i></span></li><li><span>QED!</span></li>';


 var Exercise122 = new Exercise("12.2(a)", 'DOUBLE NEGATION (right)', [NOT(NOT(A))], A,4);
 Exercise122.unlockedBy(Exercise121);
Exercise122.proof = '<li><span>NOT (NOT <em>A</em>). <i>[given]</i></span></li><li><span>Deduce <em>A</em> OR (NOT <em>A</em>). <i>[<a href="https://en.wikipedia.org/wiki/Law_of_excluded_middle" target="_blank">EXCLUDED MIDDLE</a>]</i></span></li><li><span>From <em>A</em> OR (NOT <em>A</em>), NOT (NOT <em>A</em>): deduce <em>A</em>. <i>[<a href="https://en.wikipedia.org/wiki/Disjunctive_syllogism" target="_blank">DISJUNCTIVE ELIMINATION</a> (right)]</i></span></li><li><span>QED!</span></li>';

 var Exercise122b = new Exercise("12.2(b)", 'DOUBLE NEGATION (left)', [A], NOT(NOT(A)),5);
 Exercise122b.unlockedBy(Exercise121);
 Exercise122b.notes = "Thanks to Steve Trout, Hugo Musso Gualandi, Jon Easterday, William Chargin, Haggai Nuchi, Andrew Lei, Jim Apple, Jorge Ca√±izales D√≠az, and Matthew Steffen for discovering the short proof.";
Exercise122b.proof = '<li><span><em>A</em>. <i>[given]</i></span></li><li><span>Deduce NOT <em>A</em> [assuming NOT <em>A</em>]. <i>[IMPLICATION INTRODUCTION]</i></span></li><li><span>From <em>A</em>: deduce <em>A</em> [assuming NOT <em>A</em>]. <i>[PUSH]</i></span></li><li><span>From <em>A</em> [assuming NOT <em>A</em>], NOT <em>A</em> [assuming NOT <em>A</em>]: deduce NOT (NOT <em>A</em>). <i>[<a href="https://en.wikipedia.org/wiki/Reductio_ad_absurdum" target="_blank">REDUCTIO AD ABSURDUM</a> (separated form)]</i></span></li><li><span>QED!</span></li>';


 var Exercise122c = new Exercise("12.2(c)", 'DOUBLE NEGATION (both)', [formulaContext(A)], IFF(A,NOT(NOT(A))),6);
 Exercise122c.unlockedBy(Exercise121);
Exercise122c.proof = '<li><span>Deduce <em>A</em> [assuming <em>A</em>]. <i>[IMPLICATION INTRODUCTION]</i></span></li><li><span>From <em>A</em> [assuming <em>A</em>]: deduce NOT (NOT <em>A</em>) [assuming <em>A</em>]. <i>[DOUBLE NEGATION (left)]</i></span></li><li><span>Deduce NOT (NOT <em>A</em>) [assuming NOT (NOT <em>A</em>)]. <i>[IMPLICATION INTRODUCTION]</i></span></li><li><span>From NOT (NOT <em>A</em>) [assuming NOT (NOT <em>A</em>)]: deduce <em>A</em> [assuming NOT (NOT <em>A</em>)]. <i>[DOUBLE NEGATION (right)]</i></span></li><li><span>From <em>A</em> [assuming NOT (NOT <em>A</em>)], NOT (NOT <em>A</em>) [assuming <em>A</em>]: deduce <em>A</em> IFF (NOT (NOT <em>A</em>)). <i>[BICONDITIONAL INTRODUCTION (ASSUMPTION FORM)]</i></span></li><li><span>QED!</span></li>';

 var Exercise123 = new Exercise("12.3", 'PROOF BY CONTRADICTION', [assuming(AND(B,NOT(B)),NOT(A))], A,4);
 Exercise123.unlockedBy(Exercise121);
 Exercise123.notes = "Thanks to Tyler Freeman and Chandler Watson for a short proof, and Hugo Musso Gualandi, Jon Easterday, Haggai Nuchi, and Jorge Ca√±izales D√≠az for an even shorter proof.";
Exercise123.proof = '<li><span><em>B</em> AND (NOT <em>B</em>) [assuming NOT <em>A</em>]. <i>[given]</i></span></li><li><span>From <em>B</em> AND (NOT <em>B</em>) [assuming NOT <em>A</em>]: deduce NOT (NOT <em>A</em>). <i>[<a href="https://en.wikipedia.org/wiki/Reductio_ad_absurdum" target="_blank">REDUCTIO AD ABSURDUM</a>]</i></span></li><li><span>From NOT (NOT <em>A</em>): deduce <em>A</em>. <i>[DOUBLE NEGATION (right)]</i></span></li><li><span>QED!</span></li>';

 var Exercise124 = new Exercise("12.4(a)", "", [IMPLIES(A,B)], OR( NOT(A), B),5);
 Exercise124.unlockedBy(Exercise121);
Exercise124.proof = '<li><span><em>A</em> IMPLIES <em>B</em>. <i>[given]</i></span></li><li><span>Deduce <em>A</em> OR (NOT <em>A</em>). <i>[<a href="https://en.wikipedia.org/wiki/Law_of_excluded_middle" target="_blank">EXCLUDED MIDDLE</a>]</i></span></li><li><span>From <em>A</em> OR (NOT <em>A</em>), <em>A</em> IMPLIES <em>B</em>: deduce <em>B</em> OR (NOT <em>A</em>). <i>[<a href="https://en.wikipedia.org/wiki/Constructive_dilemma" target="_blank">CONSTRUCTIVE DILEMMA</a> (left)]</i></span></li><li><span>From <em>B</em> OR (NOT <em>A</em>): deduce (NOT <em>A</em>) OR <em>B</em>. <i>[OR IS COMMUTATIVE]</i></span></li><li><span>QED!</span></li>';

 var Exercise124b = new Exercise("12.4(b)", "", [OR( NOT(A), B)], IMPLIES(A,B),7);
 Exercise124b.unlockedBy(Exercise121);
 Exercise124b.notes = "Thanks to Yuval Wigderson, cory, Tyler Freeman, Haggai Nuchi, and Chandler Watson for supplying the short proof for this exercise.";
Exercise124b.proof = '<li><span>(NOT <em>A</em>) OR <em>B</em>. <i>[given]</i></span></li><li><span>Deduce <em>A</em> [assuming <em>A</em>]. <i>[IMPLICATION INTRODUCTION]</i></span></li><li><span>From (NOT <em>A</em>) OR <em>B</em>: deduce (NOT <em>A</em>) OR <em>B</em> [assuming <em>A</em>]. <i>[PUSH]</i></span></li><li><span>From <em>A</em> [assuming <em>A</em>]: deduce NOT (NOT <em>A</em>) [assuming <em>A</em>]. <i>[DOUBLE NEGATION (left)]</i></span></li><li><span>From (NOT <em>A</em>) OR <em>B</em> [assuming <em>A</em>], NOT (NOT <em>A</em>) [assuming <em>A</em>]: deduce <em>B</em> [assuming <em>A</em>]. <i>[<a href="https://en.wikipedia.org/wiki/Disjunctive_syllogism" target="_blank">DISJUNCTIVE ELIMINATION</a> (left)]</i></span></li><li><span>From <em>B</em> [assuming <em>A</em>]: deduce <em>A</em> IMPLIES <em>B</em>. <i>[<a href="https://en.wikipedia.org/wiki/Deduction_theorem" target="_blank">DEDUCTION THEOREM</a>]</i></span></li><li><span>QED!</span></li>';

 var Exercise124c = new Exercise("12.4(c)", "", [formulaContext(A), formulaContext(B)], IFF(IMPLIES(A,B), OR( NOT(A), B)),6);
 Exercise124c.unlockedBy(Exercise121);
Exercise124c.proof = '<li><span>Deduce <em>A</em> IMPLIES <em>B</em> [assuming <em>A</em> IMPLIES <em>B</em>]. <i>[IMPLICATION INTRODUCTION]</i></span></li><li><span>From <em>A</em> IMPLIES <em>B</em> [assuming <em>A</em> IMPLIES <em>B</em>]: deduce (NOT <em>A</em>) OR <em>B</em> [assuming <em>A</em> IMPLIES <em>B</em>]. <i>[EXERCISE 12.4(a)]</i></span></li><li><span>Deduce (NOT <em>A</em>) OR <em>B</em> [assuming (NOT <em>A</em>) OR <em>B</em>]. <i>[IMPLICATION INTRODUCTION]</i></span></li><li><span>From (NOT <em>A</em>) OR <em>B</em> [assuming (NOT <em>A</em>) OR <em>B</em>]: deduce <em>A</em> IMPLIES <em>B</em> [assuming (NOT <em>A</em>) OR <em>B</em>]. <i>[EXERCISE 12.4(b)]</i></span></li><li><span>From <em>A</em> IMPLIES <em>B</em> [assuming (NOT <em>A</em>) OR <em>B</em>], (NOT <em>A</em>) OR <em>B</em> [assuming <em>A</em> IMPLIES <em>B</em>]: deduce (<em>A</em> IMPLIES <em>B</em>) IFF ((NOT <em>A</em>) OR <em>B</em>). <i>[BICONDITIONAL INTRODUCTION (ASSUMPTION FORM)]</i></span></li><li><span>QED!</span></li>';

  var Exercise125 = new Exercise("12.5(a)", '<A HREF="https://en.wikipedia.org/wiki/De_Morgan%27s_laws" target="_blank">DE MORGAN\'S LAW</A> I', [NOT(OR(A,B))], AND(NOT(A), NOT(B)),11);
 Exercise125.unlockedBy(Exercise121);
 Exercise125.notes = "Thanks to Daniel Spivak for a short proof.";
Exercise125.proof = '<li><span>NOT (<em>A</em> OR <em>B</em>). <i>[given]</i></span></li><li><span>Deduce <em>A</em> [assuming <em>A</em>]. <i>[IMPLICATION INTRODUCTION]</i></span></li><li><span>From <em>A</em> [assuming <em>A</em>]: deduce <em>A</em> OR <em>B</em> [assuming <em>A</em>]. <i>[<a href="https://en.wikipedia.org/wiki/Disjunction_introduction" target="_blank">DISJUNCTION INTRODUCTION</a> (left)]</i></span></li><li><span>From NOT (<em>A</em> OR <em>B</em>): deduce NOT (<em>A</em> OR <em>B</em>) [assuming <em>A</em>]. <i>[PUSH]</i></span></li><li><span>From <em>A</em> OR <em>B</em> [assuming <em>A</em>], NOT (<em>A</em> OR <em>B</em>) [assuming <em>A</em>]: deduce NOT <em>A</em>. <i>[<a href="https://en.wikipedia.org/wiki/Reductio_ad_absurdum" target="_blank">REDUCTIO AD ABSURDUM</a> (separated form)]</i></span></li><li><span>Deduce <em>B</em> [assuming <em>B</em>]. <i>[IMPLICATION INTRODUCTION]</i></span></li><li><span>From <em>B</em> [assuming <em>B</em>]: deduce <em>A</em> OR <em>B</em> [assuming <em>B</em>]. <i>[<a href="https://en.wikipedia.org/wiki/Disjunction_introduction" target="_blank">DISJUNCTION INTRODUCTION</a> (right)]</i></span></li><li><span>From NOT (<em>A</em> OR <em>B</em>): deduce NOT (<em>A</em> OR <em>B</em>) [assuming <em>B</em>]. <i>[PUSH]</i></span></li><li><span>From <em>A</em> OR <em>B</em> [assuming <em>B</em>], NOT (<em>A</em> OR <em>B</em>) [assuming <em>B</em>]: deduce NOT <em>B</em>. <i>[<a href="https://en.wikipedia.org/wiki/Reductio_ad_absurdum" target="_blank">REDUCTIO AD ABSURDUM</a> (separated form)]</i></span></li><li><span>From NOT <em>A</em>, NOT <em>B</em>: deduce (NOT <em>A</em>) AND (NOT <em>B</em>). <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_introduction" target=" _blank">CONJUNCTION INTRODUCTION</a>]</i></span></li><li><span>QED!</span></li>';

 var Exercise125b = new Exercise("12.5(b)", '<A HREF="https://en.wikipedia.org/wiki/De_Morgan%27s_laws" target="_blank">DE MORGAN\'S LAW</A> II', [OR(NOT(A), NOT(B))], NOT(AND(A,B)),7);
 Exercise125b.unlockedBy(Exercise121);
 Exercise125b.notes = 'Thanks to Anders Kaseorg for a short proof (found by computer search!).';
Exercise125b.proof = '<li><span>(NOT <em>A</em>) OR (NOT <em>B</em>). <i>[given]</i></span></li><li><span>From (NOT <em>A</em>) OR (NOT <em>B</em>): deduce <em>A</em> IMPLIES (NOT <em>B</em>). <i>[EXERCISE 12.4(b)]</i></span></li><li><span>From <em>A</em> IMPLIES (NOT <em>B</em>): deduce (<em>A</em> AND <em>B</em>) IMPLIES ((NOT <em>B</em>) AND <em>B</em>). <i>[<a href="https://en.wikipedia.org/wiki/Monotonic_function" target="_blank">MONOTONICITY</a> OF AND]</i></span></li><li><span>From (<em>A</em> AND <em>B</em>) IMPLIES ((NOT <em>B</em>) AND <em>B</em>): deduce (NOT <em>B</em>) AND <em>B</em> [assuming <em>A</em> AND <em>B</em>]. <i>[REVERSE <a href="https://en.wikipedia.org/wiki/Deduction_theorem" target="_blank">DEDUCTION THEOREM</a>]</i></span></li><li><span>From (NOT <em>B</em>) AND <em>B</em> [assuming <em>A</em> AND <em>B</em>]: deduce <em>B</em> AND (NOT <em>B</em>) [assuming <em>A</em> AND <em>B</em>]. <i>[AND IS <a href="https://en.wikipedia.org/wiki/Commutative_property" target="_blank">COMMUTATIVE</a>]</i></span></li><li><span>From <em>B</em> AND (NOT <em>B</em>) [assuming <em>A</em> AND <em>B</em>]: deduce NOT (<em>A</em> AND <em>B</em>). <i>[<a href="https://en.wikipedia.org/wiki/Reductio_ad_absurdum" target="_blank">REDUCTIO AD ABSURDUM</a>]</i></span></li><li><span>QED!</span></li>';

 var Exercise125c = new Exercise("12.5(c)", '<A HREF="https://en.wikipedia.org/wiki/De_Morgan%27s_laws" target="_blank">DE MORGAN\'S LAW</A> III', [NOT(AND(A,B))], OR(NOT(A), NOT(B)),10);
 Exercise125c.unlockedBy(Exercise121);
 Exercise125c.notes = "Thanks to Daniel Spivak, Anders Kaseorg, Vincent Hwang, and Olle Wiklund for supplying the short proof for this exercise.";
Exercise125c.proof = '<li><span>NOT (<em>A</em> AND <em>B</em>). <i>[given]</i></span></li><li><span>Deduce <em>A</em> [assuming <em>A</em>]. <i>[IMPLICATION INTRODUCTION]</i></span></li><li><span>Deduce <em>B</em> [assuming <em>A</em>, <em>B</em>]. <i>[IMPLICATION INTRODUCTION]</i></span></li><li><span>From <em>A</em> [assuming <em>A</em>]: deduce <em>A</em> [assuming <em>A</em>, <em>B</em>]. <i>[PUSH]</i></span></li><li><span>From <em>A</em> [assuming <em>A</em>, <em>B</em>], <em>B</em> [assuming <em>A</em>, <em>B</em>]: deduce <em>A</em> AND <em>B</em> [assuming <em>A</em>, <em>B</em>]. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_introduction" target=" _blank">CONJUNCTION INTRODUCTION</a>]</i></span></li><li><span>From NOT (<em>A</em> AND <em>B</em>): deduce NOT (<em>A</em> AND <em>B</em>) [assuming <em>A</em>, <em>B</em>]. <i>[DOUBLE PUSH]</i></span></li><li><span>From <em>A</em> AND <em>B</em> [assuming <em>A</em>, <em>B</em>], NOT (<em>A</em> AND <em>B</em>) [assuming <em>A</em>, <em>B</em>]: deduce NOT <em>B</em> [assuming <em>A</em>]. <i>[<a href="https://en.wikipedia.org/wiki/Reductio_ad_absurdum" target="_blank">REDUCTIO AD ABSURDUM</a> (separated form)]</i></span></li><li><span>From NOT <em>B</em> [assuming <em>A</em>]: deduce <em>A</em> IMPLIES (NOT <em>B</em>). <i>[<a href="https://en.wikipedia.org/wiki/Deduction_theorem" target="_blank">DEDUCTION THEOREM</a>]</i></span></li><li><span>From <em>A</em> IMPLIES (NOT <em>B</em>): deduce (NOT <em>A</em>) OR (NOT <em>B</em>). <i>[EXERCISE 12.4(a)]</i></span></li><li><span>QED!</span></li>';

 var Exercise125d = new Exercise("12.5(d)", '<A HREF="https://en.wikipedia.org/wiki/De_Morgan%27s_laws" target="_blank">DE MORGAN\'S LAW</A> IV', [AND(NOT(A), NOT(B))], NOT(OR(A,B)),8);
 Exercise125d.unlockedBy(Exercise121);
 Exercise125d.notes = '<table> <tr> <th>Object</th> <th>Dual</th> </tr>     <tr> <td>TRUE</td> <td>FALSE</td> </tr> <tr> <td>AND</td> <td>OR</td> </tr> <tr> <td>NOT</td> <td>NOT</td> </tr> <tr> <td>FOR ALL</td> <td>THERE EXISTS</td> </tr> <tr>  <td>Hypothesis</td> <td>Conclusion</td> </tr> </td> </tr> <UL><LI> At this point, the reader may have noticed a certain symmetry to propositional logic.  This symmetry is formalised by the <A HREF="https://en.wikipedia.org/wiki/Boolean_algebra#Duality_principle" target="_blank">duality principle</A> in <A HREF="https://en.wikipedia.org/wiki/Boolean_algebra" target="_blank">boolean algebra</A>, and may be summarised by the displayed table of "dual" pairs. </LI> <LI>  Every deductive law involving the connectives TRUE, FALSE, AND, OR, and NOT with a single hypothesis and conclusion then has a dual law in which the hypothesis and conclusion are interchanged, and the logical connectives are replaced with their duals as indicated by the table. </LI> <LI> For instance, Exercise 12.5(a) and Exercise 12.5(b) are dual, as are Exercise 12.5(c) and Exercise 12.5(d).</LI><LI>Thanks to Yuval Wigderson and cory for supplying the short proof for this exercise.</LI></UL>';
Exercise125d.proof = '<li><span>(NOT <em>A</em>) AND (NOT <em>B</em>). <i>[given]</i></span></li><li><span>Deduce <em>A</em> OR <em>B</em> [assuming <em>A</em> OR <em>B</em>]. <i>[IMPLICATION INTRODUCTION]</i></span></li><li><span>From (NOT <em>A</em>) AND (NOT <em>B</em>): deduce (NOT <em>A</em>) AND (NOT <em>B</em>) [assuming <em>A</em> OR <em>B</em>]. <i>[PUSH]</i></span></li><li><span>From (NOT <em>A</em>) AND (NOT <em>B</em>) [assuming <em>A</em> OR <em>B</em>]: deduce NOT <em>A</em> [assuming <em>A</em> OR <em>B</em>]. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_elimination" target="_blank">CONJUNCTION ELIMINATION</a> (left)]</i></span></li><li><span>From (NOT <em>A</em>) AND (NOT <em>B</em>) [assuming <em>A</em> OR <em>B</em>]: deduce NOT <em>B</em> [assuming <em>A</em> OR <em>B</em>]. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_elimination" target="_blank">CONJUNCTION ELIMINATION</a> (right)]</i></span></li><li><span>From <em>A</em> OR <em>B</em> [assuming <em>A</em> OR <em>B</em>], NOT <em>A</em> [assuming <em>A</em> OR <em>B</em>]: deduce <em>B</em> [assuming <em>A</em> OR <em>B</em>]. <i>[<a href="https://en.wikipedia.org/wiki/Disjunctive_syllogism" target="_blank">DISJUNCTIVE ELIMINATION</a> (left)]</i></span></li><li><span>From <em>B</em> [assuming <em>A</em> OR <em>B</em>], NOT <em>B</em> [assuming <em>A</em> OR <em>B</em>]: deduce NOT (<em>A</em> OR <em>B</em>). <i>[<a href="https://en.wikipedia.org/wiki/Reductio_ad_absurdum" target="_blank">REDUCTIO AD ABSURDUM</a> (separated form)]</i></span></li><li><span>QED!</span></li>';

 var Exercise126 = new Exercise("12.6(a)", '<A HREF="https://en.wikipedia.org/wiki/Contraposition" target="_blank">CONTRAPOSITION</A>', [IMPLIES(A,B)], IMPLIES(NOT(B),NOT(A)),7);
 Exercise126.unlockedBy(Exercise121);
 Exercise126.notes = '<UL><LI>Contraposition is also known as <A HREF="" target="_blank">transposition</A>, and the statement (NOT <I>B</I>) IMPLIES (NOT <I>A</I>) is known as the <I>contrapositive</I> of <I>A</I> IMPLIES <I>B</I>.</LI><LI>Thanks to Steve Trout for a short proof, and Andrew Litfin and Andrew Lei for a shorter proof.</LI></UL>';
Exercise126.proof = '<li><span><em>A</em> IMPLIES <em>B</em>. <i>[given]</i></span></li><li><span>Deduce NOT <em>B</em> [assuming NOT <em>B</em>]. <i>[IMPLICATION INTRODUCTION]</i></span></li><li><span>From <em>A</em> IMPLIES <em>B</em>: deduce <em>A</em> IMPLIES <em>B</em> [assuming NOT <em>B</em>]. <i>[PUSH]</i></span></li><li><span>From <em>A</em> IMPLIES <em>B</em> [assuming NOT <em>B</em>]: deduce (NOT <em>A</em>) OR <em>B</em> [assuming NOT <em>B</em>]. <i>[EXERCISE 12.4(a)]</i></span></li><li><span>From (NOT <em>A</em>) OR <em>B</em> [assuming NOT <em>B</em>], NOT <em>B</em> [assuming NOT <em>B</em>]: deduce NOT <em>A</em> [assuming NOT <em>B</em>]. <i>[<a href="https://en.wikipedia.org/wiki/Disjunctive_syllogism" target="_blank">DISJUNCTIVE ELIMINATION</a> (right)]</i></span></li><li><span>From NOT <em>A</em> [assuming NOT <em>B</em>]: deduce (NOT <em>B</em>) IMPLIES (NOT <em>A</em>). <i>[<a href="https://en.wikipedia.org/wiki/Deduction_theorem" target="_blank">DEDUCTION THEOREM</a>]</i></span></li><li><span>QED!</span></li>';

 var Exercise126b = new Exercise("12.6(b)", '<A HREF="https://en.wikipedia.org/wiki/Modus_tollens" target="_blank">MODUS TOLLENS</A>', [IMPLIES(A,B), NOT(B)], NOT(A),5);
 Exercise126b.unlockedBy(Exercise121);
Exercise126b.proof = '<li><span><em>A</em> IMPLIES <em>B</em>. <i>[given]</i></span></li><li><span>NOT <em>B</em>. <i>[given]</i></span></li><li><span>From <em>A</em> IMPLIES <em>B</em>: deduce (NOT <em>B</em>) IMPLIES (NOT <em>A</em>). <i>[<a href="https://en.wikipedia.org/wiki/Contraposition" target="_blank">CONTRAPOSITION</a>]</i></span></li><li><span>From NOT <em>B</em>, (NOT <em>B</em>) IMPLIES (NOT <em>A</em>): deduce NOT <em>A</em>. <i>[<a href="https://en.wikipedia.org/wiki/Modus_ponens" target="_blank">MODUS PONENS</a>]</i></span></li><li><span>QED!</span></li>';

 var Exercise126c = new Exercise("12.6(c)", "SUBSTITUTION FOR NOT", [NOT(A), IFF(A,B)], NOT(B),5);
 Exercise126c.unlockedBy(Exercise121);
 Exercise126c.notes ="Thanks to Haggai Nuchi for a short proof, and Tyler Freeman, Jim Apple, and Jorge Ca√±izales D√≠az for an even shorter proof.";
Exercise126c.proof = '<li><span>NOT <em>A</em>. <i>[given]</i></span></li><li><span><em>A</em> IFF <em>B</em>. <i>[given]</i></span></li><li><span>From <em>A</em> IFF <em>B</em>: deduce <em>B</em> IMPLIES <em>A</em>. <i>[BICONDITIONAL ELIMINATION (right)]</i></span></li><li><span>From <em>B</em> IMPLIES <em>A</em>, NOT <em>A</em>: deduce NOT <em>B</em>. <i>[<a href="https://en.wikipedia.org/wiki/Modus_tollens" target="_blank">MODUS TOLLENS</a>]</i></span></li><li><span>QED!</span></li>';

 var Exercise127 = new Exercise("12.7", '<A HREF="https://en.wikipedia.org/wiki/Peirce%27s_law" target="_blank">PEIRCE\'S LAW</A>', [IMPLIES(IMPLIES(A,B),A)], A,9);
 Exercise127.unlockedBy(Exercise121);
Exercise127.proof = '<li><span>(<em>A</em> IMPLIES <em>B</em>) IMPLIES <em>A</em>. <i>[given]</i></span></li><li><span>Deduce NOT <em>A</em> [assuming NOT <em>A</em>]. <i>[IMPLICATION INTRODUCTION]</i></span></li><li><span>From NOT <em>A</em> [assuming NOT <em>A</em>]: deduce (NOT <em>A</em>) OR <em>B</em> [assuming NOT <em>A</em>]. <i>[<a href="https://en.wikipedia.org/wiki/Disjunction_introduction" target="_blank">DISJUNCTION INTRODUCTION</a> (left)]</i></span></li><li><span>From (NOT <em>A</em>) OR <em>B</em> [assuming NOT <em>A</em>]: deduce <em>A</em> IMPLIES <em>B</em> [assuming NOT <em>A</em>]. <i>[EXERCISE 12.4(b)]</i></span></li><li><span>From (<em>A</em> IMPLIES <em>B</em>) IMPLIES <em>A</em>: deduce (<em>A</em> IMPLIES <em>B</em>) IMPLIES <em>A</em> [assuming NOT <em>A</em>]. <i>[PUSH]</i></span></li><li><span>From <em>A</em> IMPLIES <em>B</em> [assuming NOT <em>A</em>], (<em>A</em> IMPLIES <em>B</em>) IMPLIES <em>A</em> [assuming NOT <em>A</em>]: deduce <em>A</em> [assuming NOT <em>A</em>]. <i>[<a href="https://en.wikipedia.org/wiki/Modus_ponens" target="_blank">MODUS PONENS</a>]</i></span></li><li><span>From <em>A</em> [assuming NOT <em>A</em>], NOT <em>A</em> [assuming NOT <em>A</em>]: deduce NOT (NOT <em>A</em>). <i>[<a href="https://en.wikipedia.org/wiki/Reductio_ad_absurdum" target="_blank">REDUCTIO AD ABSURDUM</a> (separated form)]</i></span></li><li><span>From NOT (NOT <em>A</em>): deduce <em>A</em>. <i>[DOUBLE NEGATION (right)]</i></span></li><li><span>QED!</span></li>';

 var Exercise128 = new Exercise("12.8", '<A HREF="https://en.wikipedia.org/wiki/Resolution_(logic)" target="_blank">RESOLUTION</A>', [OR(A,B), OR(NOT(A),C)], OR(C,B), 5);
 Exercise128.unlockedBy(Exercise121);
 Exercise128.proof = '<li><span><em>A</em> OR <em>B</em>. <i>[given]</i></span></li><li><span>(NOT <em>A</em>) OR <em>C</em>. <i>[given]</i></span></li><li><span>From (NOT <em>A</em>) OR <em>C</em>: deduce <em>A</em> IMPLIES <em>C</em>. <i>[EXERCISE 12.4(b)]</i></span></li><li><span>From <em>A</em> OR <em>B</em>, <em>A</em> IMPLIES <em>C</em>: deduce <em>C</em> OR <em>B</em>. <i>[<a href="https://en.wikipedia.org/wiki/Constructive_dilemma" target="_blank">CONSTRUCTIVE DILEMMA</a> (left)]</i></span></li><li><span>QED!</span></li>';

newSection("13", "True and false");

var trueLaw = new Law("TRUE", [formulaContext(TRUE())], TRUE());
var falseLaw = new Law("NOT FALSE", [formulaContext(NOT(FALSE()))], NOT(FALSE()));
var Exercise131 = new Exercise("13.1(a)", "TRUE IS IDENTITY FOR AND", [formulaContext(A)], IFF(A,AND(TRUE(),A)),7);
Exercise131.unlocks(trueLaw);
Exercise131.unlocks(falseLaw);
Exercise131.unlockedBy(Exercise121);
Exercise131.notes = "<UL><LI> In propositional logic, there are two formulas with a constant truth value: TRUE, which is always true, and FALSE, which is never true.  These have now been permanently added to the <B>Formulas</B> window for use.</LI> <LI> There is just one law for TRUE: TRUE is always true!  To use it, drag TRUE from the <B>Formulas</B> window to any environment (or just click on TRUE, if one wants to create it in the root environment).</LI> <LI> Similarly, there is one law for FALSE, namely that NOT(FALSE) is always true.  To use it, create the formula NOT(FALSE) in the <B>Formulas</B> window and drag it to any environment (or click on NOT(FALSE)).</LI> <LI> Another feature that can be of some minor convenience: if a formula already exists in an enviroment, you can create a copy in the <B>Formulas</B> window by dragging to that window.</UL>";
Exercise131.revealTrueFalse = true;
Exercise131.proof = '<li><span>Deduce <em>A</em> [assuming <em>A</em>]. <i>[IMPLICATION INTRODUCTION]</i></span></li><li><span>Deduce TRUE [assuming <em>A</em>]. <i>[TRUE]</i></span></li><li><span>From TRUE [assuming <em>A</em>], <em>A</em> [assuming <em>A</em>]: deduce TRUE AND <em>A</em> [assuming <em>A</em>]. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_introduction" target="_blank">CONJUNCTION INTRODUCTION</a>]</i></span></li><li><span>Deduce TRUE AND <em>A</em> [assuming TRUE AND <em>A</em>]. <i>[IMPLICATION INTRODUCTION]</i></span></li><li><span>From TRUE AND <em>A</em> [assuming TRUE AND <em>A</em>]: deduce <em>A</em> [assuming TRUE AND <em>A</em>]. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_elimination" target="_blank">CONJUNCTION ELIMINATION</a> (right)]</i></span></li><li><span>From <em>A</em> [assuming TRUE AND <em>A</em>], TRUE AND <em>A</em> [assuming <em>A</em>]: deduce <em>A</em> IFF (TRUE AND <em>A</em>). <i>[BICONDITIONAL INTRODUCTION (ASSUMPTION FORM)]</i></span></li><li><span>QED! (again)</span></li>';

var Exercise131b = new Exercise("13.1(b)", "FALSE IS IDENTITY FOR OR", [formulaContext(A)], IFF(A,OR(FALSE(),A)),7);
Exercise131b.unlockedBy(Exercise131);
Exercise131b.proof = '<li><span>Deduce <em>A</em> [assuming <em>A</em>]. <i>[IMPLICATION INTRODUCTION]</i></span></li><li><span>From <em>A</em> [assuming <em>A</em>]: deduce FALSE OR <em>A</em> [assuming <em>A</em>]. <i>[<a href="https://en.wikipedia.org/wiki/Disjunction_introduction" target="_blank">DISJUNCTION INTRODUCTION</a> (right)]</i></span></li><li><span>Deduce FALSE OR <em>A</em> [assuming FALSE OR <em>A</em>]. <i>[IMPLICATION INTRODUCTION]</i></span></li><li><span>Deduce NOT FALSE [assuming FALSE OR <em>A</em>]. <i>[NOT FALSE]</i></span></li><li><span>From FALSE OR <em>A</em> [assuming FALSE OR <em>A</em>], NOT FALSE [assuming FALSE OR <em>A</em>]: deduce <em>A</em> [assuming FALSE OR <em>A</em>]. <i>[<a href="https://en.wikipedia.org/wiki/Disjunctive_syllogism" target="_blank">DISJUNCTIVE ELIMINATION</a> (left)]</i></span></li><li><span>From <em>A</em> [assuming FALSE OR <em>A</em>], FALSE OR <em>A</em> [assuming <em>A</em>]: deduce <em>A</em> IFF (FALSE OR <em>A</em>). <i>[BICONDITIONAL INTRODUCTION (ASSUMPTION FORM)]</i></span></li><li><span>QED!</span></li>';

var Exercise132 = new Exercise("13.2(a)", "FALSE ANNULS AND", [formulaContext(A)], NOT(AND(FALSE(),A)),4);
Exercise132.unlockedBy(Exercise131);
 Exercise132.notes ="Thanks to Pace Nielsen, Elliot Parlin, Adam Glasgall, Ephim Kolmogorov, and Loren Spice for a short proof.";
Exercise132.proof = '<li><span>Deduce NOT FALSE. <i>[NOT FALSE]</i></span></li><li><span>From NOT FALSE: deduce (NOT FALSE) OR (NOT <em>A</em>). <i>[<a href="https://en.wikipedia.org/wiki/Disjunction_introduction" target="_blank">DISJUNCTION INTRODUCTION</a> (left)]</i></span></li><li><span>From (NOT FALSE) OR (NOT <em>A</em>): deduce NOT (FALSE AND <em>A</em>). <i>[<a href="https://en.wikipedia.org/wiki/De_Morgan%27s_laws" target="_blank">DE MORGAN\'S LAW</a> II]</i></span></li><li><span>QED!</span></li>';

var Exercise132b = new Exercise("13.2(b)", "TRUE ANNULS OR", [formulaContext(A)], OR(TRUE(),A),3);
Exercise132b.unlockedBy(Exercise131);
Exercise132b.proof = '<li><span>Deduce TRUE. <i>[TRUE]</i></span></li><li><span>From TRUE: deduce TRUE OR <em>A</em>. <i>[<a href="https://en.wikipedia.org/wiki/Disjunction_introduction" target="_blank">DISJUNCTION INTRODUCTION</a> (left)]</i></span></li><li><span>QED!</span></li>';

var Exercise133 = new Exercise("13.3(a)", "EX FALSO QUODLIBET (boolean version)", [formulaContext(A)], IMPLIES(FALSE(),A),4);
Exercise133.unlockedBy(Exercise131);
Exercise133.notes = 'Thanks to Anders Kaseorg, Jacob Hobbs, and Pace Nielsen for the short proof.';
Exercise133.proof = '<li><span>Deduce NOT FALSE. <i>[NOT FALSE]</i></span></li><li><span>From NOT FALSE: deduce (NOT FALSE) OR <em>A</em>. <i>[<a href="https://en.wikipedia.org/wiki/Disjunction_introduction" target="_blank">DISJUNCTION INTRODUCTION</a> (left)]</i></span></li><li><span>From (NOT FALSE) OR <em>A</em>: deduce FALSE IMPLIES <em>A</em>. <i>[EXERCISE 12.4(b)]</i></span></li><li><span>QED!</span></li>';

var Exercise133b = new Exercise("13.3(b)", "", [formulaContext(A)], IMPLIES(A,TRUE()),4);
Exercise133b.unlockedBy(Exercise131);
Exercise133b.proof = '<li><span>Deduce <em>A</em> [assuming <em>A</em>]. <i>[IMPLICATION INTRODUCTION]</i></span></li><li><span>Deduce TRUE [assuming <em>A</em>]. <i>[TRUE]</i></span></li><li><span>From TRUE [assuming <em>A</em>]: deduce <em>A</em> IMPLIES TRUE. <i>[<a href="https://en.wikipedia.org/wiki/Deduction_theorem" target="_blank">DEDUCTION THEOREM</a>]</i></span></li><li><span>QED!</span></li>';

var Exercise133c = new Exercise("13.3(c)", "", [formulaContext(A)], IFF(A, IMPLIES(TRUE(),A)),7);
Exercise133c.unlockedBy(Exercise131);
Exercise133c.proof = '<li><span>Deduce <em>A</em> IMPLIES (TRUE IMPLIES <em>A</em>). <i>[EXERCISE 7.1]</i></span></li><li><span>Deduce TRUE IMPLIES <em>A</em> [assuming TRUE IMPLIES <em>A</em>]. <i>[IMPLICATION INTRODUCTION]</i></span></li><li><span>Deduce TRUE [assuming TRUE IMPLIES <em>A</em>]. <i>[TRUE]</i></span></li><li><span>From TRUE [assuming TRUE IMPLIES <em>A</em>], TRUE IMPLIES <em>A</em> [assuming TRUE IMPLIES <em>A</em>]: deduce <em>A</em> [assuming TRUE IMPLIES <em>A</em>]. <i>[<a href="https://en.wikipedia.org/wiki/Modus_ponens" target="_blank">MODUS PONENS</a>]</i></span></li><li><span>From <em>A</em> [assuming TRUE IMPLIES <em>A</em>]: deduce (TRUE IMPLIES <em>A</em>) IMPLIES <em>A</em>. <i>[<a href="https://en.wikipedia.org/wiki/Deduction_theorem" target="_blank">DEDUCTION THEOREM</a>]</i></span></li><li><span>From <em>A</em> IMPLIES (TRUE IMPLIES <em>A</em>), (TRUE IMPLIES <em>A</em>) IMPLIES <em>A</em>: deduce <em>A</em> IFF (TRUE IMPLIES <em>A</em>). <i>[BICONDITIONAL INTRODUCTION]</i></span></li><li><span>QED!</span></li>';

var Exercise133d = new Exercise("13.3(d)", "", [formulaContext(A)], IFF(NOT(A), IMPLIES(A,FALSE())),8);
Exercise133d.unlockedBy(Exercise131);
Exercise133d.notes = 'Thanks to Anders Kaseorg for the short proof, to Jacob Hobbs for a shorter proof, and to Pace Nielsen for an even shorter proof.';
Exercise133d.proof = '<li><span>Deduce <em>A</em> IMPLIES FALSE [assuming <em>A</em> IMPLIES FALSE]. <i>[IMPLICATION INTRODUCTION]</i></span></li><li><span>Deduce NOT FALSE [assuming <em>A</em> IMPLIES FALSE]. <i>[NOT FALSE]</i></span></li><li><span>From <em>A</em> IMPLIES FALSE [assuming <em>A</em> IMPLIES FALSE], NOT FALSE [assuming <em>A</em> IMPLIES FALSE]: deduce NOT <em>A</em> [assuming <em>A</em> IMPLIES FALSE]. <i>[<a href="https://en.wikipedia.org/wiki/Modus_tollens" target="_blank">MODUS TOLLENS</a>]</i></span></li><li><span>Deduce NOT <em>A</em> [assuming NOT <em>A</em>]. <i>[IMPLICATION INTRODUCTION]</i></span></li><li><span>From NOT <em>A</em> [assuming NOT <em>A</em>]: deduce (NOT <em>A</em>) OR FALSE [assuming NOT <em>A</em>]. <i>[<a href="https://en.wikipedia.org/wiki/Disjunction_introduction" target="_blank">DISJUNCTION INTRODUCTION</a> (left)]</i></span></li><li><span>From (NOT <em>A</em>) OR FALSE [assuming NOT <em>A</em>]: deduce <em>A</em> IMPLIES FALSE [assuming NOT <em>A</em>]. <i>[EXERCISE 12.4(b)]</i></span></li><li><span>From NOT <em>A</em> [assuming <em>A</em> IMPLIES FALSE], <em>A</em> IMPLIES FALSE [assuming NOT <em>A</em>]: deduce (NOT <em>A</em>) IFF (<em>A</em> IMPLIES FALSE). <i>[BICONDITIONAL INTRODUCTION (ASSUMPTION FORM)]</i></span></li><li><span>QED!</span></li>';

newSection("14", "Free variables");


var Exercise141 = new Exercise("14.1", "", [assuming(Px,x)], assuming(IMPLIES(Qx,AND(Px,Qx)),x), 6);
Exercise141.unlockedBy(Exercise131);
Exercise141.notes = '<B>Note:</B> this section, and subsequent ones, are in alpha release, and may be subject to change as the version updates.  Please report any bugs found here to tao@math.ucla.edu.<UL><LI> In previous sections we were working in the simple setting of <A HREF="https://en.wikipedia.org/wiki/Propositional_calculus" target="_blank">propositional logic</A>, in which the atomic propositions were given short names such as <I>A</I>, <I>B</I>, or <I>C</I>, and had no further internal structure.  We now begin the exploration of a powerful extension of this logic known as <A HREF="https://en.wikipedia.org/wiki/First-order_logic" target="_blank">first-order logic</A> (or <I>predicate logic</I>), in which the atomic propositions may now depend on one or more <I>variables</I> such as <I>x</I>, <I>y</I>, <I>z</I>.  First-order logic is the standard logical framework for most of modern mathematics.</LI>  <LI> For now, we focus on the type of variable known as <A HREF="https://en.wikipedia.org/wiki/Free_variables_and_bound_variables" target="_blank">free variables</A>.</LI> <LI> A free variable can take any value within a given <A HREF="https://en.wikipedia.org/wiki/Domain_of_discourse" target="_blank">domain of discourse</A>.  The precise domain of discourse used is important when applying first-order logic to mathematical situations; for instance, if one is doing number theory, the domain of discourse might be the real numbers, while if one is doing group theory, domain of discourse might be the collection of elements of the group.  For more complicated mathematics, the domain of discourse may be the <A HREF="https://en.wikipedia.org/wiki/Universe_(mathematics)" target="_blank">universe of sets</A>.  However the rules of first-order logic do not care exactly what this domain is, so we will usually leave the domain unspecified.</LI>  <LI> In previous sections, we created sub-environments of the <B>Root environment</B> in which certain sentences were assumed to be true.  In first-order logic, one can also create sub-environments in which new free variables are introduced and allowed to range freely in the domain of discourse.  Any statement in such a sub-environment is known to be true for all values of this variable. </LI> <LI>All the usual laws of propositional logic apply within such sub-environments, with one new wrinkle: if one wants to use a sentence such as <I>P(x)</I> that depends on a variable <I>x</I>, one can only do so inside an environment in which that variable has been introduced.  For instance, <I>P(x)</I> cannot be directly used in the <B>Root environment</B>, but can be used in a sub-environment where <I>x</I> is arbitrary.  (Try dragging <I>P(x)</I> or <I>Q(x)</I> to various environments to see what happens!)</LI><LI> <B>Technical note</B>: matching has not been automatically implemented on exercises containing terms such as <I>P(x)</I> that involve variables.  As such, once one completes exercises in this section and later ones, it may not necessarily be possible to apply these exercises the same way as for preceding exercises.  I hope to implement this functionality in the future.</LI></UL>';
Exercise141.proof = '<li><span><i>P</i>(<i>x</i>) [letting <i>x</i> be arbitrary]. <i>[given]</i></span></li><li><span>Deduce <i>Q</i>(<i>x</i>) [letting <i>x</i> be arbitrary, assuming <i>Q</i>(<i>x</i>)]. <i>[IMPLICATION INTRODUCTION]</i></span></li><li><span>From <i>P</i>(<i>x</i>) [letting <i>x</i> be arbitrary]: deduce <i>P</i>(<i>x</i>) [letting <i>x</i> be arbitrary, assuming <i>Q</i>(<i>x</i>)]. <i>[PUSH]</i></span></li><li><span>From <i>P</i>(<i>x</i>) [letting <i>x</i> be arbitrary, assuming <i>Q</i>(<i>x</i>)], <i>Q</i>(<i>x</i>) [letting <i>x</i> be arbitrary, assuming <i>Q</i>(<i>x</i>)]: deduce <i>P</i>(<i>x</i>) AND <i>Q</i>(<i>x</i>) [letting <i>x</i> be arbitrary, assuming <i>Q</i>(<i>x</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_introduction" target="_blank">CONJUNCTION INTRODUCTION</a>]</i></span></li><li><span>From <i>P</i>(<i>x</i>) AND <i>Q</i>(<i>x</i>) [letting <i>x</i> be arbitrary, assuming <i>Q</i>(<i>x</i>)]: deduce <i>Q</i>(<i>x</i>) IMPLIES (<i>P</i>(<i>x</i>) AND <i>Q</i>(<i>x</i>)) [letting <i>x</i> be arbitrary]. <i>[<a href="https://en.wikipedia.org/wiki/Deduction_theorem" target="_blank">DEDUCTION THEOREM</a>]</i></span></li><li><span>QED!</span></li>';

newSection("15", "Push (for free variables)");

var PushVar = new Law("PUSH (for free variables)", [A, x], assuming(A, x));
var Exercise151 = new Exercise("15.1", "", [assuming(Px,x), assuming(assuming(Qxy,y),x)], assuming(assuming(AND(Px,Qxy),y),x), 5);
Exercise151.unlocks(PushVar);
Exercise151.unlockedBy(Exercise141);
Exercise151.notes = '<UL><LI> We already know that a sentence (such as <I>A</I>) can be pushed into a sub-environment in which an additional statement (such as <I>B</I>) is assumed.</LI><LI>  Similarly, we may push a sentence into a sub-environment in which an additional free variable (such as <I>x</I>) is introduced.</LI><LI> By invoking the push law in this fashion, we may end up with statements that do not depend on all of the ambient free variables, but this is perfectly acceptable in first-order logic. (However, as mentioned previously, in any given environment, it is not permitted to work with sentences that depend on free variables that have not been introduced into that environment.)</LI></UL>'
Exercise151.proof = '<li><span><i>P</i>(<i>x</i>) [letting <i>x</i> be arbitrary]. <i>[given]</i></span></li><li><span><i>Q</i>(<i>x</i>, <i>y</i>) [letting <i>x</i>, <i>y</i> be arbitrary]. <i>[given]</i></span></li><li><span>From <i>P</i>(<i>x</i>) [letting <i>x</i> be arbitrary]: deduce <i>P</i>(<i>x</i>) [letting <i>x</i>, <i>y</i> be arbitrary]. <i>[PUSH (for free variables)]</i></span></li><li><span>From <i>P</i>(<i>x</i>) [letting <i>x</i>, <i>y</i> be arbitrary], <i>Q</i>(<i>x</i>, <i>y</i>) [letting <i>x</i>, <i>y</i> be arbitrary]: deduce <i>P</i>(<i>x</i>) AND <i>Q</i>(<i>x</i>, <i>y</i>) [letting <i>x</i>, <i>y</i> be arbitrary]. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_introduction" target="_blank">CONJUNCTION INTRODUCTION</a>]</i></span></li><li><span>QED!</span></li>';

var Exercise152 = new Exercise("15.2(a)", "DOUBLE PUSH (for free variables)", [A, environmentContext([x,y])], assuming(assuming(A,y),x),5);
Exercise152.unlockedBy(Exercise151);
Exercise152.notes = 'This is the analogue of the DOUBLE PUSH law for assumptions introduced in Exercise 7.2, and can similarly be used to shorten some of the proofs in subsequent exercises.';
Exercise152.proof = '<li><span><em>A</em>. <i>[given]</i></span></li><li><span>Form environment [letting <i>x</i>, <i>y</i> be arbitrary]. <i>[given]</i></span></li><li><span>From <em>A</em>: deduce <em>A</em> [letting <i>x</i> be arbitrary]. <i>[PUSH (for free variables)]</i></span></li><li><span>From <em>A</em> [letting <i>x</i> be arbitrary]: deduce <em>A</em> [letting <i>x</i>, <i>y</i> be arbitrary]. <i>[PUSH (for free variables)]</i></span></li><li><span>QED! (again)</span></li>';

var Exercise152b = new Exercise("15.2(b)", "DOUBLE PUSH (mixed version I)", [A, environmentContext([B,x])], assuming(assuming(A,x),B),5);
Exercise152b.notes = 'It will also be helpful to have "mixed" double pushes involving both assumptions and arbitrary variables.';
Exercise152b.unlockedBy(Exercise151);

var Exercise152c = new Exercise("15.2(c)", "DOUBLE PUSH (mixed version II)", [A, environmentContext([x,B])], assuming(assuming(A,B),x),5);
Exercise152c.unlockedBy(Exercise151);

newSection("16", "Free variable introduction");

var freeLaw = new Law("FREE VARIABLE INTRODUCTION", [toTerm(x)], x);
var Exercise161 = new Exercise("16.1", "", [formulaContext(Qxy)], assuming(assuming(OR(Qxy, NOT(Qxy)),y),x), 4);
Exercise161.unlockedBy(Exercise151);
Exercise161.unlocks(freeLaw);
Exercise161.revealTermWindow = true;
Exercise161.notes = '<UL><LI>In any environment, one may introduce any free variable that is not already in use, thus forming a new environment in which that free variable is arbitrary.</LI><LI>To do this, drag a free variable from the (now unlocked) <B>Terms</B> window to the target environment (or, if one wants to start from the root environment, one can just click on a free variable).</LI><LI> If all the free variables in the <B>Terms</B> window are already in use, you can click on the "New free variable" button to create a further free variable.</LI><LI>Later, we will introduce some other types of terms than free variables, namely bound variables, primitive terms, and operators applied to other terms. But for now, the <B>Terms</B> window will only be occupied by free variables.</LI></UL>';
Exercise161.proof = '<li><span>Form environment [letting <i>x</i> be arbitrary]. <i>[FREE VARIABLE INTRODUCTION]</i></span></li><li><span>Form environment [letting <i>x</i>, <i>y</i> be arbitrary]. <i>[FREE VARIABLE INTRODUCTION]</i></span></li><li><span>Deduce <i>Q</i>(<i>x</i>, <i>y</i>) OR (NOT <i>Q</i>(<i>x</i>, <i>y</i>)) [letting <i>x</i>, <i>y</i> be arbitrary]. <i>[<a href="https://en.wikipedia.org/wiki/Law_of_excluded_middle" target="_blank">EXCLUDED MIDDLE</a>]</i></span></li><li><span>QED!</span></li>';

newSection("17", "Universal quantification");

var forAllLaw = new Law("FOR ALL", [formulaContext(A), toTerm(X)], formulaContext(forAll(A,X)));
var Exercise171 = new Exercise("17.1", "", [formulaContext(Px)], forAll(IMPLIES(PX,PX),X), 4);
Exercise171.unlockedBy(Exercise161);
Exercise171.unlocks(forAllLaw);
Exercise171.unlocks(universalIntroduction);
Exercise171.unlocks(universalIntroduction2);
Exercise171.revealBoundButton = true;
Exercise171.notes = '<UL><LI>Recall the <A HREF="https://en.wikipedia.org/wiki/Deduction_theorem" target="_blank">deduction theorem</A>, which allowed one to convert a statement <I>A</I> that was only known conditionally on an assumption <I>B</I>, to a statement <I>A</I> IMPLIES <I>B</I> that was known unconditionally.</LI><LI> In a similar spirit, we have the law of <A HREF="https://en.wikipedia.org/wiki/Universal_generalization" target="_blank">universal introduction</A>: if one has established a statement <I>P(x)</I> under the assumption that the free variable <I>x</I> be arbitrary, then one can conclude the statement FOR ALL <I>X</I>: <I>P(X)</I> unconditionally.</LI> <LI> Note that it is the immediate environment of the statement <I>P(x)</I> that has to be of the form "<B>Let <I>x</I> be arbitrary</B>"; the law of universal quantification is not available if <I>P(x)</I> is deeply nested inside such an environment.</LI> <LI>  Here <I>X</I> is a different type of variable than a free variable, namely a <A HREF="https://en.wikipedia.org/wiki/Free_variables_and_bound_variables" target="_blank">bound variable</A>.  <I>P(X)</I> is formed from <I>P(x)</I> by replacing every occurrence of the free variable <I>x</I> in <I>P(x)</I> with the bound variable <I>X</I>.</LI><LI> Bound variables need to have different names from free variables; in this text, we ensure this by using lower case letters such as <I>x</I>, <I>y</I>, <I>z</I> for free variables and upper case variables such as <I>X</I>, <I>Y</I>, <I>Z</I> for bound variables. (Note: this convention is not standard in the mathematics literature; usually, one sees free and bound variables share the same namespace, and then one has to ensure that a variable is not simultaneously used as a free variable and as a bound variable.)</LI> <LI>  Both free and bound variables will be placed in the <B>Terms</B> window.  In later sections we will also introduce further types of terms.</LI><LI> A bound variable such as <I>X</I> can only be used in statements in various environments if they are "bound" by an appropriate quantifier.  </LI> <LI> For instance, the formula <I>P(X)</I> cannot be directly used in environment windows right now, as it is not bound by a quantifier.  (However, we still consider it to be a valid formula.)</LI><LI> Currently, the only available quantifier is the universal quantifier "FOR ALL"; later we will also introduce the existential quantifier "THERE EXISTS".</LI><LI> Quantifiers can be nested, as long as each quantifier uses different bound variables: "FOR ALL <I>X</I>: (FOR ALL <I>Y</I>: <I>Q(X,Y)</I>)" is a valid formula, but "FOR ALL <I>X</I>: (FOR ALL <I>X</I>: <I>Q(X,X)</I>)" is not.</LI><LI> To use the law of universal introduction, either drag a statement (in which some free variable is arbitrary) to a bound variable in the <B>Terms</B> window, or drag it to the parent environment.</LI><LI> In the former case, the bound variable selected will be used to perform universal quantification.  In the latter case, the text will pick the next available bound variable.</LI><LI>  As with free variables, a button is now provided to produce additional bound variables, should this prove necessary.</LI></UL>';
Exercise171.proof = '<li><span>Form environment [letting <i>x</i> be arbitrary]. <i>[FREE VARIABLE INTRODUCTION]</i></span></li><li><span>Deduce <i>P</i>(<i>x</i>) IMPLIES <i>P</i>(<i>x</i>) [letting <i>x</i> be arbitrary]. <i>[IMPLIES IS <a href="https://en.wikipedia.org/wiki/Idempotence" target="_blank" target="_blank">IDEMPOTENT</a>]</i></span></li><li><span>From <i>P</i>(<i>x</i>) IMPLIES <i>P</i>(<i>x</i>) [letting <i>x</i> be arbitrary]: deduce FOR ALL <i>X</i>: (<i>P</i>(<i>X</i>) IMPLIES <i>P</i>(<i>X</i>)). <i>[UNIVERSAL INTRODUCTION]</i></span></li><li><span>QED!</span></li>';

var Exercise172 = new Exercise("17.2", "", [formulaContext(QXY)], IMPLIES(forAll(forAll(QXY,Y),X),forAll(forAll(QXY,Y),X)), 2);
Exercise172.unlockedBy(Exercise171);
Exercise172.notes = '<UL><LI> To create a formula of the form "FOR ALL <I>X</I>: <I>P(X)</I>", create the formula "<I>P(X)</I>" and drag it to the bound variable <I>X</I> (or vice versa).</LI><LI> As previously noted, we allow the <B>Formulas</B> window to contain formulas such as <I>Q(X,Y)</I> that contain unquantified bound variables.  As such, these formulas cannot be <I>directly</I> used in an environment window; however, after enclosing such formulas in quantifiers to bound all the bound variables, it becomes legal to use them in those windows.</LI></UL>';
Exercise172.proof = '<li><span>Deduce (FOR ALL <i>X</i>: (FOR ALL <i>Y</i>: <i>Q</i>(<i>X</i>, <i>Y</i>))) IMPLIES (FOR ALL <i>X</i>: (FOR ALL <i>Y</i>: <i>Q</i>(<i>X</i>, <i>Y</i>))). <i>[IMPLIES IS <a href="&lt;A HREF="https://en.wikipedia.org/wiki/Idempotence" target="_blank" target="_blank">IDEMPOTENT</a>]</i></span></li><li><span>QED!</span></li>';

newSection("18", "Universal specification");


var Exercise181 = new Exercise("18.1", "RENAMING BOUND VARIABLE (universal)", [forAll(PX,X)], forAll(PY,Y), 6);
Exercise181.unlocks(universalSpecification);
Exercise181.unlockedBy(Exercise171);
Exercise181.notes = '<UL><LI>There is a reverse to the law of universal introduction, known as the law of <A HREF="https://en.wikipedia.org/wiki/Universal_instantiation" target="_blank">universal specification</A>.  It asserts that if FOR ALL <I>X</I>: <I>P(X)</I> is true, and <I>&alpha;</I> is a term which is <I>well-defined</I> in the sense that it does not involve bound variables or free variables not present in the environment, then <I>P(&alpha;)</I> is also true.</LI> <LI> Here, <I>X</I> is a bound variable, <I>P(X)</I> is any statement that can involve the variable <I>X</I>.</LI> <LI> At present, the only terms you have seen are free variables and bound variables, so the law can only be currently applied to free variables <I>&alpha;</I>.  However, some further examples of terms will be introduced later.</LI> <LI> As with all other laws, this law is only applicable if the conclusion <I>P(&alpha;)</I> is <A HREF="https://en.wikipedia.org/wiki/Well-formed_formula" target="_blank">well-formed</A>: in particular, the statement <I>P(&alpha;)</I> cannot use free variables that are not present in the environment, nor can it have nested quantifiers involving the same bound variable.</LI> <LI> The law of universal specification can fail if one permits <I>&alpha;</I> to contain bound variables.  For instance, using the natural numbers as the domain of discourse, the sentence "FOR ALL <I>X</I>: THERE EXISTS <I>Y</I>: <I>Y</I>=<I>X</I>+1" is true (every natural number has a successor), but one cannot specify <I>X</I> to equal <I>Y</I> to conclude the (incorrect) statement THERE EXISTS <I>Y</I>: <I>Y</I>=<I>Y</I>+1.  However, if <I>y</I> is an ambient free variable in the current environment, one may specify <I>X</I> to equal <I>y</I> and conclude THERE EXISTS <I>Y</I>: <I>Y</I>=<I>y</I>+1.  <LI> To use the law of universal specification, drag a sentence of the form FOR ALL <I>X</I>: <I>P(X)</I> to a term <I>&alpha;</I> or vice versa.</LI><LI> Note that currently the law does not work in the <B>Root environment</B>, because the unquantified bound variables <I>X,Y</I> cannot be used in this environment; similarly for any further free and bound variables one creates.  How would one get around this problem?</UL>';
Exercise181.proof = '<li><span>FOR ALL <i>X</i>: <i>P</i>(<i>X</i>). <i>[given]</i></span></li><li><span>Form environment [letting <i>x</i> be arbitrary]. <i>[FREE VARIABLE INTRODUCTION]</i></span></li><li><span>From FOR ALL <i>X</i>: <i>P</i>(<i>X</i>): deduce FOR ALL <i>X</i>: <i>P</i>(<i>X</i>) [letting <i>x</i> be arbitrary]. <i>[PUSH (for free variables)]</i></span></li><li><span>From FOR ALL <i>X</i>: <i>P</i>(<i>X</i>) [letting <i>x</i> be arbitrary]: deduce <i>P</i>(<i>x</i>) [letting <i>x</i> be arbitrary]. <i>[<a href="" target="_blank">UNIVERSAL SPECIFICATION</a>]</i></span></li><li><span>From <i>P</i>(<i>x</i>) [letting <i>x</i> be arbitrary]: deduce FOR ALL <i>Y</i>: <i>P</i>(<i>Y</i>). <i>[<a href="https://en.wikipedia.org/wiki/Universal_generalization" target="_blank"> UNIVERSAL INTRODUCTION</a>]</i></span></li><li><span>QED!</span></li>';

var Exercise182 = new Exercise("18.2(a)", "", [A, toTerm(X)], forAll(A,X), 5);
Exercise182.unlockedBy(Exercise181);
Exercise182.proof = '<li><span><em>A</em>. <i>[given]</i></span></li><li><span>Form environment [letting <i>x</i> be arbitrary]. <i>[FREE VARIABLE INTRODUCTION]</i></span></li><li><span>From <em>A</em>: deduce <em>A</em> [letting <i>x</i> be arbitrary]. <i>[PUSH (for free variables)]</i></span></li><li><span>From <em>A</em> [letting <i>x</i> be arbitrary]: deduce FOR ALL <i>X</i>: <em>A</em>. <i>[<a href="https://en.wikipedia.org/wiki/Universal_generalization" target="_blank"> UNIVERSAL INTRODUCTION</a>]</i></span></li><li><span>QED!</span></li>';

var Exercise182b = new Exercise("18.2(b)", universalSpecification2, null, null, 5);
Exercise182b.unlockedBy(Exercise181);
Exercise182b.notes = '<UL><LI> This exercise, which reverses the universal introduction law from Section 17, will be helpful in some later exercises. (As such, it has been added to the matching code by hand, even though matching for general rules involving predicates have not yet been implemented.)</LI><LI> To use it, drag a statement of the form FOR ALL <I>X</I>: <I>P(X)</I> onto a free variable term such as <I>x</I> (or vice versa).</LI></UL>';
Exercise182b.proof = '<li><span>FOR ALL <i>X</i>: <i>P</i>(<i>X</i>). <i>[given]</i></span></li><li><span>Form environment [letting <i>x</i> be arbitrary]. <i>[FREE VARIABLE INTRODUCTION]</i></span></li><li><span>From FOR ALL <i>X</i>: <i>P</i>(<i>X</i>): deduce FOR ALL <i>X</i>: <i>P</i>(<i>X</i>) [letting <i>x</i> be arbitrary]. <i>[PUSH (for free variables)]</i></span></li><li><span>From FOR ALL <i>X</i>: <i>P</i>(<i>X</i>) [letting <i>x</i> be arbitrary]: deduce <i>P</i>(<i>x</i>) [letting <i>x</i> be arbitrary]. <i>[<a href="https://en.wikipedia.org/wiki/Universal_instantiation" target="_blank">UNIVERSAL SPECIFICATION</a>]</i></span></li><li><span>QED! (again)</span></li>';

var Exercise183 = new Exercise("18.3(a)", "BARBARA SYLLOGISM (singular form)", [forAll(IMPLIES(PX,QX),X), Pa], Qa, 5);
Exercise183.unlockedBy(Exercise181);
Exercise183.notes = '<UL><LI> The classical syllogisms of <A HREF="https://en.wikipedia.org/wiki/Term_logic" target="_blank">Aristotlean logic</A> consisted of two premises (a major premise and a minor premise), and a conclusion that could be drawn from those premises.  These syllogisms can be interpreted using the more modern language of first-order logic.</LI> <LI> One of the classical syllogisms is the <A HREF="https://en.wikipedia.org/wiki/Syllogism#Barbara_(AAA-1)" target="_blank">Barbara syllogism</A>.  A famous example of this syllogism (in its singular form) is "All men are mortal.  Socrates is a man.  Hence, Socrates is mortal." </LI> <LI> In this exercise, we model this syllogism by using <I>P(X)</I> to denote the statement "<I>X</I> is a man", <I>Q(X)</I> to denote the statement "<I>X</I> is a mortal", and <I>&alpha;</I> to denote Socrates.</LI> <LI> The term <I>&alpha;</I> is an example of a primitive term - neither a free variable or a bound variable, but an object or quantity that one can use in one\'s arguments.</LI> <LI>  Primitive terms are to terms as atomic propositions such as <I>A</I>, <I>B</I>, <I>C</I> are to propositions.  To avoid confusion with other objects in first-order logic, we will use Greek letters such as <I>&alpha;</I>, <I>&beta;</I>, <I>&gamma;</I> to refer to primitive terms (or more generally to terms that are not required to be free or bound variables)</LI><LI> Most of the other classical syllogisms will be treated in Section 22.</LI> </UL>';
Exercise183.proof = '<li><span>FOR ALL <i>X</i>: (<i>P</i>(<i>X</i>) IMPLIES <i>Q</i>(<i>X</i>)). <i>[given]</i></span></li><li><span><i>P</i>(Œ±). <i>[given]</i></span></li><li><span>From FOR ALL <i>X</i>: (<i>P</i>(<i>X</i>) IMPLIES <i>Q</i>(<i>X</i>)): deduce <i>P</i>(Œ±) IMPLIES <i>Q</i>(Œ±). <i>[<a href="" target="_blank">UNIVERSAL SPECIFICATION</a>]</i></span></li><li><span>From <i>P</i>(Œ±), <i>P</i>(Œ±) IMPLIES <i>Q</i>(Œ±): deduce <i>Q</i>(Œ±). <i>[<a href="https://en.wikipedia.org/wiki/Modus_ponens" target="_blank">MODUS PONENS</a>]</i></span></li><li><span>QED!</span></li>';

var Exercise183b = new Exercise("18.3(b)", "BARBARA SYLLOGISM (classical form)", [forAll(IMPLIES(PX,QX),X), forAll(IMPLIES(RX,PX),X)], forAll(IMPLIES(RX,QX),X), 7);
Exercise183b.unlockedBy(Exercise181);
Exercise183b.notes = '<UL><LI> There is another, more classical, form of the Barbara syllogism, a typical example of which is "All men are mortal.  All Greeks are men.  Hence, all Greeks are mortal".</LI> <LI> Again, we can model this in first-order logic as before, where now <I>R(X)</I> denotes the statement "<I>X</I> is Greek".</LI> <LI> We will present the other classical syllogisms of Aristotlean logic later in this text.</LI></UL>'
Exercise183b.proof = '<li><span>FOR ALL <i>X</i>: (<i>P</i>(<i>X</i>) IMPLIES <i>Q</i>(<i>X</i>)). <i>[given]</i></span></li><li><span>FOR ALL <i>X</i>: (<i>R</i>(<i>X</i>) IMPLIES <i>P</i>(<i>X</i>)). <i>[given]</i></span></li><li><span>From FOR ALL <i>X</i>: (<i>P</i>(<i>X</i>) IMPLIES <i>Q</i>(<i>X</i>)): deduce <i>P</i>(<i>x</i>) IMPLIES <i>Q</i>(<i>x</i>) [letting <i>x</i> be arbitrary]. <i>[REVERSE <a href="https://en.wikipedia.org/wiki/Universal_generalization" target="_blank"> UNIVERSAL INTRODUCTION</a>]</i></span></li><li><span>From FOR ALL <i>X</i>: (<i>R</i>(<i>X</i>) IMPLIES <i>P</i>(<i>X</i>)): deduce <i>R</i>(<i>x</i>) IMPLIES <i>P</i>(<i>x</i>) [letting <i>x</i> be arbitrary]. <i>[REVERSE <a href="https://en.wikipedia.org/wiki/Universal_generalization" target="_blank"> UNIVERSAL INTRODUCTION</a>]</i></span></li><li><span>From <i>R</i>(<i>x</i>) IMPLIES <i>P</i>(<i>x</i>) [letting <i>x</i> be arbitrary], <i>P</i>(<i>x</i>) IMPLIES <i>Q</i>(<i>x</i>) [letting <i>x</i> be arbitrary]: deduce <i>R</i>(<i>x</i>) IMPLIES <i>Q</i>(<i>x</i>) [letting <i>x</i> be arbitrary]. <i>[IMPLIES IS <a href="https://en.wikipedia.org/wiki/Transitive_relation" target="_blank">TRANSITIVE</a>]</i></span></li><li><span>From <i>R</i>(<i>x</i>) IMPLIES <i>Q</i>(<i>x</i>) [letting <i>x</i> be arbitrary]: deduce FOR ALL <i>X</i>: (<i>R</i>(<i>X</i>) IMPLIES <i>Q</i>(<i>X</i>)). <i>[<a href="https://en.wikipedia.org/wiki/Universal_generalization" target="_blank"> UNIVERSAL INTRODUCTION</a>]</i></span></li><li><span>QED!</span></li>';

var Exercise184 = new Exercise("18.4", 'FOR ALL IS <A HREF="https://en.wikipedia.org/wiki/Commutative_property" target="_blank">COMMUTATIVE</A>', [forAll(forAll(QXY,Y),X)], forAll(forAll(QXY,X),Y), 8);
Exercise184.unlockedBy(Exercise181);
Exercise184.notes = 'Thanks to Anders Kaseorg for the short proof.';
Exercise184.proof = '<li><span>FOR ALL <i>X</i>: (FOR ALL <i>Y</i>: <i>Q</i>(<i>X</i>, <i>Y</i>)). <i>[given]</i></span></li><li><span>Form environment [letting <i>y</i> be arbitrary]. <i>[FREE VARIABLE INTRODUCTION]</i></span></li><li><span>From FOR ALL <i>X</i>: (FOR ALL <i>Y</i>: <i>Q</i>(<i>X</i>, <i>Y</i>)): deduce FOR ALL <i>X</i>: (FOR ALL <i>Y</i>: <i>Q</i>(<i>X</i>, <i>Y</i>)) [letting <i>y</i> be arbitrary]. <i>[PUSH (for free variables)]</i></span></li><li><span>From FOR ALL <i>X</i>: (FOR ALL <i>Y</i>: <i>Q</i>(<i>X</i>, <i>Y</i>)) [letting <i>y</i> be arbitrary]: deduce FOR ALL <i>Y</i>: <i>Q</i>(<i>x</i>, <i>Y</i>) [letting <i>y</i>, <i>x</i> be arbitrary]. <i>[REVERSE <a href="https://en.wikipedia.org/wiki/Universal_generalization" target="_blank"> UNIVERSAL INTRODUCTION</a>]</i></span></li><li><span>From FOR ALL <i>Y</i>: <i>Q</i>(<i>x</i>, <i>Y</i>) [letting <i>y</i>, <i>x</i> be arbitrary]: deduce <i>Q</i>(<i>x</i>, <i>y</i>) [letting <i>y</i>, <i>x</i> be arbitrary]. <i>[<a href="https://en.wikipedia.org/wiki/Universal_instantiation" target="_blank">UNIVERSAL SPECIFICATION</a>]</i></span></li><li><span>From <i>Q</i>(<i>x</i>, <i>y</i>) [letting <i>y</i>, <i>x</i> be arbitrary]: deduce FOR ALL <i>X</i>: <i>Q</i>(<i>X</i>, <i>y</i>) [letting <i>y</i> be arbitrary]. <i>[<a href="https://en.wikipedia.org/wiki/Universal_generalization" target="_blank"> UNIVERSAL INTRODUCTION</a>]</i></span></li><li><span>From FOR ALL <i>X</i>: <i>Q</i>(<i>X</i>, <i>y</i>) [letting <i>y</i> be arbitrary]: deduce FOR ALL <i>Y</i>: (FOR ALL <i>X</i>: <i>Q</i>(<i>X</i>, <i>Y</i>)). <i>[<a href="https://en.wikipedia.org/wiki/Universal_generalization" target="_blank"> UNIVERSAL INTRODUCTION</a>]</i></span></li><li><span>QED!</span></li>';

var Exercise185 = new Exercise("18.5", "AND COMMUTES WITH FOR ALL", [formulaContext(PX), formulaContext(QX)], IFF( forAll( AND(PX,QX), X ), AND(forAll(PX,X), forAll(QX,X))), 16);
Exercise185.unlockedBy(Exercise181);
Exercise185.notes = 'Thanks to Elliot Parlin, Keith Winstein, and Andrew Lei for a (relatively) short proof (which has since been shortened further using some additional helper exercises.';
Exercise185.proof = '<li><span>Deduce FOR ALL <i>X</i>: (<i>P</i>(<i>X</i>) AND <i>Q</i>(<i>X</i>)) [assuming FOR ALL <i>X</i>: (<i>P</i>(<i>X</i>) AND <i>Q</i>(<i>X</i>))]. <i>[IMPLICATION INTRODUCTION]</i></span></li><li><span>From FOR ALL <i>X</i>: (<i>P</i>(<i>X</i>) AND <i>Q</i>(<i>X</i>)) [assuming FOR ALL <i>X</i>: (<i>P</i>(<i>X</i>) AND <i>Q</i>(<i>X</i>))]: deduce <i>P</i>(<i>x</i>) AND <i>Q</i>(<i>x</i>) [assuming FOR ALL <i>X</i>: (<i>P</i>(<i>X</i>) AND <i>Q</i>(<i>X</i>)), letting <i>x</i> be arbitrary]. <i>[REVERSE <a href="https://en.wikipedia.org/wiki/Universal_generalization" target="_blank"> UNIVERSAL INTRODUCTION</a>]</i></span></li><li><span>From <i>P</i>(<i>x</i>) AND <i>Q</i>(<i>x</i>) [assuming FOR ALL <i>X</i>: (<i>P</i>(<i>X</i>) AND <i>Q</i>(<i>X</i>)), letting <i>x</i> be arbitrary]: deduce <i>P</i>(<i>x</i>) [assuming FOR ALL <i>X</i>: (<i>P</i>(<i>X</i>) AND <i>Q</i>(<i>X</i>)), letting <i>x</i> be arbitrary]. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_elimination" target="_blank">CONJUNCTION ELIMINATION</a> (left)]</i></span></li><li><span>From <i>P</i>(<i>x</i>) AND <i>Q</i>(<i>x</i>) [assuming FOR ALL <i>X</i>: (<i>P</i>(<i>X</i>) AND <i>Q</i>(<i>X</i>)), letting <i>x</i> be arbitrary]: deduce <i>Q</i>(<i>x</i>) [assuming FOR ALL <i>X</i>: (<i>P</i>(<i>X</i>) AND <i>Q</i>(<i>X</i>)), letting <i>x</i> be arbitrary]. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_elimination" target="_blank">CONJUNCTION ELIMINATION</a> (right)]</i></span></li><li><span>From <i>P</i>(<i>x</i>) [assuming FOR ALL <i>X</i>: (<i>P</i>(<i>X</i>) AND <i>Q</i>(<i>X</i>)), letting <i>x</i> be arbitrary]: deduce FOR ALL <i>X</i>: <i>P</i>(<i>X</i>) [assuming FOR ALL <i>X</i>: (<i>P</i>(<i>X</i>) AND <i>Q</i>(<i>X</i>))]. <i>[<a href="https://en.wikipedia.org/wiki/Universal_generalization" target="_blank"> UNIVERSAL INTRODUCTION</a>]</i></span></li><li><span>From <i>Q</i>(<i>x</i>) [assuming FOR ALL <i>X</i>: (<i>P</i>(<i>X</i>) AND <i>Q</i>(<i>X</i>)), letting <i>x</i> be arbitrary]: deduce FOR ALL <i>X</i>: <i>Q</i>(<i>X</i>) [assuming FOR ALL <i>X</i>: (<i>P</i>(<i>X</i>) AND <i>Q</i>(<i>X</i>))]. <i>[<a href="https://en.wikipedia.org/wiki/Universal_generalization" target="_blank"> UNIVERSAL INTRODUCTION</a>]</i></span></li><li><span>From FOR ALL <i>X</i>: <i>P</i>(<i>X</i>) [assuming FOR ALL <i>X</i>: (<i>P</i>(<i>X</i>) AND <i>Q</i>(<i>X</i>))], FOR ALL <i>X</i>: <i>Q</i>(<i>X</i>) [assuming FOR ALL <i>X</i>: (<i>P</i>(<i>X</i>) AND <i>Q</i>(<i>X</i>))]: deduce (FOR ALL <i>X</i>: <i>P</i>(<i>X</i>)) AND (FOR ALL <i>X</i>: <i>Q</i>(<i>X</i>)) [assuming FOR ALL <i>X</i>: (<i>P</i>(<i>X</i>) AND <i>Q</i>(<i>X</i>))]. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_introduction" target="_blank">CONJUNCTION INTRODUCTION</a>]</i></span></li><li><span>Deduce (FOR ALL <i>X</i>: <i>P</i>(<i>X</i>)) AND (FOR ALL <i>X</i>: <i>Q</i>(<i>X</i>)) [assuming (FOR ALL <i>X</i>: <i>P</i>(<i>X</i>)) AND (FOR ALL <i>X</i>: <i>Q</i>(<i>X</i>))]. <i>[IMPLICATION INTRODUCTION]</i></span></li><li><span>From (FOR ALL <i>X</i>: <i>P</i>(<i>X</i>)) AND (FOR ALL <i>X</i>: <i>Q</i>(<i>X</i>)) [assuming (FOR ALL <i>X</i>: <i>P</i>(<i>X</i>)) AND (FOR ALL <i>X</i>: <i>Q</i>(<i>X</i>))]: deduce FOR ALL <i>X</i>: <i>P</i>(<i>X</i>) [assuming (FOR ALL <i>X</i>: <i>P</i>(<i>X</i>)) AND (FOR ALL <i>X</i>: <i>Q</i>(<i>X</i>))]. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_elimination" target="_blank">CONJUNCTION ELIMINATION</a> (left)]</i></span></li><li><span>From (FOR ALL <i>X</i>: <i>P</i>(<i>X</i>)) AND (FOR ALL <i>X</i>: <i>Q</i>(<i>X</i>)) [assuming (FOR ALL <i>X</i>: <i>P</i>(<i>X</i>)) AND (FOR ALL <i>X</i>: <i>Q</i>(<i>X</i>))]: deduce FOR ALL <i>X</i>: <i>Q</i>(<i>X</i>) [assuming (FOR ALL <i>X</i>: <i>P</i>(<i>X</i>)) AND (FOR ALL <i>X</i>: <i>Q</i>(<i>X</i>))]. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_elimination" target="_blank">CONJUNCTION ELIMINATION</a> (right)]</i></span></li><li><span>From FOR ALL <i>X</i>: <i>P</i>(<i>X</i>) [assuming (FOR ALL <i>X</i>: <i>P</i>(<i>X</i>)) AND (FOR ALL <i>X</i>: <i>Q</i>(<i>X</i>))]: deduce <i>P</i>(<i>x</i>) [assuming (FOR ALL <i>X</i>: <i>P</i>(<i>X</i>)) AND (FOR ALL <i>X</i>: <i>Q</i>(<i>X</i>)), letting <i>x</i> be arbitrary]. <i>[REVERSE <a href="https://en.wikipedia.org/wiki/Universal_generalization" target="_blank"> UNIVERSAL INTRODUCTION</a>]</i></span></li><li><span>From FOR ALL <i>X</i>: <i>Q</i>(<i>X</i>) [assuming (FOR ALL <i>X</i>: <i>P</i>(<i>X</i>)) AND (FOR ALL <i>X</i>: <i>Q</i>(<i>X</i>))]: deduce <i>Q</i>(<i>x</i>) [assuming (FOR ALL <i>X</i>: <i>P</i>(<i>X</i>)) AND (FOR ALL <i>X</i>: <i>Q</i>(<i>X</i>)), letting <i>x</i> be arbitrary]. <i>[REVERSE <a href="https://en.wikipedia.org/wiki/Universal_generalization" target="_blank"> UNIVERSAL INTRODUCTION</a>]</i></span></li><li><span>From <i>P</i>(<i>x</i>) [assuming (FOR ALL <i>X</i>: <i>P</i>(<i>X</i>)) AND (FOR ALL <i>X</i>: <i>Q</i>(<i>X</i>)), letting <i>x</i> be arbitrary], <i>Q</i>(<i>x</i>) [assuming (FOR ALL <i>X</i>: <i>P</i>(<i>X</i>)) AND (FOR ALL <i>X</i>: <i>Q</i>(<i>X</i>)), letting <i>x</i> be arbitrary]: deduce <i>P</i>(<i>x</i>) AND <i>Q</i>(<i>x</i>) [assuming (FOR ALL <i>X</i>: <i>P</i>(<i>X</i>)) AND (FOR ALL <i>X</i>: <i>Q</i>(<i>X</i>)), letting <i>x</i> be arbitrary]. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_introduction" target="_blank">CONJUNCTION INTRODUCTION</a>]</i></span></li><li><span>From <i>P</i>(<i>x</i>) AND <i>Q</i>(<i>x</i>) [assuming (FOR ALL <i>X</i>: <i>P</i>(<i>X</i>)) AND (FOR ALL <i>X</i>: <i>Q</i>(<i>X</i>)), letting <i>x</i> be arbitrary]: deduce FOR ALL <i>X</i>: (<i>P</i>(<i>X</i>) AND <i>Q</i>(<i>X</i>)) [assuming (FOR ALL <i>X</i>: <i>P</i>(<i>X</i>)) AND (FOR ALL <i>X</i>: <i>Q</i>(<i>X</i>))]. <i>[<a href="https://en.wikipedia.org/wiki/Universal_generalization" target="_blank"> UNIVERSAL INTRODUCTION</a>]</i></span></li><li><span>From FOR ALL <i>X</i>: (<i>P</i>(<i>X</i>) AND <i>Q</i>(<i>X</i>)) [assuming (FOR ALL <i>X</i>: <i>P</i>(<i>X</i>)) AND (FOR ALL <i>X</i>: <i>Q</i>(<i>X</i>))], (FOR ALL <i>X</i>: <i>P</i>(<i>X</i>)) AND (FOR ALL <i>X</i>: <i>Q</i>(<i>X</i>)) [assuming FOR ALL <i>X</i>: (<i>P</i>(<i>X</i>) AND <i>Q</i>(<i>X</i>))]: deduce (FOR ALL <i>X</i>: (<i>P</i>(<i>X</i>) AND <i>Q</i>(<i>X</i>))) IFF ((FOR ALL <i>X</i>: <i>P</i>(<i>X</i>)) AND (FOR ALL <i>X</i>: <i>Q</i>(<i>X</i>))). <i>[BICONDITIONAL INTRODUCTION (ASSUMPTION FORM)]</i></span></li><li><span>QED! (again)</span></li>';

var Exercise186 = new Exercise("18.6", "IMPLIES COMMUTES WITH FOR ALL", [formulaContext(A), formulaContext(PX)], IFF( IMPLIES(A, forAll( PX, X )), forAll(IMPLIES(A,PX),X)), 17);
Exercise186.unlockedBy(Exercise181);
Exercise186.notes = 'Thanks to Gesse Roure for a short proof.';
Exercise186.proof = '<li><span>Deduce <em>A</em> IMPLIES (FOR ALL <i>X</i>: <i>P</i>(<i>X</i>)) [assuming <em>A</em> IMPLIES (FOR ALL <i>X</i>: <i>P</i>(<i>X</i>))]. <i>[IMPLICATION INTRODUCTION]</i></span></li><li><span>Form environment [assuming <em>A</em> IMPLIES (FOR ALL <i>X</i>: <i>P</i>(<i>X</i>)), letting <i>x</i> be arbitrary]. <i>[FREE VARIABLE INTRODUCTION]</i></span></li><li><span>From <em>A</em> IMPLIES (FOR ALL <i>X</i>: <i>P</i>(<i>X</i>)) [assuming <em>A</em> IMPLIES (FOR ALL <i>X</i>: <i>P</i>(<i>X</i>))]: deduce <em>A</em> IMPLIES (FOR ALL <i>X</i>: <i>P</i>(<i>X</i>)) [assuming <em>A</em> IMPLIES (FOR ALL <i>X</i>: <i>P</i>(<i>X</i>)), letting <i>x</i> be arbitrary]. <i>[PUSH (for free variables)]</i></span></li><li><span>From <em>A</em> IMPLIES (FOR ALL <i>X</i>: <i>P</i>(<i>X</i>)) [assuming <em>A</em> IMPLIES (FOR ALL <i>X</i>: <i>P</i>(<i>X</i>)), letting <i>x</i> be arbitrary]: deduce FOR ALL <i>X</i>: <i>P</i>(<i>X</i>) [assuming <em>A</em> IMPLIES (FOR ALL <i>X</i>: <i>P</i>(<i>X</i>)), letting <i>x</i> be arbitrary, assuming <em>A</em>]. <i>[REVERSE <a href="https://en.wikipedia.org/wiki/Deduction_theorem" target="_blank">DEDUCTION THEOREM</a>]</i></span></li><li><span>From FOR ALL <i>X</i>: <i>P</i>(<i>X</i>) [assuming <em>A</em> IMPLIES (FOR ALL <i>X</i>: <i>P</i>(<i>X</i>)), letting <i>x</i> be arbitrary, assuming <em>A</em>]: deduce <i>P</i>(<i>x</i>) [assuming <em>A</em> IMPLIES (FOR ALL <i>X</i>: <i>P</i>(<i>X</i>)), letting <i>x</i> be arbitrary, assuming <em>A</em>]. <i>[<a href="https://en.wikipedia.org/wiki/Universal_instantiation" target="_blank">UNIVERSAL SPECIFICATION</a>]</i></span></li><li><span>From <i>P</i>(<i>x</i>) [assuming <em>A</em> IMPLIES (FOR ALL <i>X</i>: <i>P</i>(<i>X</i>)), letting <i>x</i> be arbitrary, assuming <em>A</em>]: deduce <em>A</em> IMPLIES <i>P</i>(<i>x</i>) [assuming <em>A</em> IMPLIES (FOR ALL <i>X</i>: <i>P</i>(<i>X</i>)), letting <i>x</i> be arbitrary]. <i>[<a href="https://en.wikipedia.org/wiki/Deduction_theorem" target="_blank">DEDUCTION THEOREM</a>]</i></span></li><li><span>From <em>A</em> IMPLIES <i>P</i>(<i>x</i>) [assuming <em>A</em> IMPLIES (FOR ALL <i>X</i>: <i>P</i>(<i>X</i>)), letting <i>x</i> be arbitrary]: deduce FOR ALL <i>X</i>: (<em>A</em> IMPLIES <i>P</i>(<i>X</i>)) [assuming <em>A</em> IMPLIES (FOR ALL <i>X</i>: <i>P</i>(<i>X</i>))]. <i>[<a href="https://en.wikipedia.org/wiki/Universal_generalization" target="_blank"> UNIVERSAL INTRODUCTION</a>]</i></span></li><li><span>Deduce FOR ALL <i>X</i>: (<em>A</em> IMPLIES <i>P</i>(<i>X</i>)) [assuming FOR ALL <i>X</i>: (<em>A</em> IMPLIES <i>P</i>(<i>X</i>))]. <i>[IMPLICATION INTRODUCTION]</i></span></li><li><span>Deduce <em>A</em> [assuming FOR ALL <i>X</i>: (<em>A</em> IMPLIES <i>P</i>(<i>X</i>)), <em>A</em>]. <i>[IMPLICATION INTRODUCTION]</i></span></li><li><span>From FOR ALL <i>X</i>: (<em>A</em> IMPLIES <i>P</i>(<i>X</i>)) [assuming FOR ALL <i>X</i>: (<em>A</em> IMPLIES <i>P</i>(<i>X</i>))]: deduce FOR ALL <i>X</i>: (<em>A</em> IMPLIES <i>P</i>(<i>X</i>)) [assuming FOR ALL <i>X</i>: (<em>A</em> IMPLIES <i>P</i>(<i>X</i>)), <em>A</em>]. <i>[PUSH]</i></span></li><li><span>From FOR ALL <i>X</i>: (<em>A</em> IMPLIES <i>P</i>(<i>X</i>)) [assuming FOR ALL <i>X</i>: (<em>A</em> IMPLIES <i>P</i>(<i>X</i>)), <em>A</em>]: deduce <em>A</em> IMPLIES <i>P</i>(<i>x</i>) [assuming FOR ALL <i>X</i>: (<em>A</em> IMPLIES <i>P</i>(<i>X</i>)), <em>A</em>, letting <i>x</i> be arbitrary]. <i>[REVERSE <a href="https://en.wikipedia.org/wiki/Universal_generalization" target="_blank"> UNIVERSAL INTRODUCTION</a>]</i></span></li><li><span>From <em>A</em> [assuming FOR ALL <i>X</i>: (<em>A</em> IMPLIES <i>P</i>(<i>X</i>)), <em>A</em>]: deduce <em>A</em> [assuming FOR ALL <i>X</i>: (<em>A</em> IMPLIES <i>P</i>(<i>X</i>)), <em>A</em>, letting <i>x</i> be arbitrary]. <i>[PUSH (for free variables)]</i></span></li><li><span>From <em>A</em> [assuming FOR ALL <i>X</i>: (<em>A</em> IMPLIES <i>P</i>(<i>X</i>)), <em>A</em>, letting <i>x</i> be arbitrary], <em>A</em> IMPLIES <i>P</i>(<i>x</i>) [assuming FOR ALL <i>X</i>: (<em>A</em> IMPLIES <i>P</i>(<i>X</i>)), <em>A</em>, letting <i>x</i> be arbitrary]: deduce <i>P</i>(<i>x</i>) [assuming FOR ALL <i>X</i>: (<em>A</em> IMPLIES <i>P</i>(<i>X</i>)), <em>A</em>, letting <i>x</i> be arbitrary]. <i>[<a href="https://en.wikipedia.org/wiki/Modus_ponens" target="_blank">MODUS PONENS</a>]</i></span></li><li><span>From <i>P</i>(<i>x</i>) [assuming FOR ALL <i>X</i>: (<em>A</em> IMPLIES <i>P</i>(<i>X</i>)), <em>A</em>, letting <i>x</i> be arbitrary]: deduce FOR ALL <i>X</i>: <i>P</i>(<i>X</i>) [assuming FOR ALL <i>X</i>: (<em>A</em> IMPLIES <i>P</i>(<i>X</i>)), <em>A</em>]. <i>[<a href="https://en.wikipedia.org/wiki/Universal_generalization" target="_blank"> UNIVERSAL INTRODUCTION</a>]</i></span></li><li><span>From FOR ALL <i>X</i>: <i>P</i>(<i>X</i>) [assuming FOR ALL <i>X</i>: (<em>A</em> IMPLIES <i>P</i>(<i>X</i>)), <em>A</em>]: deduce <em>A</em> IMPLIES (FOR ALL <i>X</i>: <i>P</i>(<i>X</i>)) [assuming FOR ALL <i>X</i>: (<em>A</em> IMPLIES <i>P</i>(<i>X</i>))]. <i>[<a href="https://en.wikipedia.org/wiki/Deduction_theorem" target="_blank">DEDUCTION THEOREM</a>]</i></span></li><li><span>From <em>A</em> IMPLIES (FOR ALL <i>X</i>: <i>P</i>(<i>X</i>)) [assuming FOR ALL <i>X</i>: (<em>A</em> IMPLIES <i>P</i>(<i>X</i>))], FOR ALL <i>X</i>: (<em>A</em> IMPLIES <i>P</i>(<i>X</i>)) [assuming <em>A</em> IMPLIES (FOR ALL <i>X</i>: <i>P</i>(<i>X</i>))]: deduce (<em>A</em> IMPLIES (FOR ALL <i>X</i>: <i>P</i>(<i>X</i>))) IFF (FOR ALL <i>X</i>: (<em>A</em> IMPLIES <i>P</i>(<i>X</i>))). <i>[BICONDITIONAL INTRODUCTION (ASSUMPTION FORM)]</i></span></li><li><span>QED!</span></li>';


newSection("19", "Existential quantification");

var thereExistsLaw = new Law("THERE EXISTS", [formulaContext(A), toTerm(X)], formulaContext(thereExists(A,X)));
var PushSet = new Law("PUSH (for set variables)", [A, settingAssumption(B,x)], assuming(A, settingAssumption(B,x)));

var Exercise191 = new Exercise("19.1", "", [thereExists(PX,X), forAll(QX,X)], assuming(AND(Px,Qx), settingAssumption(Px,x)), 7);
Exercise191.unlocks(thereExistsLaw);
Exercise191.unlocks(existentialInstantiation);
Exercise191.unlocks(existentialInstantiation2);
Exercise191.unlocks(PushSet);
Exercise191.unlockedBy(Exercise181);
Exercise191.notes = '<UL><LI>There is a twin sibling to the universal quantifier FOR ALL, namely the <A HREF="https://en.wikipedia.org/wiki/Existential_quantification" target="_blank">existential quantifier</A> THERE EXISTS.  As the name suggests, the sentence THERE EXISTS <I>X</I>: <I>P(X)</I> should be interpreted as the assertion that there exists a choice of <I>X</I> in the domain of discourse such that <I>P(X)</I> is true.</LI><LI> One can formalise this using the <A HREF="https://en.wikipedia.org/wiki/Existential_instantiation" target="_blank">law of existential instantiation</A>.  This law asserts that if THERE EXISTS <I>X</I>: <I>P(X)</I> is true, and <i>x</I> is an available free variable, then one can set <I>x</I> to a value for which <I>P(x)</I> holds. </LI> <LI>  In this text, this is depicted by a subenvironment entitled <B>Set <i>x</I> s.t. <I>P(x)</I></B>.  This is an environment similar to an environment introducing a free variable, but now the variable <I>x</I> is not free to range throughout the domain of discourse, but instead has to obey <I>P(x)</I>.</LI><LI> The PUSH law extends to these environments also, by the usual mechanism of dragging a statement into the environment where <I>x</I> is set.</LI> <LI> To use the existential instantiation law, drag a statement of the form THERE EXISTS <I>X</I>: <I>P(X)</I> to a free variable.  One can also simply click on the law, and the text will try to locate an available free variable to use.</LI> </UL>';
Exercise191.proof = '<li><span>THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>). <i>[given]</i></span></li><li><span>FOR ALL <i>X</i>: <i>Q</i>(<i>X</i>). <i>[given]</i></span></li><li><span>From THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>): deduce <i>P</i>(<i>x</i>) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Existential_instantiation" target="_blank">EXISTENTIAL INSTANTIATION</a>]</i></span></li><li><span>From FOR ALL <i>X</i>: <i>Q</i>(<i>X</i>): deduce FOR ALL <i>X</i>: <i>Q</i>(<i>X</i>) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>)]. <i>[PUSH (for set variables)]</i></span></li><li><span>From FOR ALL <i>X</i>: <i>Q</i>(<i>X</i>) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>)]: deduce <i>Q</i>(<i>x</i>) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Universal_instantiation" target="_blank">UNIVERSAL SPECIFICATION</a>]</i></span></li><li><span>From <i>P</i>(<i>x</i>) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>)], <i>Q</i>(<i>x</i>) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>)]: deduce <i>P</i>(<i>x</i>) AND <i>Q</i>(<i>x</i>) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_introduction" target="_blank">CONJUNCTION INTRODUCTION</a>]</i></span></li><li><span>QED!</span></li>';

var Exercise192 = new Exercise("19.2(a)", "DOUBLE PUSH (mixed III)", [A, environmentContext([B, settingAssumption(C,x)])], assuming(assuming(A,settingAssumption(C,x)),B), 5);
Exercise192.unlocks(thereExistsLaw);
Exercise192.unlockedBy(Exercise191);
Exercise192.proof = '<li><span><em>A</em>. <i>[given]</i></span></li><li><span>Form environment [assuming <em>B</em>, setting <i>x</i> s.t. <em>C</em>]. <i>[given]</i></span></li><li><span>From <em>A</em>: deduce <em>A</em> [assuming <em>B</em>]. <i>[PUSH]</i></span></li><li><span>From <em>A</em> [assuming <em>B</em>]: deduce <em>A</em> [assuming <em>B</em>, setting <i>x</i> s.t. <em>C</em>]. <i>[PUSH (for set variables)]</i></span></li><li><span>QED!</span></li>';

var Exercise192b = new Exercise("19.2(b)", "DOUBLE PUSH (mixed IV)", [A, environmentContext([settingAssumption(C,x), B])], assuming(assuming(A,B),settingAssumption(C,x)), 5);
Exercise192b.unlocks(thereExistsLaw);
Exercise192b.unlockedBy(Exercise191);
Exercise192b.proof = '<li><span><em>A</em>. <i>[given]</i></span></li><li><span>Form environment [setting <i>x</i> s.t. <em>C</em>, assuming <em>B</em>]. <i>[given]</i></span></li><li><span>From <em>A</em>: deduce <em>A</em> [setting <i>x</i> s.t. <em>C</em>]. <i>[PUSH (for set variables)]</i></span></li><li><span>From <em>A</em> [setting <i>x</i> s.t. <em>C</em>]: deduce <em>A</em> [setting <i>x</i> s.t. <em>C</em>, assuming <em>B</em>]. <i>[PUSH]</i></span></li><li><span>QED!</span></li>';

newSection("20", "Pull");

var Pull = new Law("PULL", [assuming(A, settingAssumption(B,x))], A);
var Pull2 = new Law("PULL", [assuming(A, settingAssumption(B,x)),rootEnvironmentContext()], A);

var Exercise201 = new Exercise("20.1", "PULL (existential form)", [thereExists(A,X)], A, 4);

Exercise201.unlocks(Pull);
Exercise201.unlocks(Pull2);
Exercise201.unlockedBy(Exercise191);
Exercise201.notes = '<UL><LI> There is a reverse to the PUSH law (for variables <I>x</I> that have been set to obey a certain property): if a statement <I>A</I> is known to hold for some set value of <I>x</I>, and the statement <I>A</I> does not involve the variable <I>x</I>, then one can pull <I>A</I> out of that environment and conclude that <I>A</I> holds unconditionally.</LI><LI> Of course, if <I>A</I> does depend on <I>x</I>, then no such pull is possible, since the statement <I>A</I> is not even well-formed once one leaves the environment where <I>x</I> is being set. <LI> There are two ways to invoke the PULL law.  Either drag a statement <I>A</I> in an environment where a variable <I>x</I> is set outside of that environment, or simply click on <I>A</I>. </UL>';
Exercise201.proof = '<li><span>THERE EXISTS <i>X</i>: <em>A</em>. <i>[given]</i></span></li><li><span>From THERE EXISTS <i>X</i>: <em>A</em>: deduce <em>A</em> [setting <i>x</i> s.t. <em>A</em>]. <i>[<a href="https://en.wikipedia.org/wiki/Existential_instantiation" target="_blank">EXISTENTIAL INSTANTIATION</a>]</i></span></li><li><span>From <em>A</em> [setting <i>x</i> s.t. <em>A</em>]: deduce <em>A</em>. <i>[PULL]</i></span></li><li><span>QED!</span></li>';

newSection("21", "Existence");

var Existence = new Law("EXISTENCE", [TRUE(), X], thereExists(TRUE(),X));
var Existence2 = new Law("EXISTENCE", [formulaContext(TRUE()), X], thereExists(TRUE(),X));

var Exercise211 = new Exercise("21.1", "PULL (for arbitrary variables)", [assuming(A, x), rootEnvironmentContext()], A, 8);
Exercise211.unlocks(Existence);
Exercise211.unlocks(Existence2);
Exercise211.unlockedBy(Exercise201);
Exercise211.notes = '<UL><LI> Recall that all variables in first-order logic are understood to range in some <A HREF="https://en.wikipedia.org/wiki/Domain_of_discourse" target="_blank">domain of discourse</A>.  However, so far we have not precluded the possibility that this domain of discourse is empty, so that there are no possible values for such variables to take!</LI> <LI>  This is of course a rather degenerate situation, in particular all existential statements of the form "THERE EXISTS <I>X</I>: <I>P(X)</I>" would automatically be false.  To exclude it, we introduce the law of existence: there exists a quantity <I>X</I> for which the statement TRUE holds.  </LI><LI> This law may seem trivial or redundant, but it actually cannot be deduced from the other laws in this text, and must be stated explicitly.  (If one deletes this law, one obtains instead the theory of <A HREF="https://en.wikipedia.org/wiki/Free_logic" target="_blank">free logic</A>, in which the domain of discourse is permitted to be empty.) </LI> <LI> The error of assuming the law of existence when the domain of discourse is not known to be non-empty is known as the <A HREF="https://en.wikipedia.org/wiki/Existential_fallacy">existential fallacy.</A><LI> To use the law of existence, drag the TRUE statement (or the formula TRUE) onto a bound variable (or vice versa). </LI> </UL>';
Exercise211.proof = '<li><span><em>A</em> [letting <i>x</i> be arbitrary]. <i>[given]</i></span></li><li><span>From <em>A</em> [letting <i>x</i> be arbitrary]: deduce FOR ALL <i>X</i>: <em>A</em>. <i>[<a href="https://en.wikipedia.org/wiki/Universal_generalization" target="_blank"> UNIVERSAL INTRODUCTION</a>]</i></span></li><li><span>Deduce THERE EXISTS <i>X</i>: TRUE. <i>[EXISTENCE]</i></span></li><li><span>From THERE EXISTS <i>X</i>: TRUE: deduce TRUE [setting <i>x</i> s.t. TRUE]. <i>[<a href="https://en.wikipedia.org/wiki/Existential_instantiation" target="_blank">EXISTENTIAL INSTANTIATION</a>]</i></span></li><li><span>From FOR ALL <i>X</i>: <em>A</em>: deduce FOR ALL <i>X</i>: <em>A</em> [setting <i>x</i> s.t. TRUE]. <i>[PUSH (for set variables)]</i></span></li><li><span>From FOR ALL <i>X</i>: <em>A</em> [setting <i>x</i> s.t. TRUE]: deduce <em>A</em> [setting <i>x</i> s.t. TRUE]. <i>[<a href="https://en.wikipedia.org/wiki/Universal_instantiation" target="_blank">UNIVERSAL SPECIFICATION</a>]</i></span></li><li><span>From <em>A</em> [setting <i>x</i> s.t. TRUE]: deduce <em>A</em>. <i>[PULL]</i></span></li><li><span>QED!</span></li>';

newSection("22", "Existential introduction");

var Exercise221 = new Exercise("22.1", "", [Qaa], thereExists(AND(QaX,QXa),X), 4);
Exercise221.unlocks(existentialIntroduction);
Exercise221.unlocks(existentialIntroduction2);
Exercise221.unlockedBy(Exercise211);
Exercise221.notes = '<ul><LI> The <A HREF="https://en.wikipedia.org/wiki/Existential_generalization">law of existential introduction</A> asserts that if one knows a statement of the form <I>P</I>(&alpha;), where &alpha; is a term that does not involve any bound variables or any free variables not present in the ambient environment, then one can deduce THERE EXISTS <I>X</I>: <I>P(X)</I>, where <I>X</I> is a bound variable not already occuring in <I>P(&alpha;)</I>.  This is the main way in which existential statements are proven.  </LI> <LI> To use this law (with <I>X</I> chosen to be the next available bound variable), drag the sentence <I>P</I>(&alpha;) onto the term &alpha; (or vice versa).</LI>  If one wants to specify the bound variable as well, drag the sentence <I>P</I>(&alpha;) onto the term &alpha; and then CTRL-click on the bound variable <I>X</I> (or one can click on <I>P</I>(&alpha;) and then CTRL-click on both &alpha; and <I>X</I>. </LI> <LI> Important note: dragging <I>P</I>(&alpha;) onto a bound variable <I>X</I> will <I>not</I> trigger this law (because this does not specify what the term <I>&alpha;</I> is that one is using to introduce the existential quantifier).<LI> Note that if the expression <I>P</I>(&alpha;) contains multiple copies of &alpha;, then there will be multiple options for <I>P(X)</I>, as one is permitted to change zero, one or more of the &alpha; into a copy of <I>X</I>.  This can lead to a rather large number of possible ways to use the law of existential introduction if the statement <I>P</I>(&alpha;) contains many copies of &alpha;!</ul>';
Exercise221.proof = '<li><span><i>Q</i>(Œ±, Œ±). <i>[given]</i></span></li><li><span>From <i>Q</i>(Œ±, Œ±): deduce <i>Q</i>(Œ±, Œ±) AND <i>Q</i>(Œ±, Œ±). <i>[AND IS <a href="https://en.wikipedia.org/wiki/Idempotence" target="_blank">IDEMPOTENT</a>]</i></span></li><li><span>From <i>Q</i>(Œ±, Œ±) AND <i>Q</i>(Œ±, Œ±): deduce THERE EXISTS <i>X</i>: (<i>Q</i>(Œ±, <i>X</i>) AND <i>Q</i>(<i>X</i>, Œ±)). <i>[<a href="https://en.wikipedia.org/wiki/Existential_generalization">EXISTENTIAL INTRODUCTION</a>]</i></span></li><li><span>QED!</span></li>';

var Exercise222 = new Exercise("22.2", "FOR ALL IMPLIES THERE EXISTS", [forAll(PX,X)], thereExists(PX,X), 5);
Exercise222.unlockedBy(Exercise221);
Exercise222.notes = '<UL><LI>This exercise will require the use of the law of existence, or a consequence of that law such as the "pull" law for arbitrary variables.</LI> <LI> Thanks to Anders Kaseorg for a short proof. </LI> </UL>';
Exercise222.proof = '<li><span>FOR ALL <i>X</i>: <i>P</i>(<i>X</i>). <i>[given]</i></span></li><li><span>From FOR ALL <i>X</i>: <i>P</i>(<i>X</i>): deduce <i>P</i>(<i>x</i>) [letting <i>x</i> be arbitrary]. <i>[REVERSE <a href="https://en.wikipedia.org/wiki/Universal_generalization" target="_blank"> UNIVERSAL INTRODUCTION</a>]</i></span></li><li><span>From <i>P</i>(<i>x</i>) [letting <i>x</i> be arbitrary]: deduce THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>) [letting <i>x</i> be arbitrary]. <i>[<a href="https://en.wikipedia.org/wiki/Existential_generalization">EXISTENTIAL INTRODUCTION</a>]</i></span></li><li><span>From THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>) [letting <i>x</i> be arbitrary]: deduce THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>). <i>[PULL (for arbitrary variables)]</i></span></li><li><span>QED! (again)</span></li>';

var Exercise223 = new Exercise("22.3(a)", "DE MORGAN'S LAW FOR QUANTIFIERS I", [formulaContext(PX), formulaContext(Px), X], IFF( NOT(thereExists(PX, X)), forAll(NOT(PX),X)), 18);
Exercise223.notes = 'The formula <I>P(x)</I> provided in the hypotheses will end up being useful during the proof.';
Exercise223.unlockedBy(Exercise221);
Exercise223.proof = '<li><span>Deduce NOT (THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>)) [assuming NOT (THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>))]. <i>[IMPLICATION INTRODUCTION]</i></span></li><li><span>Form environment [assuming NOT (THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>)), letting <i>x</i> be arbitrary]. <i>[FREE VARIABLE INTRODUCTION]</i></span></li><li><span>Deduce <i>P</i>(<i>x</i>) [assuming NOT (THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>)), letting <i>x</i> be arbitrary, assuming <i>P</i>(<i>x</i>)]. <i>[IMPLICATION INTRODUCTION]</i></span></li><li><span>From <i>P</i>(<i>x</i>) [assuming NOT (THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>)), letting <i>x</i> be arbitrary, assuming <i>P</i>(<i>x</i>)]: deduce THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>) [assuming NOT (THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>)), letting <i>x</i> be arbitrary, assuming <i>P</i>(<i>x</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Existential_generalization">EXISTENTIAL INTRODUCTION</a>]</i></span></li><li><span>From NOT (THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>)) [assuming NOT (THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>))]: deduce NOT (THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>)) [assuming NOT (THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>)), letting <i>x</i> be arbitrary, assuming <i>P</i>(<i>x</i>)]. <i>[DOUBLE PUSH (mixed version II)]</i></span></li><li><span>From THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>) [assuming NOT (THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>)), letting <i>x</i> be arbitrary, assuming <i>P</i>(<i>x</i>)], NOT (THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>)) [assuming NOT (THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>)), letting <i>x</i> be arbitrary, assuming <i>P</i>(<i>x</i>)]: deduce NOT <i>P</i>(<i>x</i>) [assuming NOT (THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>)), letting <i>x</i> be arbitrary]. <i>[<a href="https://en.wikipedia.org/wiki/Reductio_ad_absurdum" target="_blank">REDUCTIO AD ABSURDUM</a> (separated form)]</i></span></li><li><span>From NOT <i>P</i>(<i>x</i>) [assuming NOT (THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>)), letting <i>x</i> be arbitrary]: deduce FOR ALL <i>X</i>: (NOT <i>P</i>(<i>X</i>)) [assuming NOT (THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>))]. <i>[<a href="https://en.wikipedia.org/wiki/Universal_generalization" target="_blank"> UNIVERSAL INTRODUCTION</a>]</i></span></li><li><span>Deduce FOR ALL <i>X</i>: (NOT <i>P</i>(<i>X</i>)) [assuming FOR ALL <i>X</i>: (NOT <i>P</i>(<i>X</i>))]. <i>[IMPLICATION INTRODUCTION]</i></span></li><li><span>Deduce THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>) [assuming FOR ALL <i>X</i>: (NOT <i>P</i>(<i>X</i>)), THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>)]. <i>[IMPLICATION INTRODUCTION]</i></span></li><li><span>From THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>) [assuming FOR ALL <i>X</i>: (NOT <i>P</i>(<i>X</i>)), THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>)]: deduce <i>P</i>(<i>x</i>) [assuming FOR ALL <i>X</i>: (NOT <i>P</i>(<i>X</i>)), THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>), setting <i>x</i> s.t. <i>P</i>(<i>x</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Existential_instantiation" target="_blank">EXISTENTIAL INSTANTIATION</a>]</i></span></li><li><span>From FOR ALL <i>X</i>: (NOT <i>P</i>(<i>X</i>)) [assuming FOR ALL <i>X</i>: (NOT <i>P</i>(<i>X</i>))]: deduce FOR ALL <i>X</i>: (NOT <i>P</i>(<i>X</i>)) [assuming FOR ALL <i>X</i>: (NOT <i>P</i>(<i>X</i>)), THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>), setting <i>x</i> s.t. <i>P</i>(<i>x</i>)]. <i>[DOUBLE PUSH (mixed III)]</i></span></li><li><span>From FOR ALL <i>X</i>: (NOT <i>P</i>(<i>X</i>)) [assuming FOR ALL <i>X</i>: (NOT <i>P</i>(<i>X</i>)), THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>), setting <i>x</i> s.t. <i>P</i>(<i>x</i>)]: deduce NOT <i>P</i>(<i>x</i>) [assuming FOR ALL <i>X</i>: (NOT <i>P</i>(<i>X</i>)), THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>), setting <i>x</i> s.t. <i>P</i>(<i>x</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Universal_instantiation" target="_blank">UNIVERSAL SPECIFICATION</a>]</i></span></li><li><span>From <i>P</i>(<i>x</i>) [assuming FOR ALL <i>X</i>: (NOT <i>P</i>(<i>X</i>)), THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>), setting <i>x</i> s.t. <i>P</i>(<i>x</i>)], NOT <i>P</i>(<i>x</i>) [assuming FOR ALL <i>X</i>: (NOT <i>P</i>(<i>X</i>)), THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>), setting <i>x</i> s.t. <i>P</i>(<i>x</i>)]: deduce <i>P</i>(<i>x</i>) AND (NOT <i>P</i>(<i>x</i>)) [assuming FOR ALL <i>X</i>: (NOT <i>P</i>(<i>X</i>)), THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>), setting <i>x</i> s.t. <i>P</i>(<i>x</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_introduction" target="_blank">CONJUNCTION INTRODUCTION</a>]</i></span></li><li><span>From <i>P</i>(<i>x</i>) AND (NOT <i>P</i>(<i>x</i>)) [assuming FOR ALL <i>X</i>: (NOT <i>P</i>(<i>X</i>)), THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>), setting <i>x</i> s.t. <i>P</i>(<i>x</i>)]: deduce TRUE AND (NOT TRUE) [assuming FOR ALL <i>X</i>: (NOT <i>P</i>(<i>X</i>)), THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>), setting <i>x</i> s.t. <i>P</i>(<i>x</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Principle_of_explosion" target="_blank">EX FALSO QUODLIBET</a>]</i></span></li><li><span>From TRUE AND (NOT TRUE) [assuming FOR ALL <i>X</i>: (NOT <i>P</i>(<i>X</i>)), THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>), setting <i>x</i> s.t. <i>P</i>(<i>x</i>)]: deduce TRUE AND (NOT TRUE) [assuming FOR ALL <i>X</i>: (NOT <i>P</i>(<i>X</i>)), THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>)]. <i>[PULL]</i></span></li><li><span>From TRUE AND (NOT TRUE) [assuming FOR ALL <i>X</i>: (NOT <i>P</i>(<i>X</i>)), THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>)]: deduce NOT (THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>)) [assuming FOR ALL <i>X</i>: (NOT <i>P</i>(<i>X</i>))]. <i>[<a href="https://en.wikipedia.org/wiki/Reductio_ad_absurdum" target="_blank">REDUCTIO AD ABSURDUM</a>]</i></span></li><li><span>From NOT (THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>)) [assuming FOR ALL <i>X</i>: (NOT <i>P</i>(<i>X</i>))], FOR ALL <i>X</i>: (NOT <i>P</i>(<i>X</i>)) [assuming NOT (THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>))]: deduce (NOT (THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>))) IFF (FOR ALL <i>X</i>: (NOT <i>P</i>(<i>X</i>))). <i>[BICONDITIONAL INTRODUCTION (ASSUMPTION FORM)]</i></span></li><li><span>QED! (again)</span></li>';

var Exercise223b = new Exercise("22.3(b)", "DE MORGAN'S LAW FOR QUANTIFIERS II", [formulaContext(PX), formulaContext(Px), X], IFF( NOT(forAll(PX, X)), thereExists(NOT(PX),X)), 21);
Exercise223b.unlockedBy(Exercise221);
Exercise223b.notes = 'This one is rather tough; you may have to think in terms of double negatives.';
Exercise223b.proof = '<li><span>Deduce NOT (FOR ALL <i>X</i>: <i>P</i>(<i>X</i>)) [assuming NOT (FOR ALL <i>X</i>: <i>P</i>(<i>X</i>))]. <i>[IMPLICATION INTRODUCTION]</i></span></li><li><span>Deduce NOT (THERE EXISTS <i>X</i>: (NOT <i>P</i>(<i>X</i>))) [assuming NOT (FOR ALL <i>X</i>: <i>P</i>(<i>X</i>)), NOT (THERE EXISTS <i>X</i>: (NOT <i>P</i>(<i>X</i>)))]. <i>[IMPLICATION INTRODUCTION]</i></span></li><li><span>Form environment [assuming NOT (FOR ALL <i>X</i>: <i>P</i>(<i>X</i>)), NOT (THERE EXISTS <i>X</i>: (NOT <i>P</i>(<i>X</i>))), letting <i>x</i> be arbitrary]. <i>[FREE VARIABLE INTRODUCTION]</i></span></li><li><span>Deduce NOT <i>P</i>(<i>x</i>) [assuming NOT (FOR ALL <i>X</i>: <i>P</i>(<i>X</i>)), NOT (THERE EXISTS <i>X</i>: (NOT <i>P</i>(<i>X</i>))), letting <i>x</i> be arbitrary, assuming NOT <i>P</i>(<i>x</i>)]. <i>[IMPLICATION INTRODUCTION]</i></span></li><li><span>From NOT <i>P</i>(<i>x</i>) [assuming NOT (FOR ALL <i>X</i>: <i>P</i>(<i>X</i>)), NOT (THERE EXISTS <i>X</i>: (NOT <i>P</i>(<i>X</i>))), letting <i>x</i> be arbitrary, assuming NOT <i>P</i>(<i>x</i>)]: deduce THERE EXISTS <i>X</i>: (NOT <i>P</i>(<i>X</i>)) [assuming NOT (FOR ALL <i>X</i>: <i>P</i>(<i>X</i>)), NOT (THERE EXISTS <i>X</i>: (NOT <i>P</i>(<i>X</i>))), letting <i>x</i> be arbitrary, assuming NOT <i>P</i>(<i>x</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Existential_generalization">EXISTENTIAL INTRODUCTION</a>]</i></span></li><li><span>From NOT (THERE EXISTS <i>X</i>: (NOT <i>P</i>(<i>X</i>))) [assuming NOT (FOR ALL <i>X</i>: <i>P</i>(<i>X</i>)), NOT (THERE EXISTS <i>X</i>: (NOT <i>P</i>(<i>X</i>)))]: deduce NOT (THERE EXISTS <i>X</i>: (NOT <i>P</i>(<i>X</i>))) [assuming NOT (FOR ALL <i>X</i>: <i>P</i>(<i>X</i>)), NOT (THERE EXISTS <i>X</i>: (NOT <i>P</i>(<i>X</i>))), letting <i>x</i> be arbitrary, assuming NOT <i>P</i>(<i>x</i>)]. <i>[DOUBLE PUSH (mixed version II)]</i></span></li><li><span>From THERE EXISTS <i>X</i>: (NOT <i>P</i>(<i>X</i>)) [assuming NOT (FOR ALL <i>X</i>: <i>P</i>(<i>X</i>)), NOT (THERE EXISTS <i>X</i>: (NOT <i>P</i>(<i>X</i>))), letting <i>x</i> be arbitrary, assuming NOT <i>P</i>(<i>x</i>)], NOT (THERE EXISTS <i>X</i>: (NOT <i>P</i>(<i>X</i>))) [assuming NOT (FOR ALL <i>X</i>: <i>P</i>(<i>X</i>)), NOT (THERE EXISTS <i>X</i>: (NOT <i>P</i>(<i>X</i>))), letting <i>x</i> be arbitrary, assuming NOT <i>P</i>(<i>x</i>)]: deduce NOT (NOT <i>P</i>(<i>x</i>)) [assuming NOT (FOR ALL <i>X</i>: <i>P</i>(<i>X</i>)), NOT (THERE EXISTS <i>X</i>: (NOT <i>P</i>(<i>X</i>))), letting <i>x</i> be arbitrary]. <i>[<a href="https://en.wikipedia.org/wiki/Reductio_ad_absurdum" target="_blank">REDUCTIO AD ABSURDUM</a> (separated form)]</i></span></li><li><span>From NOT (NOT <i>P</i>(<i>x</i>)) [assuming NOT (FOR ALL <i>X</i>: <i>P</i>(<i>X</i>)), NOT (THERE EXISTS <i>X</i>: (NOT <i>P</i>(<i>X</i>))), letting <i>x</i> be arbitrary]: deduce <i>P</i>(<i>x</i>) [assuming NOT (FOR ALL <i>X</i>: <i>P</i>(<i>X</i>)), NOT (THERE EXISTS <i>X</i>: (NOT <i>P</i>(<i>X</i>))), letting <i>x</i> be arbitrary]. <i>[DOUBLE NEGATION (right)]</i></span></li><li><span>From <i>P</i>(<i>x</i>) [assuming NOT (FOR ALL <i>X</i>: <i>P</i>(<i>X</i>)), NOT (THERE EXISTS <i>X</i>: (NOT <i>P</i>(<i>X</i>))), letting <i>x</i> be arbitrary]: deduce FOR ALL <i>X</i>: <i>P</i>(<i>X</i>) [assuming NOT (FOR ALL <i>X</i>: <i>P</i>(<i>X</i>)), NOT (THERE EXISTS <i>X</i>: (NOT <i>P</i>(<i>X</i>)))]. <i>[<a href="https://en.wikipedia.org/wiki/Universal_generalization" target="_blank"> UNIVERSAL INTRODUCTION</a>]</i></span></li><li><span>From NOT (FOR ALL <i>X</i>: <i>P</i>(<i>X</i>)) [assuming NOT (FOR ALL <i>X</i>: <i>P</i>(<i>X</i>))]: deduce NOT (FOR ALL <i>X</i>: <i>P</i>(<i>X</i>)) [assuming NOT (FOR ALL <i>X</i>: <i>P</i>(<i>X</i>)), NOT (THERE EXISTS <i>X</i>: (NOT <i>P</i>(<i>X</i>)))]. <i>[PUSH]</i></span></li><li><span>From FOR ALL <i>X</i>: <i>P</i>(<i>X</i>) [assuming NOT (FOR ALL <i>X</i>: <i>P</i>(<i>X</i>)), NOT (THERE EXISTS <i>X</i>: (NOT <i>P</i>(<i>X</i>)))], NOT (FOR ALL <i>X</i>: <i>P</i>(<i>X</i>)) [assuming NOT (FOR ALL <i>X</i>: <i>P</i>(<i>X</i>)), NOT (THERE EXISTS <i>X</i>: (NOT <i>P</i>(<i>X</i>)))]: deduce NOT (NOT (THERE EXISTS <i>X</i>: (NOT <i>P</i>(<i>X</i>)))) [assuming NOT (FOR ALL <i>X</i>: <i>P</i>(<i>X</i>))]. <i>[<a href="https://en.wikipedia.org/wiki/Reductio_ad_absurdum" target="_blank">REDUCTIO AD ABSURDUM</a> (separated form)]</i></span></li><li><span>From NOT (NOT (THERE EXISTS <i>X</i>: (NOT <i>P</i>(<i>X</i>)))) [assuming NOT (FOR ALL <i>X</i>: <i>P</i>(<i>X</i>))]: deduce THERE EXISTS <i>X</i>: (NOT <i>P</i>(<i>X</i>)) [assuming NOT (FOR ALL <i>X</i>: <i>P</i>(<i>X</i>))]. <i>[DOUBLE NEGATION (right)]</i></span></li><li><span>Deduce THERE EXISTS <i>X</i>: (NOT <i>P</i>(<i>X</i>)) [assuming THERE EXISTS <i>X</i>: (NOT <i>P</i>(<i>X</i>))]. <i>[IMPLICATION INTRODUCTION]</i></span></li><li><span>From THERE EXISTS <i>X</i>: (NOT <i>P</i>(<i>X</i>)) [assuming THERE EXISTS <i>X</i>: (NOT <i>P</i>(<i>X</i>))]: deduce NOT <i>P</i>(<i>x</i>) [assuming THERE EXISTS <i>X</i>: (NOT <i>P</i>(<i>X</i>)), setting <i>x</i> s.t. NOT <i>P</i>(<i>x</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Existential_instantiation" target="_blank">EXISTENTIAL INSTANTIATION</a>]</i></span></li><li><span>Deduce FOR ALL <i>X</i>: <i>P</i>(<i>X</i>) [assuming THERE EXISTS <i>X</i>: (NOT <i>P</i>(<i>X</i>)), setting <i>x</i> s.t. NOT <i>P</i>(<i>x</i>), assuming FOR ALL <i>X</i>: <i>P</i>(<i>X</i>)]. <i>[IMPLICATION INTRODUCTION]</i></span></li><li><span>From FOR ALL <i>X</i>: <i>P</i>(<i>X</i>) [assuming THERE EXISTS <i>X</i>: (NOT <i>P</i>(<i>X</i>)), setting <i>x</i> s.t. NOT <i>P</i>(<i>x</i>), assuming FOR ALL <i>X</i>: <i>P</i>(<i>X</i>)]: deduce <i>P</i>(<i>x</i>) [assuming THERE EXISTS <i>X</i>: (NOT <i>P</i>(<i>X</i>)), setting <i>x</i> s.t. NOT <i>P</i>(<i>x</i>), assuming FOR ALL <i>X</i>: <i>P</i>(<i>X</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Universal_instantiation" target="_blank">UNIVERSAL SPECIFICATION</a>]</i></span></li><li><span>From NOT <i>P</i>(<i>x</i>) [assuming THERE EXISTS <i>X</i>: (NOT <i>P</i>(<i>X</i>)), setting <i>x</i> s.t. NOT <i>P</i>(<i>x</i>)]: deduce NOT <i>P</i>(<i>x</i>) [assuming THERE EXISTS <i>X</i>: (NOT <i>P</i>(<i>X</i>)), setting <i>x</i> s.t. NOT <i>P</i>(<i>x</i>), assuming FOR ALL <i>X</i>: <i>P</i>(<i>X</i>)]. <i>[PUSH]</i></span></li><li><span>From <i>P</i>(<i>x</i>) [assuming THERE EXISTS <i>X</i>: (NOT <i>P</i>(<i>X</i>)), setting <i>x</i> s.t. NOT <i>P</i>(<i>x</i>), assuming FOR ALL <i>X</i>: <i>P</i>(<i>X</i>)], NOT <i>P</i>(<i>x</i>) [assuming THERE EXISTS <i>X</i>: (NOT <i>P</i>(<i>X</i>)), setting <i>x</i> s.t. NOT <i>P</i>(<i>x</i>), assuming FOR ALL <i>X</i>: <i>P</i>(<i>X</i>)]: deduce NOT (FOR ALL <i>X</i>: <i>P</i>(<i>X</i>)) [assuming THERE EXISTS <i>X</i>: (NOT <i>P</i>(<i>X</i>)), setting <i>x</i> s.t. NOT <i>P</i>(<i>x</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Reductio_ad_absurdum" target="_blank">REDUCTIO AD ABSURDUM</a> (separated form)]</i></span></li><li><span>From NOT (FOR ALL <i>X</i>: <i>P</i>(<i>X</i>)) [assuming THERE EXISTS <i>X</i>: (NOT <i>P</i>(<i>X</i>)), setting <i>x</i> s.t. NOT <i>P</i>(<i>x</i>)]: deduce NOT (FOR ALL <i>X</i>: <i>P</i>(<i>X</i>)) [assuming THERE EXISTS <i>X</i>: (NOT <i>P</i>(<i>X</i>))]. <i>[PULL]</i></span></li><li><span>From NOT (FOR ALL <i>X</i>: <i>P</i>(<i>X</i>)) [assuming THERE EXISTS <i>X</i>: (NOT <i>P</i>(<i>X</i>))], THERE EXISTS <i>X</i>: (NOT <i>P</i>(<i>X</i>)) [assuming NOT (FOR ALL <i>X</i>: <i>P</i>(<i>X</i>))]: deduce (NOT (FOR ALL <i>X</i>: <i>P</i>(<i>X</i>))) IFF (THERE EXISTS <i>X</i>: (NOT <i>P</i>(<i>X</i>))). <i>[BICONDITIONAL INTRODUCTION (ASSUMPTION FORM)]</i></span></li><li><span>QED!</span></li>';

var Exercise224 = new Exercise("22.4(a)", "CELARENT SYLLOGISM", [NOT(thereExists(AND(PX,QX),X)), forAll(IMPLIES(RX,PX),X), formulaContext(Px), formulaContext(Qx), formulaContext(Rx)], NOT(thereExists(AND(RX,QX),X)), 13);
Exercise224.notes = '<UL><LI>An example of the <A HREF="https://en.wikipedia.org/wiki/Syllogism#Types" target="_blank">Celarent syllogism</A> is "No reptiles have fur.  All snakes are reptiles.  Hence, no snakes have fur."</LI><LI> Thanks to Anders Kaseorg for a short proof.</LI></UL>';
Exercise224.unlockedBy(Exercise221);
Exercise224.proof = '<li><span>NOT (THERE EXISTS <i>X</i>: (<i>P</i>(<i>X</i>) AND <i>Q</i>(<i>X</i>))). <i>[given]</i></span></li><li><span>FOR ALL <i>X</i>: (<i>R</i>(<i>X</i>) IMPLIES <i>P</i>(<i>X</i>)). <i>[given]</i></span></li><li><span>Deduce THERE EXISTS <i>X</i>: (<i>R</i>(<i>X</i>) AND <i>Q</i>(<i>X</i>)) [assuming THERE EXISTS <i>X</i>: (<i>R</i>(<i>X</i>) AND <i>Q</i>(<i>X</i>))]. <i>[IMPLICATION INTRODUCTION]</i></span></li><li><span>From THERE EXISTS <i>X</i>: (<i>R</i>(<i>X</i>) AND <i>Q</i>(<i>X</i>)) [assuming THERE EXISTS <i>X</i>: (<i>R</i>(<i>X</i>) AND <i>Q</i>(<i>X</i>))]: deduce <i>R</i>(<i>x</i>) AND <i>Q</i>(<i>x</i>) [assuming THERE EXISTS <i>X</i>: (<i>R</i>(<i>X</i>) AND <i>Q</i>(<i>X</i>)), setting <i>x</i> s.t. <i>R</i>(<i>x</i>) AND <i>Q</i>(<i>x</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Existential_instantiation" target="_blank">EXISTENTIAL INSTANTIATION</a>]</i></span></li><li><span>From FOR ALL <i>X</i>: (<i>R</i>(<i>X</i>) IMPLIES <i>P</i>(<i>X</i>)): deduce FOR ALL <i>X</i>: (<i>R</i>(<i>X</i>) IMPLIES <i>P</i>(<i>X</i>)) [assuming THERE EXISTS <i>X</i>: (<i>R</i>(<i>X</i>) AND <i>Q</i>(<i>X</i>)), setting <i>x</i> s.t. <i>R</i>(<i>x</i>) AND <i>Q</i>(<i>x</i>)]. <i>[DOUBLE PUSH (mixed III)]</i></span></li><li><span>From FOR ALL <i>X</i>: (<i>R</i>(<i>X</i>) IMPLIES <i>P</i>(<i>X</i>)) [assuming THERE EXISTS <i>X</i>: (<i>R</i>(<i>X</i>) AND <i>Q</i>(<i>X</i>)), setting <i>x</i> s.t. <i>R</i>(<i>x</i>) AND <i>Q</i>(<i>x</i>)]: deduce <i>R</i>(<i>x</i>) IMPLIES <i>P</i>(<i>x</i>) [assuming THERE EXISTS <i>X</i>: (<i>R</i>(<i>X</i>) AND <i>Q</i>(<i>X</i>)), setting <i>x</i> s.t. <i>R</i>(<i>x</i>) AND <i>Q</i>(<i>x</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Universal_instantiation" target="_blank">UNIVERSAL SPECIFICATION</a>]</i></span></li><li><span>From <i>R</i>(<i>x</i>) IMPLIES <i>P</i>(<i>x</i>) [assuming THERE EXISTS <i>X</i>: (<i>R</i>(<i>X</i>) AND <i>Q</i>(<i>X</i>)), setting <i>x</i> s.t. <i>R</i>(<i>x</i>) AND <i>Q</i>(<i>x</i>)]: deduce (<i>R</i>(<i>x</i>) AND <i>Q</i>(<i>x</i>)) IMPLIES (<i>P</i>(<i>x</i>) AND <i>Q</i>(<i>x</i>)) [assuming THERE EXISTS <i>X</i>: (<i>R</i>(<i>X</i>) AND <i>Q</i>(<i>X</i>)), setting <i>x</i> s.t. <i>R</i>(<i>x</i>) AND <i>Q</i>(<i>x</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Monotonic_function" target="_blank">MONOTONICITY</a> OF AND]</i></span></li><li><span>From <i>R</i>(<i>x</i>) AND <i>Q</i>(<i>x</i>) [assuming THERE EXISTS <i>X</i>: (<i>R</i>(<i>X</i>) AND <i>Q</i>(<i>X</i>)), setting <i>x</i> s.t. <i>R</i>(<i>x</i>) AND <i>Q</i>(<i>x</i>)], (<i>R</i>(<i>x</i>) AND <i>Q</i>(<i>x</i>)) IMPLIES (<i>P</i>(<i>x</i>) AND <i>Q</i>(<i>x</i>)) [assuming THERE EXISTS <i>X</i>: (<i>R</i>(<i>X</i>) AND <i>Q</i>(<i>X</i>)), setting <i>x</i> s.t. <i>R</i>(<i>x</i>) AND <i>Q</i>(<i>x</i>)]: deduce <i>P</i>(<i>x</i>) AND <i>Q</i>(<i>x</i>) [assuming THERE EXISTS <i>X</i>: (<i>R</i>(<i>X</i>) AND <i>Q</i>(<i>X</i>)), setting <i>x</i> s.t. <i>R</i>(<i>x</i>) AND <i>Q</i>(<i>x</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Modus_ponens" target="_blank">MODUS PONENS</a>]</i></span></li><li><span>From <i>P</i>(<i>x</i>) AND <i>Q</i>(<i>x</i>) [assuming THERE EXISTS <i>X</i>: (<i>R</i>(<i>X</i>) AND <i>Q</i>(<i>X</i>)), setting <i>x</i> s.t. <i>R</i>(<i>x</i>) AND <i>Q</i>(<i>x</i>)]: deduce THERE EXISTS <i>X</i>: (<i>P</i>(<i>X</i>) AND <i>Q</i>(<i>X</i>)) [assuming THERE EXISTS <i>X</i>: (<i>R</i>(<i>X</i>) AND <i>Q</i>(<i>X</i>)), setting <i>x</i> s.t. <i>R</i>(<i>x</i>) AND <i>Q</i>(<i>x</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Existential_generalization">EXISTENTIAL INTRODUCTION</a>]</i></span></li><li><span>From THERE EXISTS <i>X</i>: (<i>P</i>(<i>X</i>) AND <i>Q</i>(<i>X</i>)) [assuming THERE EXISTS <i>X</i>: (<i>R</i>(<i>X</i>) AND <i>Q</i>(<i>X</i>)), setting <i>x</i> s.t. <i>R</i>(<i>x</i>) AND <i>Q</i>(<i>x</i>)]: deduce THERE EXISTS <i>X</i>: (<i>P</i>(<i>X</i>) AND <i>Q</i>(<i>X</i>)) [assuming THERE EXISTS <i>X</i>: (<i>R</i>(<i>X</i>) AND <i>Q</i>(<i>X</i>))]. <i>[PULL]</i></span></li><li><span>From NOT (THERE EXISTS <i>X</i>: (<i>P</i>(<i>X</i>) AND <i>Q</i>(<i>X</i>))): deduce NOT (THERE EXISTS <i>X</i>: (<i>P</i>(<i>X</i>) AND <i>Q</i>(<i>X</i>))) [assuming THERE EXISTS <i>X</i>: (<i>R</i>(<i>X</i>) AND <i>Q</i>(<i>X</i>))]. <i>[PUSH]</i></span></li><li><span>From THERE EXISTS <i>X</i>: (<i>P</i>(<i>X</i>) AND <i>Q</i>(<i>X</i>)) [assuming THERE EXISTS <i>X</i>: (<i>R</i>(<i>X</i>) AND <i>Q</i>(<i>X</i>))], NOT (THERE EXISTS <i>X</i>: (<i>P</i>(<i>X</i>) AND <i>Q</i>(<i>X</i>))) [assuming THERE EXISTS <i>X</i>: (<i>R</i>(<i>X</i>) AND <i>Q</i>(<i>X</i>))]: deduce NOT (THERE EXISTS <i>X</i>: (<i>R</i>(<i>X</i>) AND <i>Q</i>(<i>X</i>))). <i>[<a href="https://en.wikipedia.org/wiki/Reductio_ad_absurdum" target="_blank">REDUCTIO AD ABSURDUM</a> (separated form)]</i></span></li><li><span>QED! (again)</span></li>';

var Exercise224b = new Exercise("22.4(b)", "DARII SYLLOGISM", [forAll(IMPLIES(PX,QX),X), thereExists(AND(RX,PX),X)], thereExists(AND(RX,QX),X), 12);
Exercise224b.notes = 'An example of the <A HREF="https://en.wikipedia.org/wiki/Syllogism#Types" target="_blank">Darii  syllogism</A> is "All rabbits have fur.  Some pets are rabbits.  Hence, some pets have fur.".';
Exercise224b.unlockedBy(Exercise221);
Exercise224b.proof = '<li><span>FOR ALL <i>X</i>: (<i>P</i>(<i>X</i>) IMPLIES <i>Q</i>(<i>X</i>)). <i>[given]</i></span></li><li><span>THERE EXISTS <i>X</i>: (<i>R</i>(<i>X</i>) AND <i>P</i>(<i>X</i>)). <i>[given]</i></span></li><li><span>From THERE EXISTS <i>X</i>: (<i>R</i>(<i>X</i>) AND <i>P</i>(<i>X</i>)): deduce <i>R</i>(<i>x</i>) AND <i>P</i>(<i>x</i>) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>) AND <i>P</i>(<i>x</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Existential_instantiation" target="_blank">EXISTENTIAL INSTANTIATION</a>]</i></span></li><li><span>From FOR ALL <i>X</i>: (<i>P</i>(<i>X</i>) IMPLIES <i>Q</i>(<i>X</i>)): deduce FOR ALL <i>X</i>: (<i>P</i>(<i>X</i>) IMPLIES <i>Q</i>(<i>X</i>)) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>) AND <i>P</i>(<i>x</i>)]. <i>[PUSH (for set variables)]</i></span></li><li><span>From FOR ALL <i>X</i>: (<i>P</i>(<i>X</i>) IMPLIES <i>Q</i>(<i>X</i>)) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>) AND <i>P</i>(<i>x</i>)]: deduce <i>P</i>(<i>x</i>) IMPLIES <i>Q</i>(<i>x</i>) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>) AND <i>P</i>(<i>x</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Universal_instantiation" target="_blank">UNIVERSAL SPECIFICATION</a>]</i></span></li><li><span>From <i>R</i>(<i>x</i>) AND <i>P</i>(<i>x</i>) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>) AND <i>P</i>(<i>x</i>)]: deduce <i>R</i>(<i>x</i>) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>) AND <i>P</i>(<i>x</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_elimination" target="_blank">CONJUNCTION ELIMINATION</a> (left)]</i></span></li><li><span>From <i>R</i>(<i>x</i>) AND <i>P</i>(<i>x</i>) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>) AND <i>P</i>(<i>x</i>)]: deduce <i>P</i>(<i>x</i>) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>) AND <i>P</i>(<i>x</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_elimination" target="_blank">CONJUNCTION ELIMINATION</a> (right)]</i></span></li><li><span>From <i>P</i>(<i>x</i>) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>) AND <i>P</i>(<i>x</i>)], <i>P</i>(<i>x</i>) IMPLIES <i>Q</i>(<i>x</i>) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>) AND <i>P</i>(<i>x</i>)]: deduce <i>Q</i>(<i>x</i>) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>) AND <i>P</i>(<i>x</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Modus_ponens" target="_blank">MODUS PONENS</a>]</i></span></li><li><span>From <i>R</i>(<i>x</i>) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>) AND <i>P</i>(<i>x</i>)], <i>Q</i>(<i>x</i>) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>) AND <i>P</i>(<i>x</i>)]: deduce <i>R</i>(<i>x</i>) AND <i>Q</i>(<i>x</i>) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>) AND <i>P</i>(<i>x</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_introduction" target="_blank">CONJUNCTION INTRODUCTION</a>]</i></span></li><li><span>From <i>R</i>(<i>x</i>) AND <i>Q</i>(<i>x</i>) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>) AND <i>P</i>(<i>x</i>)]: deduce THERE EXISTS <i>X</i>: (<i>R</i>(<i>X</i>) AND <i>Q</i>(<i>X</i>)) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>) AND <i>P</i>(<i>x</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Existential_generalization">EXISTENTIAL INTRODUCTION</a>]</i></span></li><li><span>From THERE EXISTS <i>X</i>: (<i>R</i>(<i>X</i>) AND <i>Q</i>(<i>X</i>)) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>) AND <i>P</i>(<i>x</i>)]: deduce THERE EXISTS <i>X</i>: (<i>R</i>(<i>X</i>) AND <i>Q</i>(<i>X</i>)). <i>[PULL]</i></span></li><li><span>QED!</span></li>';

var Exercise224c = new Exercise("22.4(c)", "FERIOQUE SYLLOGISM", [NOT(thereExists(AND(PX,QX),X)), thereExists(AND(RX,PX),X), formulaContext(Px), formulaContext(Qx), formulaContext(Rx)], thereExists(AND(RX,NOT(QX)),X), 15);
Exercise224c.notes = '<UL><LI> An example of the <A HREF="https://en.wikipedia.org/wiki/Syllogism#Types" target="_blank">Ferioque  syllogism</A> is "No homework is fun. Some reading is homework.  Hence, some reading is not fun.".</LI> <LI> Thanks to Anders Kaseorg for a short proof. </LI></UL>';
Exercise224c.unlockedBy(Exercise221);
Exercise224c.proof = '<li><span>NOT (THERE EXISTS <i>X</i>: (<i>P</i>(<i>X</i>) AND <i>Q</i>(<i>X</i>))). <i>[given]</i></span></li><li><span>THERE EXISTS <i>X</i>: (<i>R</i>(<i>X</i>) AND <i>P</i>(<i>X</i>)). <i>[given]</i></span></li><li><span>From THERE EXISTS <i>X</i>: (<i>R</i>(<i>X</i>) AND <i>P</i>(<i>X</i>)): deduce <i>R</i>(<i>x</i>) AND <i>P</i>(<i>x</i>) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>) AND <i>P</i>(<i>x</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Existential_instantiation" target="_blank">EXISTENTIAL INSTANTIATION</a>]</i></span></li><li><span>Deduce <i>Q</i>(<i>x</i>) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>) AND <i>P</i>(<i>x</i>), assuming <i>Q</i>(<i>x</i>)]. <i>[IMPLICATION INTRODUCTION]</i></span></li><li><span>From <i>R</i>(<i>x</i>) AND <i>P</i>(<i>x</i>) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>) AND <i>P</i>(<i>x</i>)]: deduce <i>P</i>(<i>x</i>) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>) AND <i>P</i>(<i>x</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_elimination" target="_blank">CONJUNCTION ELIMINATION</a> (right)]</i></span></li><li><span>From <i>P</i>(<i>x</i>) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>) AND <i>P</i>(<i>x</i>)]: deduce <i>P</i>(<i>x</i>) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>) AND <i>P</i>(<i>x</i>), assuming <i>Q</i>(<i>x</i>)]. <i>[PUSH]</i></span></li><li><span>From <i>P</i>(<i>x</i>) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>) AND <i>P</i>(<i>x</i>), assuming <i>Q</i>(<i>x</i>)], <i>Q</i>(<i>x</i>) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>) AND <i>P</i>(<i>x</i>), assuming <i>Q</i>(<i>x</i>)]: deduce <i>P</i>(<i>x</i>) AND <i>Q</i>(<i>x</i>) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>) AND <i>P</i>(<i>x</i>), assuming <i>Q</i>(<i>x</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_introduction" target="_blank">CONJUNCTION INTRODUCTION</a>]</i></span></li><li><span>From <i>P</i>(<i>x</i>) AND <i>Q</i>(<i>x</i>) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>) AND <i>P</i>(<i>x</i>), assuming <i>Q</i>(<i>x</i>)]: deduce THERE EXISTS <i>X</i>: (<i>P</i>(<i>X</i>) AND <i>Q</i>(<i>X</i>)) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>) AND <i>P</i>(<i>x</i>), assuming <i>Q</i>(<i>x</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Existential_generalization">EXISTENTIAL INTRODUCTION</a>]</i></span></li><li><span>From NOT (THERE EXISTS <i>X</i>: (<i>P</i>(<i>X</i>) AND <i>Q</i>(<i>X</i>))): deduce NOT (THERE EXISTS <i>X</i>: (<i>P</i>(<i>X</i>) AND <i>Q</i>(<i>X</i>))) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>) AND <i>P</i>(<i>x</i>), assuming <i>Q</i>(<i>x</i>)]. <i>[DOUBLE PUSH (mixed IV)]</i></span></li><li><span>From THERE EXISTS <i>X</i>: (<i>P</i>(<i>X</i>) AND <i>Q</i>(<i>X</i>)) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>) AND <i>P</i>(<i>x</i>), assuming <i>Q</i>(<i>x</i>)], NOT (THERE EXISTS <i>X</i>: (<i>P</i>(<i>X</i>) AND <i>Q</i>(<i>X</i>))) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>) AND <i>P</i>(<i>x</i>), assuming <i>Q</i>(<i>x</i>)]: deduce NOT <i>Q</i>(<i>x</i>) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>) AND <i>P</i>(<i>x</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Reductio_ad_absurdum" target="_blank">REDUCTIO AD ABSURDUM</a> (separated form)]</i></span></li><li><span>From <i>R</i>(<i>x</i>) AND <i>P</i>(<i>x</i>) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>) AND <i>P</i>(<i>x</i>)]: deduce <i>R</i>(<i>x</i>) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>) AND <i>P</i>(<i>x</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_elimination" target="_blank">CONJUNCTION ELIMINATION</a> (left)]</i></span></li><li><span>From <i>R</i>(<i>x</i>) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>) AND <i>P</i>(<i>x</i>)], NOT <i>Q</i>(<i>x</i>) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>) AND <i>P</i>(<i>x</i>)]: deduce <i>R</i>(<i>x</i>) AND (NOT <i>Q</i>(<i>x</i>)) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>) AND <i>P</i>(<i>x</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_introduction" target="_blank">CONJUNCTION INTRODUCTION</a>]</i></span></li><li><span>From <i>R</i>(<i>x</i>) AND (NOT <i>Q</i>(<i>x</i>)) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>) AND <i>P</i>(<i>x</i>)]: deduce THERE EXISTS <i>X</i>: (<i>R</i>(<i>X</i>) AND (NOT <i>Q</i>(<i>X</i>))) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>) AND <i>P</i>(<i>x</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Existential_generalization">EXISTENTIAL INTRODUCTION</a>]</i></span></li><li><span>From THERE EXISTS <i>X</i>: (<i>R</i>(<i>X</i>) AND (NOT <i>Q</i>(<i>X</i>))) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>) AND <i>P</i>(<i>x</i>)]: deduce THERE EXISTS <i>X</i>: (<i>R</i>(<i>X</i>) AND (NOT <i>Q</i>(<i>X</i>))). <i>[PULL]</i></span></li><li><span>QED!</span></li>';


var Exercise224d = new Exercise("22.4(d)", "BAROCO SYLLOGISM", [forAll(IMPLIES(PX,QX), X), thereExists(AND(RX,NOT(QX)),X)], thereExists(AND(RX,NOT(PX)),X), 12);
Exercise224d.notes = '<UL><LI> An example of the <A HREF="https://en.wikipedia.org/wiki/Syllogism#Types" target="_blank">Baroco  syllogism</A> is "All informative things are useful. Some websites are not useful.  Hence, some websites are not informative.".</LI> <LI> Thanks to Anders Kaseorg for a shorter proof.</LI> </UL>';
Exercise224d.unlockedBy(Exercise221);
Exercise224d.proof = '<li><span>FOR ALL <i>X</i>: (<i>P</i>(<i>X</i>) IMPLIES <i>Q</i>(<i>X</i>)). <i>[given]</i></span></li><li><span>THERE EXISTS <i>X</i>: (<i>R</i>(<i>X</i>) AND (NOT <i>Q</i>(<i>X</i>))). <i>[given]</i></span></li><li><span>From THERE EXISTS <i>X</i>: (<i>R</i>(<i>X</i>) AND (NOT <i>Q</i>(<i>X</i>))): deduce <i>R</i>(<i>x</i>) AND (NOT <i>Q</i>(<i>x</i>)) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>) AND (NOT <i>Q</i>(<i>x</i>))]. <i>[<a href="https://en.wikipedia.org/wiki/Existential_instantiation" target="_blank">EXISTENTIAL INSTANTIATION</a>]</i></span></li><li><span>From <i>R</i>(<i>x</i>) AND (NOT <i>Q</i>(<i>x</i>)) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>) AND (NOT <i>Q</i>(<i>x</i>))]: deduce <i>R</i>(<i>x</i>) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>) AND (NOT <i>Q</i>(<i>x</i>))]. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_elimination" target="_blank">CONJUNCTION ELIMINATION</a> (left)]</i></span></li><li><span>From <i>R</i>(<i>x</i>) AND (NOT <i>Q</i>(<i>x</i>)) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>) AND (NOT <i>Q</i>(<i>x</i>))]: deduce NOT <i>Q</i>(<i>x</i>) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>) AND (NOT <i>Q</i>(<i>x</i>))]. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_elimination" target="_blank">CONJUNCTION ELIMINATION</a> (right)]</i></span></li><li><span>From FOR ALL <i>X</i>: (<i>P</i>(<i>X</i>) IMPLIES <i>Q</i>(<i>X</i>)): deduce FOR ALL <i>X</i>: (<i>P</i>(<i>X</i>) IMPLIES <i>Q</i>(<i>X</i>)) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>) AND (NOT <i>Q</i>(<i>x</i>))]. <i>[PUSH (for set variables)]</i></span></li><li><span>From FOR ALL <i>X</i>: (<i>P</i>(<i>X</i>) IMPLIES <i>Q</i>(<i>X</i>)) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>) AND (NOT <i>Q</i>(<i>x</i>))]: deduce <i>P</i>(<i>x</i>) IMPLIES <i>Q</i>(<i>x</i>) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>) AND (NOT <i>Q</i>(<i>x</i>))]. <i>[<a href="https://en.wikipedia.org/wiki/Universal_instantiation" target="_blank">UNIVERSAL SPECIFICATION</a>]</i></span></li><li><span>From <i>P</i>(<i>x</i>) IMPLIES <i>Q</i>(<i>x</i>) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>) AND (NOT <i>Q</i>(<i>x</i>))], NOT <i>Q</i>(<i>x</i>) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>) AND (NOT <i>Q</i>(<i>x</i>))]: deduce NOT <i>P</i>(<i>x</i>) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>) AND (NOT <i>Q</i>(<i>x</i>))]. <i>[<a href="https://en.wikipedia.org/wiki/Modus_tollens" target="_blank">MODUS TOLLENS</a>]</i></span></li><li><span>From <i>R</i>(<i>x</i>) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>) AND (NOT <i>Q</i>(<i>x</i>))], NOT <i>P</i>(<i>x</i>) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>) AND (NOT <i>Q</i>(<i>x</i>))]: deduce <i>R</i>(<i>x</i>) AND (NOT <i>P</i>(<i>x</i>)) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>) AND (NOT <i>Q</i>(<i>x</i>))]. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_introduction" target="_blank">CONJUNCTION INTRODUCTION</a>]</i></span></li><li><span>From <i>R</i>(<i>x</i>) AND (NOT <i>P</i>(<i>x</i>)) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>) AND (NOT <i>Q</i>(<i>x</i>))]: deduce THERE EXISTS <i>X</i>: (<i>R</i>(<i>X</i>) AND (NOT <i>P</i>(<i>X</i>))) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>) AND (NOT <i>Q</i>(<i>x</i>))]. <i>[<a href="https://en.wikipedia.org/wiki/Existential_generalization">EXISTENTIAL INTRODUCTION</a>]</i></span></li><li><span>From THERE EXISTS <i>X</i>: (<i>R</i>(<i>X</i>) AND (NOT <i>P</i>(<i>X</i>))) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>) AND (NOT <i>Q</i>(<i>x</i>))]: deduce THERE EXISTS <i>X</i>: (<i>R</i>(<i>X</i>) AND (NOT <i>P</i>(<i>X</i>))). <i>[PULL]</i></span></li><li><span>QED!</span></li>';

var Exercise224e = new Exercise("22.4(e)", "BOCARDO SYLLOGISM", [thereExists(AND(PX, NOT(QX)), X), forAll(IMPLIES(PX,RX), X), formulaContext(Px), formulaContext(Qx), formulaContext(Rx)], thereExists(AND(RX,NOT(QX)),X), 10);
Exercise224e.notes = 'An example of the <A HREF="https://en.wikipedia.org/wiki/Syllogism#Types" target="_blank">Bocardo  syllogism</A> is "Some cats have no tails.  All cats are mammals.  Hence, some mammals have no tails.".';
Exercise224e.unlockedBy(Exercise221);
Exercise224e.proof = '<li><span>THERE EXISTS <i>X</i>: (<i>P</i>(<i>X</i>) AND (NOT <i>Q</i>(<i>X</i>))). <i>[given]</i></span></li><li><span>FOR ALL <i>X</i>: (<i>P</i>(<i>X</i>) IMPLIES <i>R</i>(<i>X</i>)). <i>[given]</i></span></li><li><span>From THERE EXISTS <i>X</i>: (<i>P</i>(<i>X</i>) AND (NOT <i>Q</i>(<i>X</i>))): deduce <i>P</i>(<i>x</i>) AND (NOT <i>Q</i>(<i>x</i>)) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>) AND (NOT <i>Q</i>(<i>x</i>))]. <i>[<a href="https://en.wikipedia.org/wiki/Existential_instantiation" target="_blank">EXISTENTIAL INSTANTIATION</a>]</i></span></li><li><span>From FOR ALL <i>X</i>: (<i>P</i>(<i>X</i>) IMPLIES <i>R</i>(<i>X</i>)): deduce FOR ALL <i>X</i>: (<i>P</i>(<i>X</i>) IMPLIES <i>R</i>(<i>X</i>)) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>) AND (NOT <i>Q</i>(<i>x</i>))]. <i>[PUSH (for set variables)]</i></span></li><li><span>From FOR ALL <i>X</i>: (<i>P</i>(<i>X</i>) IMPLIES <i>R</i>(<i>X</i>)) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>) AND (NOT <i>Q</i>(<i>x</i>))]: deduce <i>P</i>(<i>x</i>) IMPLIES <i>R</i>(<i>x</i>) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>) AND (NOT <i>Q</i>(<i>x</i>))]. <i>[<a href="https://en.wikipedia.org/wiki/Universal_instantiation" target="_blank">UNIVERSAL SPECIFICATION</a>]</i></span></li><li><span>From <i>P</i>(<i>x</i>) IMPLIES <i>R</i>(<i>x</i>) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>) AND (NOT <i>Q</i>(<i>x</i>))]: deduce (<i>P</i>(<i>x</i>) AND (NOT <i>Q</i>(<i>x</i>))) IMPLIES (<i>R</i>(<i>x</i>) AND (NOT <i>Q</i>(<i>x</i>))) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>) AND (NOT <i>Q</i>(<i>x</i>))]. <i>[<a href="https://en.wikipedia.org/wiki/Monotonic_function" target="_blank">MONOTONICITY</a> OF AND]</i></span></li><li><span>From <i>P</i>(<i>x</i>) AND (NOT <i>Q</i>(<i>x</i>)) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>) AND (NOT <i>Q</i>(<i>x</i>))], (<i>P</i>(<i>x</i>) AND (NOT <i>Q</i>(<i>x</i>))) IMPLIES (<i>R</i>(<i>x</i>) AND (NOT <i>Q</i>(<i>x</i>))) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>) AND (NOT <i>Q</i>(<i>x</i>))]: deduce <i>R</i>(<i>x</i>) AND (NOT <i>Q</i>(<i>x</i>)) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>) AND (NOT <i>Q</i>(<i>x</i>))]. <i>[<a href="https://en.wikipedia.org/wiki/Modus_ponens" target="_blank">MODUS PONENS</a>]</i></span></li><li><span>From <i>R</i>(<i>x</i>) AND (NOT <i>Q</i>(<i>x</i>)) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>) AND (NOT <i>Q</i>(<i>x</i>))]: deduce THERE EXISTS <i>X</i>: (<i>R</i>(<i>X</i>) AND (NOT <i>Q</i>(<i>X</i>))) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>) AND (NOT <i>Q</i>(<i>x</i>))]. <i>[<a href="https://en.wikipedia.org/wiki/Existential_generalization">EXISTENTIAL INTRODUCTION</a>]</i></span></li><li><span>From THERE EXISTS <i>X</i>: (<i>R</i>(<i>X</i>) AND (NOT <i>Q</i>(<i>X</i>))) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>) AND (NOT <i>Q</i>(<i>x</i>))]: deduce THERE EXISTS <i>X</i>: (<i>R</i>(<i>X</i>) AND (NOT <i>Q</i>(<i>X</i>))). <i>[PULL]</i></span></li><li><span>QED!</span></li>';

var Exercise225 = new Exercise("22.5(a)", "BARBARI SYLLOGISM", [forAll(IMPLIES(PX,QX), X), forAll(IMPLIES(QX,RX),X), thereExists(PX, X)], thereExists(AND(PX,RX),X), 14);
Exercise225.notes = '<UL><LI> In contrast to the syllogisms in Exercise 22.4, these syllogisms require a third assumption, namely the existence of some class of object. As such, they are sometimes not considered to be genuine syllogisms in the classical sense by some authors.</LI><LI> An example of the <A HREF="https://en.wikipedia.org/wiki/Syllogism#Types" target="_blank">Barbari syllogism</A> is "All men are mortal.  All Greeks are men.  Greeks exist.  Hence, some Greeks are mortal."';
Exercise225.unlockedBy(Exercise221);
Exercise225.proof = '<li><span>FOR ALL <i>X</i>: (<i>P</i>(<i>X</i>) IMPLIES <i>Q</i>(<i>X</i>)). <i>[given]</i></span></li><li><span>FOR ALL <i>X</i>: (<i>Q</i>(<i>X</i>) IMPLIES <i>R</i>(<i>X</i>)). <i>[given]</i></span></li><li><span>THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>). <i>[given]</i></span></li><li><span>From THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>): deduce <i>P</i>(<i>x</i>) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Existential_instantiation" target="_blank">EXISTENTIAL INSTANTIATION</a>]</i></span></li><li><span>From FOR ALL <i>X</i>: (<i>P</i>(<i>X</i>) IMPLIES <i>Q</i>(<i>X</i>)): deduce FOR ALL <i>X</i>: (<i>P</i>(<i>X</i>) IMPLIES <i>Q</i>(<i>X</i>)) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>)]. <i>[PUSH (for set variables)]</i></span></li><li><span>From FOR ALL <i>X</i>: (<i>Q</i>(<i>X</i>) IMPLIES <i>R</i>(<i>X</i>)): deduce FOR ALL <i>X</i>: (<i>Q</i>(<i>X</i>) IMPLIES <i>R</i>(<i>X</i>)) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>)]. <i>[PUSH (for set variables)]</i></span></li><li><span>From FOR ALL <i>X</i>: (<i>P</i>(<i>X</i>) IMPLIES <i>Q</i>(<i>X</i>)) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>)]: deduce <i>P</i>(<i>x</i>) IMPLIES <i>Q</i>(<i>x</i>) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Universal_instantiation" target="_blank">UNIVERSAL SPECIFICATION</a>]</i></span></li><li><span>From FOR ALL <i>X</i>: (<i>Q</i>(<i>X</i>) IMPLIES <i>R</i>(<i>X</i>)) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>)]: deduce <i>Q</i>(<i>x</i>) IMPLIES <i>R</i>(<i>x</i>) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Universal_instantiation" target="_blank">UNIVERSAL SPECIFICATION</a>]</i></span></li><li><span>From <i>P</i>(<i>x</i>) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>)], <i>P</i>(<i>x</i>) IMPLIES <i>Q</i>(<i>x</i>) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>)]: deduce <i>Q</i>(<i>x</i>) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Modus_ponens" target="_blank">MODUS PONENS</a>]</i></span></li><li><span>From <i>Q</i>(<i>x</i>) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>)], <i>Q</i>(<i>x</i>) IMPLIES <i>R</i>(<i>x</i>) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>)]: deduce <i>R</i>(<i>x</i>) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Modus_ponens" target="_blank">MODUS PONENS</a>]</i></span></li><li><span>From <i>P</i>(<i>x</i>) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>)], <i>R</i>(<i>x</i>) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>)]: deduce <i>P</i>(<i>x</i>) AND <i>R</i>(<i>x</i>) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_introduction" target="_blank">CONJUNCTION INTRODUCTION</a>]</i></span></li><li><span>From <i>P</i>(<i>x</i>) AND <i>R</i>(<i>x</i>) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>)]: deduce THERE EXISTS <i>X</i>: (<i>P</i>(<i>X</i>) AND <i>R</i>(<i>X</i>)) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Existential_generalization">EXISTENTIAL INTRODUCTION</a>]</i></span></li><li><span>From THERE EXISTS <i>X</i>: (<i>P</i>(<i>X</i>) AND <i>R</i>(<i>X</i>)) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>)]: deduce THERE EXISTS <i>X</i>: (<i>P</i>(<i>X</i>) AND <i>R</i>(<i>X</i>)). <i>[PULL]</i></span></li><li><span>QED!</span></li>';

var Exercise225b = new Exercise("22.5(b)", "CELARONT SYLLOGISM", [NOT(thereExists(AND(PX,QX),X)), forAll(IMPLIES(RX,PX),X), thereExists(RX, X), formulaContext(Px), formulaContext(Qx), formulaContext(Rx)], thereExists(AND(RX,NOT(QX)),X), 17);
Exercise225b.notes = 'An example of the <A HREF="https://en.wikipedia.org/wiki/Syllogism#Types" target="_blank">Celaront syllogism</A> is "No reptiles have fur.  All snakes are reptiles.  Snakes exist. Hence, some snakes have no fur."';
Exercise225b.unlockedBy(Exercise221);
Exercise225b.proof   = '<li><span>NOT (THERE EXISTS <i>X</i>: (<i>P</i>(<i>X</i>) AND <i>Q</i>(<i>X</i>))). <i>[given]</i></span></li><li><span>FOR ALL <i>X</i>: (<i>R</i>(<i>X</i>) IMPLIES <i>P</i>(<i>X</i>)). <i>[given]</i></span></li><li><span>THERE EXISTS <i>X</i>: <i>R</i>(<i>X</i>). <i>[given]</i></span></li><li><span>From THERE EXISTS <i>X</i>: <i>R</i>(<i>X</i>): deduce <i>R</i>(<i>x</i>) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Existential_instantiation" target="_blank">EXISTENTIAL INSTANTIATION</a>]</i></span></li><li><span>From FOR ALL <i>X</i>: (<i>R</i>(<i>X</i>) IMPLIES <i>P</i>(<i>X</i>)): deduce FOR ALL <i>X</i>: (<i>R</i>(<i>X</i>) IMPLIES <i>P</i>(<i>X</i>)) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>)]. <i>[PUSH (for set variables)]</i></span></li><li><span>From FOR ALL <i>X</i>: (<i>R</i>(<i>X</i>) IMPLIES <i>P</i>(<i>X</i>)) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>)]: deduce <i>R</i>(<i>x</i>) IMPLIES <i>P</i>(<i>x</i>) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Universal_instantiation" target="_blank">UNIVERSAL SPECIFICATION</a>]</i></span></li><li><span>From <i>R</i>(<i>x</i>) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>)], <i>R</i>(<i>x</i>) IMPLIES <i>P</i>(<i>x</i>) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>)]: deduce <i>P</i>(<i>x</i>) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Modus_ponens" target="_blank">MODUS PONENS</a>]</i></span></li><li><span>Deduce <i>Q</i>(<i>x</i>) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>), assuming <i>Q</i>(<i>x</i>)]. <i>[IMPLICATION INTRODUCTION]</i></span></li><li><span>From <i>P</i>(<i>x</i>) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>)]: deduce <i>P</i>(<i>x</i>) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>), assuming <i>Q</i>(<i>x</i>)]. <i>[PUSH]</i></span></li><li><span>From <i>P</i>(<i>x</i>) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>), assuming <i>Q</i>(<i>x</i>)], <i>Q</i>(<i>x</i>) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>), assuming <i>Q</i>(<i>x</i>)]: deduce <i>P</i>(<i>x</i>) AND <i>Q</i>(<i>x</i>) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>), assuming <i>Q</i>(<i>x</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_introduction" target="_blank">CONJUNCTION INTRODUCTION</a>]</i></span></li><li><span>From <i>P</i>(<i>x</i>) AND <i>Q</i>(<i>x</i>) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>), assuming <i>Q</i>(<i>x</i>)]: deduce THERE EXISTS <i>X</i>: (<i>P</i>(<i>X</i>) AND <i>Q</i>(<i>X</i>)) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>), assuming <i>Q</i>(<i>x</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Existential_generalization">EXISTENTIAL INTRODUCTION</a>]</i></span></li><li><span>From NOT (THERE EXISTS <i>X</i>: (<i>P</i>(<i>X</i>) AND <i>Q</i>(<i>X</i>))): deduce NOT (THERE EXISTS <i>X</i>: (<i>P</i>(<i>X</i>) AND <i>Q</i>(<i>X</i>))) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>), assuming <i>Q</i>(<i>x</i>)]. <i>[DOUBLE PUSH (mixed IV)]</i></span></li><li><span>From THERE EXISTS <i>X</i>: (<i>P</i>(<i>X</i>) AND <i>Q</i>(<i>X</i>)) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>), assuming <i>Q</i>(<i>x</i>)], NOT (THERE EXISTS <i>X</i>: (<i>P</i>(<i>X</i>) AND <i>Q</i>(<i>X</i>))) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>), assuming <i>Q</i>(<i>x</i>)]: deduce NOT <i>Q</i>(<i>x</i>) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Reductio_ad_absurdum" target="_blank">REDUCTIO AD ABSURDUM</a> (separated form)]</i></span></li><li><span>From <i>R</i>(<i>x</i>) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>)], NOT <i>Q</i>(<i>x</i>) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>)]: deduce <i>R</i>(<i>x</i>) AND (NOT <i>Q</i>(<i>x</i>)) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_introduction" target="_blank">CONJUNCTION INTRODUCTION</a>]</i></span></li><li><span>From <i>R</i>(<i>x</i>) AND (NOT <i>Q</i>(<i>x</i>)) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>)]: deduce THERE EXISTS <i>X</i>: (<i>R</i>(<i>X</i>) AND (NOT <i>Q</i>(<i>X</i>))) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Existential_generalization">EXISTENTIAL INTRODUCTION</a>]</i></span></li><li><span>From THERE EXISTS <i>X</i>: (<i>R</i>(<i>X</i>) AND (NOT <i>Q</i>(<i>X</i>))) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>)]: deduce THERE EXISTS <i>X</i>: (<i>R</i>(<i>X</i>) AND (NOT <i>Q</i>(<i>X</i>))). <i>[PULL]</i></span></li><li><span>QED!</span></li>';

var Exercise225c = new Exercise("22.5(c)", "CAMESTROS SYLLOGISM", [forAll(IMPLIES(PX,QX),X), NOT(thereExists(AND(RX,QX),X)), thereExists(RX,X), formulaContext(Px), formulaContext(Qx), formulaContext(Rx)], thereExists(AND(RX,NOT(PX)),X), 16);
Exercise225c.notes = '<UL><LI> An example of the <A HREF="https://en.wikipedia.org/wiki/Syllogism#Types" target="_blank">Camestros  syllogism</A> is "All horses have hooves. No humans have hooves.  Humans exist.  Hence, some humans are not horses."</LI> <LI> Thanks to Anders Kaseorg for a short proof. </LI> </UL>';
Exercise225c.unlockedBy(Exercise221);
Exercise225c.proof = '<li><span>FOR ALL <i>X</i>: (<i>P</i>(<i>X</i>) IMPLIES <i>Q</i>(<i>X</i>)). <i>[given]</i></span></li><li><span>NOT (THERE EXISTS <i>X</i>: (<i>R</i>(<i>X</i>) AND <i>Q</i>(<i>X</i>))). <i>[given]</i></span></li><li><span>THERE EXISTS <i>X</i>: <i>R</i>(<i>X</i>). <i>[given]</i></span></li><li><span>From THERE EXISTS <i>X</i>: <i>R</i>(<i>X</i>): deduce <i>R</i>(<i>x</i>) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Existential_instantiation" target="_blank">EXISTENTIAL INSTANTIATION</a>]</i></span></li><li><span>From FOR ALL <i>X</i>: (<i>P</i>(<i>X</i>) IMPLIES <i>Q</i>(<i>X</i>)): deduce FOR ALL <i>X</i>: (<i>P</i>(<i>X</i>) IMPLIES <i>Q</i>(<i>X</i>)) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>)]. <i>[PUSH (for set variables)]</i></span></li><li><span>From FOR ALL <i>X</i>: (<i>P</i>(<i>X</i>) IMPLIES <i>Q</i>(<i>X</i>)) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>)]: deduce <i>P</i>(<i>x</i>) IMPLIES <i>Q</i>(<i>x</i>) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Universal_instantiation" target="_blank">UNIVERSAL SPECIFICATION</a>]</i></span></li><li><span>From <i>P</i>(<i>x</i>) IMPLIES <i>Q</i>(<i>x</i>) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>)]: deduce <i>Q</i>(<i>x</i>) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>), assuming <i>P</i>(<i>x</i>)]. <i>[REVERSE <a href="https://en.wikipedia.org/wiki/Deduction_theorem" target="_blank">DEDUCTION THEOREM</a>]</i></span></li><li><span>From <i>R</i>(<i>x</i>) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>)]: deduce <i>R</i>(<i>x</i>) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>), assuming <i>P</i>(<i>x</i>)]. <i>[PUSH]</i></span></li><li><span>From <i>R</i>(<i>x</i>) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>), assuming <i>P</i>(<i>x</i>)], <i>Q</i>(<i>x</i>) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>), assuming <i>P</i>(<i>x</i>)]: deduce <i>R</i>(<i>x</i>) AND <i>Q</i>(<i>x</i>) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>), assuming <i>P</i>(<i>x</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_introduction" target="_blank">CONJUNCTION INTRODUCTION</a>]</i></span></li><li><span>From <i>R</i>(<i>x</i>) AND <i>Q</i>(<i>x</i>) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>), assuming <i>P</i>(<i>x</i>)]: deduce THERE EXISTS <i>X</i>: (<i>R</i>(<i>X</i>) AND <i>Q</i>(<i>X</i>)) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>), assuming <i>P</i>(<i>x</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Existential_generalization">EXISTENTIAL INTRODUCTION</a>]</i></span></li><li><span>From NOT (THERE EXISTS <i>X</i>: (<i>R</i>(<i>X</i>) AND <i>Q</i>(<i>X</i>))): deduce NOT (THERE EXISTS <i>X</i>: (<i>R</i>(<i>X</i>) AND <i>Q</i>(<i>X</i>))) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>), assuming <i>P</i>(<i>x</i>)]. <i>[DOUBLE PUSH (mixed IV)]</i></span></li><li><span>From THERE EXISTS <i>X</i>: (<i>R</i>(<i>X</i>) AND <i>Q</i>(<i>X</i>)) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>), assuming <i>P</i>(<i>x</i>)], NOT (THERE EXISTS <i>X</i>: (<i>R</i>(<i>X</i>) AND <i>Q</i>(<i>X</i>))) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>), assuming <i>P</i>(<i>x</i>)]: deduce NOT <i>P</i>(<i>x</i>) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Reductio_ad_absurdum" target="_blank">REDUCTIO AD ABSURDUM</a> (separated form)]</i></span></li><li><span>From <i>R</i>(<i>x</i>) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>)], NOT <i>P</i>(<i>x</i>) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>)]: deduce <i>R</i>(<i>x</i>) AND (NOT <i>P</i>(<i>x</i>)) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_introduction" target="_blank">CONJUNCTION INTRODUCTION</a>]</i></span></li><li><span>From <i>R</i>(<i>x</i>) AND (NOT <i>P</i>(<i>x</i>)) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>)]: deduce THERE EXISTS <i>X</i>: (<i>R</i>(<i>X</i>) AND (NOT <i>P</i>(<i>X</i>))) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Existential_generalization">EXISTENTIAL INTRODUCTION</a>]</i></span></li><li><span>From THERE EXISTS <i>X</i>: (<i>R</i>(<i>X</i>) AND (NOT <i>P</i>(<i>X</i>))) [setting <i>x</i> s.t. <i>R</i>(<i>x</i>)]: deduce THERE EXISTS <i>X</i>: (<i>R</i>(<i>X</i>) AND (NOT <i>P</i>(<i>X</i>))). <i>[PULL]</i></span></li><li><span>QED!</span></li>';


var Exercise225d = new Exercise("22.5(d)", "FELAPTON SYLLOGISM", [NOT(thereExists(AND(PX,QX),X)), forAll(IMPLIES(PX,RX),X), thereExists(PX,X), formulaContext(Px), formulaContext(Qx), formulaContext(Rx)], thereExists(AND(RX, NOT(QX)),X), 17);
Exercise225d.notes = 'An example of the <A HREF="https://en.wikipedia.org/wiki/Syllogism#Types" target="_blank">Felapton  syllogism</A> is "No flowers are animals. All flowers are plants.  Flowers exist.  Hence, some plants are not animals."';
Exercise225d.unlockedBy(Exercise221);
Exercise225d.proof = '<li><span>NOT (THERE EXISTS <i>X</i>: (<i>P</i>(<i>X</i>) AND <i>Q</i>(<i>X</i>))). <i>[given]</i></span></li><li><span>FOR ALL <i>X</i>: (<i>P</i>(<i>X</i>) IMPLIES <i>R</i>(<i>X</i>)). <i>[given]</i></span></li><li><span>THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>). <i>[given]</i></span></li><li><span>From THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>): deduce <i>P</i>(<i>x</i>) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Existential_instantiation" target="_blank">EXISTENTIAL INSTANTIATION</a>]</i></span></li><li><span>From FOR ALL <i>X</i>: (<i>P</i>(<i>X</i>) IMPLIES <i>R</i>(<i>X</i>)): deduce FOR ALL <i>X</i>: (<i>P</i>(<i>X</i>) IMPLIES <i>R</i>(<i>X</i>)) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>)]. <i>[PUSH (for set variables)]</i></span></li><li><span>From FOR ALL <i>X</i>: (<i>P</i>(<i>X</i>) IMPLIES <i>R</i>(<i>X</i>)) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>)]: deduce <i>P</i>(<i>x</i>) IMPLIES <i>R</i>(<i>x</i>) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Universal_instantiation" target="_blank">UNIVERSAL SPECIFICATION</a>]</i></span></li><li><span>From <i>P</i>(<i>x</i>) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>)], <i>P</i>(<i>x</i>) IMPLIES <i>R</i>(<i>x</i>) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>)]: deduce <i>R</i>(<i>x</i>) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Modus_ponens" target="_blank">MODUS PONENS</a>]</i></span></li><li><span>Deduce <i>Q</i>(<i>x</i>) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>), assuming <i>Q</i>(<i>x</i>)]. <i>[IMPLICATION INTRODUCTION]</i></span></li><li><span>From <i>P</i>(<i>x</i>) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>)]: deduce <i>P</i>(<i>x</i>) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>), assuming <i>Q</i>(<i>x</i>)]. <i>[PUSH]</i></span></li><li><span>From <i>P</i>(<i>x</i>) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>), assuming <i>Q</i>(<i>x</i>)], <i>Q</i>(<i>x</i>) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>), assuming <i>Q</i>(<i>x</i>)]: deduce <i>P</i>(<i>x</i>) AND <i>Q</i>(<i>x</i>) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>), assuming <i>Q</i>(<i>x</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_introduction" target="_blank">CONJUNCTION INTRODUCTION</a>]</i></span></li><li><span>From <i>P</i>(<i>x</i>) AND <i>Q</i>(<i>x</i>) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>), assuming <i>Q</i>(<i>x</i>)]: deduce THERE EXISTS <i>X</i>: (<i>P</i>(<i>X</i>) AND <i>Q</i>(<i>X</i>)) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>), assuming <i>Q</i>(<i>x</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Existential_generalization">EXISTENTIAL INTRODUCTION</a>]</i></span></li><li><span>From NOT (THERE EXISTS <i>X</i>: (<i>P</i>(<i>X</i>) AND <i>Q</i>(<i>X</i>))): deduce NOT (THERE EXISTS <i>X</i>: (<i>P</i>(<i>X</i>) AND <i>Q</i>(<i>X</i>))) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>), assuming <i>Q</i>(<i>x</i>)]. <i>[DOUBLE PUSH (mixed IV)]</i></span></li><li><span>From THERE EXISTS <i>X</i>: (<i>P</i>(<i>X</i>) AND <i>Q</i>(<i>X</i>)) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>), assuming <i>Q</i>(<i>x</i>)], NOT (THERE EXISTS <i>X</i>: (<i>P</i>(<i>X</i>) AND <i>Q</i>(<i>X</i>))) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>), assuming <i>Q</i>(<i>x</i>)]: deduce NOT <i>Q</i>(<i>x</i>) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Reductio_ad_absurdum" target="_blank">REDUCTIO AD ABSURDUM</a> (separated form)]</i></span></li><li><span>From <i>R</i>(<i>x</i>) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>)], NOT <i>Q</i>(<i>x</i>) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>)]: deduce <i>R</i>(<i>x</i>) AND (NOT <i>Q</i>(<i>x</i>)) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_introduction" target="_blank">CONJUNCTION INTRODUCTION</a>]</i></span></li><li><span>From <i>R</i>(<i>x</i>) AND (NOT <i>Q</i>(<i>x</i>)) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>)]: deduce THERE EXISTS <i>X</i>: (<i>R</i>(<i>X</i>) AND (NOT <i>Q</i>(<i>X</i>))) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Existential_generalization">EXISTENTIAL INTRODUCTION</a>]</i></span></li><li><span>From THERE EXISTS <i>X</i>: (<i>R</i>(<i>X</i>) AND (NOT <i>Q</i>(<i>X</i>))) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>)]: deduce THERE EXISTS <i>X</i>: (<i>R</i>(<i>X</i>) AND (NOT <i>Q</i>(<i>X</i>))). <i>[PULL]</i></span></li><li><span>QED!</span></li>';

var Exercise225e = new Exercise("22.5(e)", "DARAPTI SYLLOGISM", [forAll(IMPLIES(PX,QX),X), forAll(IMPLIES(PX,RX),X), thereExists(PX,X)], thereExists(AND(RX, QX),X), 14);
Exercise225e.notes = 'An example of the <A HREF="https://en.wikipedia.org/wiki/Syllogism#Types" target="_blank">Darapti  syllogism</A> is "All squares are rectangles.  All squares are rhombi.  Squares exist.  Hence, some rhombi are rectangles."';
Exercise225e.unlockedBy(Exercise221);
Exercise225e.proof = '<li><span>FOR ALL <i>X</i>: (<i>P</i>(<i>X</i>) IMPLIES <i>Q</i>(<i>X</i>)). <i>[given]</i></span></li><li><span>FOR ALL <i>X</i>: (<i>P</i>(<i>X</i>) IMPLIES <i>R</i>(<i>X</i>)). <i>[given]</i></span></li><li><span>THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>). <i>[given]</i></span></li><li><span>From THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>): deduce <i>P</i>(<i>x</i>) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Existential_instantiation" target="_blank">EXISTENTIAL INSTANTIATION</a>]</i></span></li><li><span>From FOR ALL <i>X</i>: (<i>P</i>(<i>X</i>) IMPLIES <i>R</i>(<i>X</i>)): deduce FOR ALL <i>X</i>: (<i>P</i>(<i>X</i>) IMPLIES <i>R</i>(<i>X</i>)) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>)]. <i>[PUSH (for set variables)]</i></span></li><li><span>From FOR ALL <i>X</i>: (<i>P</i>(<i>X</i>) IMPLIES <i>Q</i>(<i>X</i>)): deduce FOR ALL <i>X</i>: (<i>P</i>(<i>X</i>) IMPLIES <i>Q</i>(<i>X</i>)) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>)]. <i>[PUSH (for set variables)]</i></span></li><li><span>From FOR ALL <i>X</i>: (<i>P</i>(<i>X</i>) IMPLIES <i>R</i>(<i>X</i>)) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>)]: deduce <i>P</i>(<i>x</i>) IMPLIES <i>R</i>(<i>x</i>) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Universal_instantiation" target="_blank">UNIVERSAL SPECIFICATION</a>]</i></span></li><li><span>From FOR ALL <i>X</i>: (<i>P</i>(<i>X</i>) IMPLIES <i>Q</i>(<i>X</i>)) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>)]: deduce <i>P</i>(<i>x</i>) IMPLIES <i>Q</i>(<i>x</i>) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Universal_instantiation" target="_blank">UNIVERSAL SPECIFICATION</a>]</i></span></li><li><span>From <i>P</i>(<i>x</i>) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>)], <i>P</i>(<i>x</i>) IMPLIES <i>R</i>(<i>x</i>) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>)]: deduce <i>R</i>(<i>x</i>) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Modus_ponens" target="_blank">MODUS PONENS</a>]</i></span></li><li><span>From <i>P</i>(<i>x</i>) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>)], <i>P</i>(<i>x</i>) IMPLIES <i>Q</i>(<i>x</i>) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>)]: deduce <i>Q</i>(<i>x</i>) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Modus_ponens" target="_blank">MODUS PONENS</a>]</i></span></li><li><span>From <i>R</i>(<i>x</i>) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>)], <i>Q</i>(<i>x</i>) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>)]: deduce <i>R</i>(<i>x</i>) AND <i>Q</i>(<i>x</i>) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_introduction" target="_blank">CONJUNCTION INTRODUCTION</a>]</i></span></li><li><span>From <i>R</i>(<i>x</i>) AND <i>Q</i>(<i>x</i>) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>)]: deduce THERE EXISTS <i>X</i>: (<i>R</i>(<i>X</i>) AND <i>Q</i>(<i>X</i>)) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Existential_generalization">EXISTENTIAL INTRODUCTION</a>]</i></span></li><li><span>From THERE EXISTS <i>X</i>: (<i>R</i>(<i>X</i>) AND <i>Q</i>(<i>X</i>)) [setting <i>x</i> s.t. <i>P</i>(<i>x</i>)]: deduce THERE EXISTS <i>X</i>: (<i>R</i>(<i>X</i>) AND <i>Q</i>(<i>X</i>)). <i>[PULL]</i></span></li><li><span>QED!</span></li>';

var Exercise226 = new Exercise("22.6(a)", "THERE EXISTS IS COMMUTATIVE", [thereExists(thereExists(QXY,X),Y)], thereExists(thereExists(QXY,Y),X), 8);
Exercise226.notes = 'In this exercise you may need to use the law of existential instantiation with a specific choice of bound variable (rather than let the text choose the first available bound variable).  In order to do so, one needs to click on the original statement <I>P(&alpha;)</I>, then CTRL-click on the term <I>&alpha;</I>, then CTRL-click on the bound variable.  (Alternatively, one can drag the statement to the term and then CTRL-click on the bound variable.)'
Exercise226.unlockedBy(Exercise221);
Exercise226.proof = '<li><span>THERE EXISTS <i>Y</i>: (THERE EXISTS <i>X</i>: <i>Q</i>(<i>X</i>, <i>Y</i>)). <i>[given]</i></span></li><li><span>From THERE EXISTS <i>Y</i>: (THERE EXISTS <i>X</i>: <i>Q</i>(<i>X</i>, <i>Y</i>)): deduce THERE EXISTS <i>X</i>: <i>Q</i>(<i>X</i>, <i>y</i>) [setting <i>y</i> s.t. THERE EXISTS <i>X</i>: <i>Q</i>(<i>X</i>, <i>y</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Existential_instantiation" target="_blank">EXISTENTIAL INSTANTIATION</a>]</i></span></li><li><span>From THERE EXISTS <i>X</i>: <i>Q</i>(<i>X</i>, <i>y</i>) [setting <i>y</i> s.t. THERE EXISTS <i>X</i>: <i>Q</i>(<i>X</i>, <i>y</i>)]: deduce <i>Q</i>(<i>x</i>, <i>y</i>) [setting <i>y</i> s.t. THERE EXISTS <i>X</i>: <i>Q</i>(<i>X</i>, <i>y</i>), setting <i>x</i> s.t. <i>Q</i>(<i>x</i>, <i>y</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Existential_instantiation" target="_blank">EXISTENTIAL INSTANTIATION</a>]</i></span></li><li><span>From <i>Q</i>(<i>x</i>, <i>y</i>) [setting <i>y</i> s.t. THERE EXISTS <i>X</i>: <i>Q</i>(<i>X</i>, <i>y</i>), setting <i>x</i> s.t. <i>Q</i>(<i>x</i>, <i>y</i>)]: deduce THERE EXISTS <i>Y</i>: <i>Q</i>(<i>x</i>, <i>Y</i>) [setting <i>y</i> s.t. THERE EXISTS <i>X</i>: <i>Q</i>(<i>X</i>, <i>y</i>), setting <i>x</i> s.t. <i>Q</i>(<i>x</i>, <i>y</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Existential_generalization">EXISTENTIAL INTRODUCTION</a>]</i></span></li><li><span>From THERE EXISTS <i>Y</i>: <i>Q</i>(<i>x</i>, <i>Y</i>) [setting <i>y</i> s.t. THERE EXISTS <i>X</i>: <i>Q</i>(<i>X</i>, <i>y</i>), setting <i>x</i> s.t. <i>Q</i>(<i>x</i>, <i>y</i>)]: deduce THERE EXISTS <i>X</i>: (THERE EXISTS <i>Y</i>: <i>Q</i>(<i>X</i>, <i>Y</i>)) [setting <i>y</i> s.t. THERE EXISTS <i>X</i>: <i>Q</i>(<i>X</i>, <i>y</i>), setting <i>x</i> s.t. <i>Q</i>(<i>x</i>, <i>y</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Existential_generalization">EXISTENTIAL INTRODUCTION</a>]</i></span></li><li><span>From THERE EXISTS <i>X</i>: (THERE EXISTS <i>Y</i>: <i>Q</i>(<i>X</i>, <i>Y</i>)) [setting <i>y</i> s.t. THERE EXISTS <i>X</i>: <i>Q</i>(<i>X</i>, <i>y</i>), setting <i>x</i> s.t. <i>Q</i>(<i>x</i>, <i>y</i>)]: deduce THERE EXISTS <i>X</i>: (THERE EXISTS <i>Y</i>: <i>Q</i>(<i>X</i>, <i>Y</i>)) [setting <i>y</i> s.t. THERE EXISTS <i>X</i>: <i>Q</i>(<i>X</i>, <i>y</i>)]. <i>[PULL]</i></span></li><li><span>From THERE EXISTS <i>X</i>: (THERE EXISTS <i>Y</i>: <i>Q</i>(<i>X</i>, <i>Y</i>)) [setting <i>y</i> s.t. THERE EXISTS <i>X</i>: <i>Q</i>(<i>X</i>, <i>y</i>)]: deduce THERE EXISTS <i>X</i>: (THERE EXISTS <i>Y</i>: <i>Q</i>(<i>X</i>, <i>Y</i>)). <i>[PULL]</i></span></li><li><span>QED!</span></li>';

var Exercise226b = new Exercise("22.6(b)", "INTERCHANGING FOR ALL AND THERE EXISTS", [thereExists(forAll(QXY,X),Y)], forAll(thereExists(QXY,Y),X), 7);
Exercise226b.unlockedBy(Exercise221);
Exercise226b.notes = '<UL><LI> This exercise cannot be reversed.  For instance, using the natural numbers as the domain of discourse, the statement "FOR ALL X: THERE EXISTS Y: Y>X" is true (every number has another number larger than it), but the statement "THERE EXISTS Y: FOR ALL X: Y>X" is false (there is no number that is larger than every number).</LI> <LI> Thanks to Anders Kaseorg for a short proof. </LI> </UL>';
Exercise226b.proof = '<li><span>THERE EXISTS <i>Y</i>: (FOR ALL <i>X</i>: <i>Q</i>(<i>X</i>, <i>Y</i>)). <i>[given]</i></span></li><li><span>From THERE EXISTS <i>Y</i>: (FOR ALL <i>X</i>: <i>Q</i>(<i>X</i>, <i>Y</i>)): deduce FOR ALL <i>X</i>: <i>Q</i>(<i>X</i>, <i>y</i>) [setting <i>y</i> s.t. FOR ALL <i>X</i>: <i>Q</i>(<i>X</i>, <i>y</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Existential_instantiation" target="_blank">EXISTENTIAL INSTANTIATION</a>]</i></s    pan></li><li><span>From FOR ALL <i>X</i>: <i>Q</i>(<i>X</i>, <i>y</i>) [setting <i>y</i> s.t. FOR ALL <i>X</i>: <i>Q</i>(<i>X</i>, <i>y</i>)]: deduce <i>Q</i>(<i>x</i>, <i>y</i>) [setting <i>y</i> s.t. FOR ALL <i>X</i>: <i>Q</i>(<i>X</i>, <i>y</i>), letting <i>x</i> be arbitrary]. <i>[REVERSE <a href="https://en.wikipedia.org/wiki/Universal_generalization" target="_blank"> UNIVERSAL INTRODUCTION</a>]</i></span></li><li><span>From <i>Q</i>(<i>x</i>, <i>y</i>) [setting <i>y</i> s.t. FOR ALL <i>X</i>: <i>Q</i>(<i>X</i>, <i>y</i>), letting <i>x</i> be arbitrary]: deduce THERE EXISTS <i>Y</i>: <i>Q</i>(<i>x</i>, <i>Y</i>) [setting <i>y</i> s.t. FOR ALL <i>X</i>: <i>Q</i>(<i>X</i>, <i>y</i>), letting <i>x</i> be arbitrary]. <i>[<a href="https://en.wikipedia.org/wiki/Existential_generalization">EXISTENTIAL INTRODUCTION</a>]</i></span></li><li><span>From THERE EXISTS <i>Y</i>: <i>Q</i>(<i>x</i>, <i>Y</i>) [setting <i>y</i> s.t. FOR ALL <i>X</i>: <i>Q</i>(<i>X</i>, <i>y</i>), letting <i>x</i> be arbitrary]: deduce FOR ALL <i>X</i>: (THERE EXISTS <i>Y</i>: <i>Q</i>(<i>X</i>, <i>Y</i>)) [setting <i>y</i> s.t. FOR ALL <i>X</i>: <i>Q</i>(<i>X</i>, <i>y</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Universal_generalization" target="_blank"> UNIVERSAL INTRODUCTION</a>]</i></span></li><li><span>From FOR ALL <i>X</i>: (THERE EXISTS <i>Y</i>: <i>Q</i>(<i>X</i>, <i>Y</i>)) [setting <i>y</i> s.t. FOR ALL <i>X</i>: <i>Q</i>(<i>X</i>, <i>y</i>)]: deduce FOR ALL <i>X</i>: (THERE EXISTS <i>Y</i>: <i>Q</i>(<i>X</i>, <i>Y</i>)). <i>[PULL]</i></span></li><li><span>QED!</span></li>';

var Exercise227 = new Exercise("22.7", "", [formulaContext(Px), formulaContext(Qy)], IFF( AND(thereExists(PX,X), thereExists(QY,Y)), thereExists(thereExists(AND(PX,QY),Y),X)), 24);
Exercise227.unlockedBy(Exercise221);
Exercise227.proof = '<li><span>Deduce (THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>)) AND (THERE EXISTS <i>Y</i>: <i>Q</i>(<i>Y</i>)) [assuming (THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>)) AND (THERE EXISTS <i>Y</i>: <i>Q</i>(<i>Y</i>))]. <i>[IMPLICATION INTRODUCTION]</i></span></li><li><span>From (THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>)) AND (THERE EXISTS <i>Y</i>: <i>Q</i>(<i>Y</i>)) [assuming (THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>)) AND (THERE EXISTS <i>Y</i>: <i>Q</i>(<i>Y</i>))]: deduce THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>) [assuming (THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>)) AND (THERE EXISTS <i>Y</i>: <i>Q</i>(<i>Y</i>))]. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_elimination" target="_blank">CONJUNCTION ELIMINATION</a> (left)]</i></span></li><li><span>From (THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>)) AND (THERE EXISTS <i>Y</i>: <i>Q</i>(<i>Y</i>)) [assuming (THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>)) AND (THERE EXISTS <i>Y</i>: <i>Q</i>(<i>Y</i>))]: deduce THERE EXISTS <i>Y</i>: <i>Q</i>(<i>Y</i>) [assuming (THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>)) AND (THERE EXISTS <i>Y</i>: <i>Q</i>(<i>Y</i>))]. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_elimination" target="_blank">CONJUNCTION ELIMINATION</a> (right)]</i></span></li><li><span>From THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>) [assuming (THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>)) AND (THERE EXISTS <i>Y</i>: <i>Q</i>(<i>Y</i>))]: deduce <i>P</i>(<i>x</i>) [assuming (THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>)) AND (THERE EXISTS <i>Y</i>: <i>Q</i>(<i>Y</i>)), setting <i>x</i> s.t. <i>P</i>(<i>x</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Existential_instantiation" target="_blank">EXISTENTIAL INSTANTIATION</a>]</i></span></li><li><span>From THERE EXISTS <i>Y</i>: <i>Q</i>(<i>Y</i>) [assuming (THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>)) AND (THERE EXISTS <i>Y</i>: <i>Q</i>(<i>Y</i>))]: deduce THERE EXISTS <i>Y</i>: <i>Q</i>(<i>Y</i>) [assuming (THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>)) AND (THERE EXISTS <i>Y</i>: <i>Q</i>(<i>Y</i>)), setting <i>x</i> s.t. <i>P</i>(<i>x</i>)]. <i>[PUSH (for set variables)]</i></span></li><li><span>From THERE EXISTS <i>Y</i>: <i>Q</i>(<i>Y</i>) [assuming (THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>)) AND (THERE EXISTS <i>Y</i>: <i>Q</i>(<i>Y</i>)), setting <i>x</i> s.t. <i>P</i>(<i>x</i>)]: deduce <i>Q</i>(<i>y</i>) [assuming (THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>)) AND (THERE EXISTS <i>Y</i>: <i>Q</i>(<i>Y</i>)), setting <i>x</i> s.t. <i>P</i>(<i>x</i>), setting <i>y</i> s.t. <i>Q</i>(<i>y</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Existential_instantiation" target="_blank">EXISTENTIAL INSTANTIATION</a>]</i></span></li><li><span>From <i>P</i>(<i>x</i>) [assuming (THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>)) AND (THERE EXISTS <i>Y</i>: <i>Q</i>(<i>Y</i>)), setting <i>x</i> s.t. <i>P</i>(<i>x</i>)]: deduce <i>P</i>(<i>x</i>) [assuming (THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>)) AND (THERE EXISTS <i>Y</i>: <i>Q</i>(<i>Y</i>)), setting <i>x</i> s.t. <i>P</i>(<i>x</i>), setting <i>y</i> s.t. <i>Q</i>(<i>y</i>)]. <i>[PUSH (for set variables)]</i></span></li><li><span>From <i>P</i>(<i>x</i>) [assuming (THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>)) AND (THERE EXISTS <i>Y</i>: <i>Q</i>(<i>Y</i>)), setting <i>x</i> s.t. <i>P</i>(<i>x</i>), setting <i>y</i> s.t. <i>Q</i>(<i>y</i>)], <i>Q</i>(<i>y</i>) [assuming (THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>)) AND (THERE EXISTS <i>Y</i>: <i>Q</i>(<i>Y</i>)), setting <i>x</i> s.t. <i>P</i>(<i>x</i>), setting <i>y</i> s.t. <i>Q</i>(<i>y</i>)]: deduce <i>P</i>(<i>x</i>) AND <i>Q</i>(<i>y</i>) [assuming (THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>)) AND (THERE EXISTS <i>Y</i>: <i>Q</i>(<i>Y</i>)), setting <i>x</i> s.t. <i>P</i>(<i>x</i>), setting <i>y</i> s.t. <i>Q</i>(<i>y</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_introduction" target="_blank">CONJUNCTION INTRODUCTION</a>]</i></span></li><li><span>From <i>P</i>(<i>x</i>) AND <i>Q</i>(<i>y</i>) [assuming (THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>)) AND (THERE EXISTS <i>Y</i>: <i>Q</i>(<i>Y</i>)), setting <i>x</i> s.t. <i>P</i>(<i>x</i>), setting <i>y</i> s.t. <i>Q</i>(<i>y</i>)]: deduce THERE EXISTS <i>Y</i>: (<i>P</i>(<i>x</i>) AND <i>Q</i>(<i>Y</i>)) [assuming (THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>)) AND (THERE EXISTS <i>Y</i>: <i>Q</i>(<i>Y</i>)), setting <i>x</i> s.t. <i>P</i>(<i>x</i>), setting <i>y</i> s.t. <i>Q</i>(<i>y</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Existential_generalization">EXISTENTIAL INTRODUCTION</a>]</i></span></li><li><span>From THERE EXISTS <i>Y</i>: (<i>P</i>(<i>x</i>) AND <i>Q</i>(<i>Y</i>)) [assuming (THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>)) AND (THERE EXISTS <i>Y</i>: <i>Q</i>(<i>Y</i>)), setting <i>x</i> s.t. <i>P</i>(<i>x</i>), setting <i>y</i> s.t. <i>Q</i>(<i>y</i>)]: deduce THERE EXISTS <i>X</i>: (THERE EXISTS <i>Y</i>: (<i>P</i>(<i>X</i>) AND <i>Q</i>(<i>Y</i>))) [assuming (THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>)) AND (THERE EXISTS <i>Y</i>: <i>Q</i>(<i>Y</i>)), setting <i>x</i> s.t. <i>P</i>(<i>x</i>), setting <i>y</i> s.t. <i>Q</i>(<i>y</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Existential_generalization">EXISTENTIAL INTRODUCTION</a>]</i></span></li><li><span>From THERE EXISTS <i>X</i>: (THERE EXISTS <i>Y</i>: (<i>P</i>(<i>X</i>) AND <i>Q</i>(<i>Y</i>))) [assuming (THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>)) AND (THERE EXISTS <i>Y</i>: <i>Q</i>(<i>Y</i>)), setting <i>x</i> s.t. <i>P</i>(<i>x</i>), setting <i>y</i> s.t. <i>Q</i>(<i>y</i>)]: deduce THERE EXISTS <i>X</i>: (THERE EXISTS <i>Y</i>: (<i>P</i>(<i>X</i>) AND <i>Q</i>(<i>Y</i>))) [assuming (THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>)) AND (THERE EXISTS <i>Y</i>: <i>Q</i>(<i>Y</i>)), setting <i>x</i> s.t. <i>P</i>(<i>x</i>)]. <i>[PULL]</i></span></li><li><span>From THERE EXISTS <i>X</i>: (THERE EXISTS <i>Y</i>: (<i>P</i>(<i>X</i>) AND <i>Q</i>(<i>Y</i>))) [assuming (THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>)) AND (THERE EXISTS <i>Y</i>: <i>Q</i>(<i>Y</i>)), setting <i>x</i> s.t. <i>P</i>(<i>x</i>)]: deduce THERE EXISTS <i>X</i>: (THERE EXISTS <i>Y</i>: (<i>P</i>(<i>X</i>) AND <i>Q</i>(<i>Y</i>))) [assuming (THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>)) AND (THERE EXISTS <i>Y</i>: <i>Q</i>(<i>Y</i>))]. <i>[PULL]</i></span></li><li><span>Deduce THERE EXISTS <i>X</i>: (THERE EXISTS <i>Y</i>: (<i>P</i>(<i>X</i>) AND <i>Q</i>(<i>Y</i>))) [assuming THERE EXISTS <i>X</i>: (THERE EXISTS <i>Y</i>: (<i>P</i>(<i>X</i>) AND <i>Q</i>(<i>Y</i>)))]. <i>[IMPLICATION INTRODUCTION]</i></span></li><li><span>From THERE EXISTS <i>X</i>: (THERE EXISTS <i>Y</i>: (<i>P</i>(<i>X</i>) AND <i>Q</i>(<i>Y</i>))) [assuming THERE EXISTS <i>X</i>: (THERE EXISTS <i>Y</i>: (<i>P</i>(<i>X</i>) AND <i>Q</i>(<i>Y</i>)))]: deduce THERE EXISTS <i>Y</i>: (<i>P</i>(<i>x</i>) AND <i>Q</i>(<i>Y</i>)) [assuming THERE EXISTS <i>X</i>: (THERE EXISTS <i>Y</i>: (<i>P</i>(<i>X</i>) AND <i>Q</i>(<i>Y</i>))), setting <i>x</i> s.t. THERE EXISTS <i>Y</i>: (<i>P</i>(<i>x</i>) AND <i>Q</i>(<i>Y</i>))]. <i>[<a href="https://en.wikipedia.org/wiki/Existential_instantiation" target="_blank">EXISTENTIAL INSTANTIATION</a>]</i></span></li><li><span>From THERE EXISTS <i>Y</i>: (<i>P</i>(<i>x</i>) AND <i>Q</i>(<i>Y</i>)) [assuming THERE EXISTS <i>X</i>: (THERE EXISTS <i>Y</i>: (<i>P</i>(<i>X</i>) AND <i>Q</i>(<i>Y</i>))), setting <i>x</i> s.t. THERE EXISTS <i>Y</i>: (<i>P</i>(<i>x</i>) AND <i>Q</i>(<i>Y</i>))]: deduce <i>P</i>(<i>x</i>) AND <i>Q</i>(<i>y</i>) [assuming THERE EXISTS <i>X</i>: (THERE EXISTS <i>Y</i>: (<i>P</i>(<i>X</i>) AND <i>Q</i>(<i>Y</i>))), setting <i>x</i> s.t. THERE EXISTS <i>Y</i>: (<i>P</i>(<i>x</i>) AND <i>Q</i>(<i>Y</i>)), setting <i>y</i> s.t. <i>P</i>(<i>x</i>) AND <i>Q</i>(<i>y</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Existential_instantiation" target="_blank">EXISTENTIAL INSTANTIATION</a>]</i></span></li><li><span>From <i>P</i>(<i>x</i>) AND <i>Q</i>(<i>y</i>) [assuming THERE EXISTS <i>X</i>: (THERE EXISTS <i>Y</i>: (<i>P</i>(<i>X</i>) AND <i>Q</i>(<i>Y</i>))), setting <i>x</i> s.t. THERE EXISTS <i>Y</i>: (<i>P</i>(<i>x</i>) AND <i>Q</i>(<i>Y</i>)), setting <i>y</i> s.t. <i>P</i>(<i>x</i>) AND <i>Q</i>(<i>y</i>)]: deduce <i>P</i>(<i>x</i>) [assuming THERE EXISTS <i>X</i>: (THERE EXISTS <i>Y</i>: (<i>P</i>(<i>X</i>) AND <i>Q</i>(<i>Y</i>))), setting <i>x</i> s.t. THERE EXISTS <i>Y</i>: (<i>P</i>(<i>x</i>) AND <i>Q</i>(<i>Y</i>)), setting <i>y</i> s.t. <i>P</i>(<i>x</i>) AND <i>Q</i>(<i>y</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_elimination" target="_blank">CONJUNCTION ELIMINATION</a> (left)]</i></span></li><li><span>From <i>P</i>(<i>x</i>) AND <i>Q</i>(<i>y</i>) [assuming THERE EXISTS <i>X</i>: (THERE EXISTS <i>Y</i>: (<i>P</i>(<i>X</i>) AND <i>Q</i>(<i>Y</i>))), setting <i>x</i> s.t. THERE EXISTS <i>Y</i>: (<i>P</i>(<i>x</i>) AND <i>Q</i>(<i>Y</i>)), setting <i>y</i> s.t. <i>P</i>(<i>x</i>) AND <i>Q</i>(<i>y</i>)]: deduce <i>Q</i>(<i>y</i>) [assuming THERE EXISTS <i>X</i>: (THERE EXISTS <i>Y</i>: (<i>P</i>(<i>X</i>) AND <i>Q</i>(<i>Y</i>))), setting <i>x</i> s.t. THERE EXISTS <i>Y</i>: (<i>P</i>(<i>x</i>) AND <i>Q</i>(<i>Y</i>)), setting <i>y</i> s.t. <i>P</i>(<i>x</i>) AND <i>Q</i>(<i>y</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_elimination" target="_blank">CONJUNCTION ELIMINATION</a> (right)]</i></span></li><li><span>From <i>P</i>(<i>x</i>) [assuming THERE EXISTS <i>X</i>: (THERE EXISTS <i>Y</i>: (<i>P</i>(<i>X</i>) AND <i>Q</i>(<i>Y</i>))), setting <i>x</i> s.t. THERE EXISTS <i>Y</i>: (<i>P</i>(<i>x</i>) AND <i>Q</i>(<i>Y</i>)), setting <i>y</i> s.t. <i>P</i>(<i>x</i>) AND <i>Q</i>(<i>y</i>)]: deduce THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>) [assuming THERE EXISTS <i>X</i>: (THERE EXISTS <i>Y</i>: (<i>P</i>(<i>X</i>) AND <i>Q</i>(<i>Y</i>))), setting <i>x</i> s.t. THERE EXISTS <i>Y</i>: (<i>P</i>(<i>x</i>) AND <i>Q</i>(<i>Y</i>)), setting <i>y</i> s.t. <i>P</i>(<i>x</i>) AND <i>Q</i>(<i>y</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Existential_generalization">EXISTENTIAL INTRODUCTION</a>]</i></span></li><li><span>From <i>Q</i>(<i>y</i>) [assuming THERE EXISTS <i>X</i>: (THERE EXISTS <i>Y</i>: (<i>P</i>(<i>X</i>) AND <i>Q</i>(<i>Y</i>))), setting <i>x</i> s.t. THERE EXISTS <i>Y</i>: (<i>P</i>(<i>x</i>) AND <i>Q</i>(<i>Y</i>)), setting <i>y</i> s.t. <i>P</i>(<i>x</i>) AND <i>Q</i>(<i>y</i>)]: deduce THERE EXISTS <i>Y</i>: <i>Q</i>(<i>Y</i>) [assuming THERE EXISTS <i>X</i>: (THERE EXISTS <i>Y</i>: (<i>P</i>(<i>X</i>) AND <i>Q</i>(<i>Y</i>))), setting <i>x</i> s.t. THERE EXISTS <i>Y</i>: (<i>P</i>(<i>x</i>) AND <i>Q</i>(<i>Y</i>)), setting <i>y</i> s.t. <i>P</i>(<i>x</i>) AND <i>Q</i>(<i>y</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Existential_generalization">EXISTENTIAL INTRODUCTION</a>]</i></span></li><li><span>From THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>) [assuming THERE EXISTS <i>X</i>: (THERE EXISTS <i>Y</i>: (<i>P</i>(<i>X</i>) AND <i>Q</i>(<i>Y</i>))), setting <i>x</i> s.t. THERE EXISTS <i>Y</i>: (<i>P</i>(<i>x</i>) AND <i>Q</i>(<i>Y</i>)), setting <i>y</i> s.t. <i>P</i>(<i>x</i>) AND <i>Q</i>(<i>y</i>)], THERE EXISTS <i>Y</i>: <i>Q</i>(<i>Y</i>) [assuming THERE EXISTS <i>X</i>: (THERE EXISTS <i>Y</i>: (<i>P</i>(<i>X</i>) AND <i>Q</i>(<i>Y</i>))), setting <i>x</i> s.t. THERE EXISTS <i>Y</i>: (<i>P</i>(<i>x</i>) AND <i>Q</i>(<i>Y</i>)), setting <i>y</i> s.t. <i>P</i>(<i>x</i>) AND <i>Q</i>(<i>y</i>)]: deduce (THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>)) AND (THERE EXISTS <i>Y</i>: <i>Q</i>(<i>Y</i>)) [assuming THERE EXISTS <i>X</i>: (THERE EXISTS <i>Y</i>: (<i>P</i>(<i>X</i>) AND <i>Q</i>(<i>Y</i>))), setting <i>x</i> s.t. THERE EXISTS <i>Y</i>: (<i>P</i>(<i>x</i>) AND <i>Q</i>(<i>Y</i>)), setting <i>y</i> s.t. <i>P</i>(<i>x</i>) AND <i>Q</i>(<i>y</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_introduction" target="_blank">CONJUNCTION INTRODUCTION</a>]</i></span></li><li><span>From (THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>)) AND (THERE EXISTS <i>Y</i>: <i>Q</i>(<i>Y</i>)) [assuming THERE EXISTS <i>X</i>: (THERE EXISTS <i>Y</i>: (<i>P</i>(<i>X</i>) AND <i>Q</i>(<i>Y</i>))), setting <i>x</i> s.t. THERE EXISTS <i>Y</i>: (<i>P</i>(<i>x</i>) AND <i>Q</i>(<i>Y</i>)), setting <i>y</i> s.t. <i>P</i>(<i>x</i>) AND <i>Q</i>(<i>y</i>)]: deduce (THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>)) AND (THERE EXISTS <i>Y</i>: <i>Q</i>(<i>Y</i>)) [assuming THERE EXISTS <i>X</i>: (THERE EXISTS <i>Y</i>: (<i>P</i>(<i>X</i>) AND <i>Q</i>(<i>Y</i>))), setting <i>x</i> s.t. THERE EXISTS <i>Y</i>: (<i>P</i>(<i>x</i>) AND <i>Q</i>(<i>Y</i>))]. <i>[PULL]</i></span></li><li><span>From (THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>)) AND (THERE EXISTS <i>Y</i>: <i>Q</i>(<i>Y</i>)) [assuming THERE EXISTS <i>X</i>: (THERE EXISTS <i>Y</i>: (<i>P</i>(<i>X</i>) AND <i>Q</i>(<i>Y</i>))), setting <i>x</i> s.t. THERE EXISTS <i>Y</i>: (<i>P</i>(<i>x</i>) AND <i>Q</i>(<i>Y</i>))]: deduce (THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>)) AND (THERE EXISTS <i>Y</i>: <i>Q</i>(<i>Y</i>)) [assuming THERE EXISTS <i>X</i>: (THERE EXISTS <i>Y</i>: (<i>P</i>(<i>X</i>) AND <i>Q</i>(<i>Y</i>)))]. <i>[PULL]</i></span></li><li><span>From (THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>)) AND (THERE EXISTS <i>Y</i>: <i>Q</i>(<i>Y</i>)) [assuming THERE EXISTS <i>X</i>: (THERE EXISTS <i>Y</i>: (<i>P</i>(<i>X</i>) AND <i>Q</i>(<i>Y</i>)))], THERE EXISTS <i>X</i>: (THERE EXISTS <i>Y</i>: (<i>P</i>(<i>X</i>) AND <i>Q</i>(<i>Y</i>))) [assuming (THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>)) AND (THERE EXISTS <i>Y</i>: <i>Q</i>(<i>Y</i>))]: deduce ((THERE EXISTS <i>X</i>: <i>P</i>(<i>X</i>)) AND (THERE EXISTS <i>Y</i>: <i>Q</i>(<i>Y</i>))) IFF (THERE EXISTS <i>X</i>: (THERE EXISTS <i>Y</i>: (<i>P</i>(<i>X</i>) AND <i>Q</i>(<i>Y</i>)))). <i>[BICONDITIONAL INTRODUCTION (ASSUMPTION FORM)]</i></span></li><li><span>QED!</span></li>';

var Exercise228 = new Exercise("22.8", "LEWIS CARROLL SYLLOGISM", [forAll(IMPLIES(PX,NOT(QX)),X), forAll(IMPLIES(NOT(QX),RX),X), NOT(thereExists(AND(RX,SX),X))], forAll(IMPLIES(PX, NOT(SX)),X), 21);
Exercise228.unlockedBy(Exercise221);
Exercise228.notes = '<UL><LI> Lewis Carroll is best known for his books "Alice in Wonderland" and "Through the Looking Glass".  But he also wrote a list of logic puzzles, some of which can be found <A HREF="http://www.math.hawaii.edu/~hile/math100/logice.htm" target="_blank">here</A>.</LI> <LI> The simplest of his logic puzzles is the following.  Given the hypotheses "Babies are illogical.  Illogical persons are despised.  Nobody who is despised can manage a crocodile", conclude "Babies cannot handle crocodiles".  </LI> <LI> The exercise here is a translation of that puzzle to first-order logic - can you see how? </LI> <LI> The solution of this exercise would be significantly shorter if it were possible to use previous syllogism exercises here.  Unfortunately, a matching algorithm for these syllogisms has not yet been implemented.  Perhaps this will be done in a future version of the text.</LI> </UL>';
Exercise228.proof = '<li><span>FOR ALL <i>X</i>: (<i>P</i>(<i>X</i>) IMPLIES (NOT <i>Q</i>(<i>X</i>))). <i>[given]</i></span></li><li><span>FOR ALL <i>X</i>: ((NOT <i>Q</i>(<i>X</i>)) IMPLIES <i>R</i>(<i>X</i>)). <i>[given]</i></span></li><li><span>NOT (THERE EXISTS <i>X</i>: (<i>R</i>(<i>X</i>) AND <i>S</i>(<i>X</i>))). <i>[given]</i></span></li><li><span>Form environment [letting <i>x</i> be arbitrary]. <i>[FREE VARIABLE INTRODUCTION]</i></span></li><li><span>Deduce <i>P</i>(<i>x</i>) [letting <i>x</i> be arbitrary, assuming <i>P</i>(<i>x</i>)]. <i>[IMPLICATION INTRODUCTION]</i></span></li><li><span>From FOR ALL <i>X</i>: (<i>P</i>(<i>X</i>) IMPLIES (NOT <i>Q</i>(<i>X</i>))): deduce FOR ALL <i>X</i>: (<i>P</i>(<i>X</i>) IMPLIES (NOT <i>Q</i>(<i>X</i>))) [letting <i>x</i> be arbitrary, assuming <i>P</i>(<i>x</i>)]. <i>[DOUBLE PUSH (mixed version II)]</i></span></li><li><span>From FOR ALL <i>X</i>: (<i>P</i>(<i>X</i>) IMPLIES (NOT <i>Q</i>(<i>X</i>))) [letting <i>x</i> be arbitrary, assuming <i>P</i>(<i>x</i>)]: deduce <i>P</i>(<i>x</i>) IMPLIES (NOT <i>Q</i>(<i>x</i>)) [letting <i>x</i> be arbitrary, assuming <i>P</i>(<i>x</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Universal_instantiation" target="_blank">UNIVERSAL SPECIFICATION</a>]</i></span></li><li><span>From <i>P</i>(<i>x</i>) [letting <i>x</i> be arbitrary, assuming <i>P</i>(<i>x</i>)], <i>P</i>(<i>x</i>) IMPLIES (NOT <i>Q</i>(<i>x</i>)) [letting <i>x</i> be arbitrary, assuming <i>P</i>(<i>x</i>)]: deduce NOT <i>Q</i>(<i>x</i>) [letting <i>x</i> be arbitrary, assuming <i>P</i>(<i>x</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Modus_ponens" target="_blank">MODUS PONENS</a>]</i></span></li><li><span>From FOR ALL <i>X</i>: ((NOT <i>Q</i>(<i>X</i>)) IMPLIES <i>R</i>(<i>X</i>)): deduce FOR ALL <i>X</i>: ((NOT <i>Q</i>(<i>X</i>)) IMPLIES <i>R</i>(<i>X</i>)) [letting <i>x</i> be arbitrary, assuming <i>P</i>(<i>x</i>)]. <i>[DOUBLE PUSH (mixed version II)]</i></span></li><li><span>From FOR ALL <i>X</i>: ((NOT <i>Q</i>(<i>X</i>)) IMPLIES <i>R</i>(<i>X</i>)) [letting <i>x</i> be arbitrary, assuming <i>P</i>(<i>x</i>)]: deduce (NOT <i>Q</i>(<i>x</i>)) IMPLIES <i>R</i>(<i>x</i>) [letting <i>x</i> be arbitrary, assuming <i>P</i>(<i>x</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Universal_instantiation" target="_blank">UNIVERSAL SPECIFICATION</a>]</i></span></li><li><span>From NOT <i>Q</i>(<i>x</i>) [letting <i>x</i> be arbitrary, assuming <i>P</i>(<i>x</i>)], (NOT <i>Q</i>(<i>x</i>)) IMPLIES <i>R</i>(<i>x</i>) [letting <i>x</i> be arbitrary, assuming <i>P</i>(<i>x</i>)]: deduce <i>R</i>(<i>x</i>) [letting <i>x</i> be arbitrary, assuming <i>P</i>(<i>x</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Modus_ponens" target="_blank">MODUS PONENS</a>]</i></span></li><li><span>Deduce <i>S</i>(<i>x</i>) [letting <i>x</i> be arbitrary, assuming <i>P</i>(<i>x</i>), <i>S</i>(<i>x</i>)]. <i>[IMPLICATION INTRODUCTION]</i></span></li><li><span>From <i>R</i>(<i>x</i>) [letting <i>x</i> be arbitrary, assuming <i>P</i>(<i>x</i>)]: deduce <i>R</i>(<i>x</i>) [letting <i>x</i> be arbitrary, assuming <i>P</i>(<i>x</i>), <i>S</i>(<i>x</i>)]. <i>[PUSH]</i></span></li><li><span>From <i>R</i>(<i>x</i>) [letting <i>x</i> be arbitrary, assuming <i>P</i>(<i>x</i>), <i>S</i>(<i>x</i>)], <i>S</i>(<i>x</i>) [letting <i>x</i> be arbitrary, assuming <i>P</i>(<i>x</i>), <i>S</i>(<i>x</i>)]: deduce <i>R</i>(<i>x</i>) AND <i>S</i>(<i>x</i>) [letting <i>x</i> be arbitrary, assuming <i>P</i>(<i>x</i>), <i>S</i>(<i>x</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_introduction" target="_blank">CONJUNCTION INTRODUCTION</a>]</i></span></li><li><span>From NOT (THERE EXISTS <i>X</i>: (<i>R</i>(<i>X</i>) AND <i>S</i>(<i>X</i>))): deduce NOT (THERE EXISTS <i>X</i>: (<i>R</i>(<i>X</i>) AND <i>S</i>(<i>X</i>))) [letting <i>x</i> be arbitrary, assuming <i>P</i>(<i>x</i>)]. <i>[DOUBLE PUSH (mixed version II)]</i></span></li><li><span>From <i>R</i>(<i>x</i>) AND <i>S</i>(<i>x</i>) [letting <i>x</i> be arbitrary, assuming <i>P</i>(<i>x</i>), <i>S</i>(<i>x</i>)]: deduce THERE EXISTS <i>X</i>: (<i>R</i>(<i>X</i>) AND <i>S</i>(<i>X</i>)) [letting <i>x</i> be arbitrary, assuming <i>P</i>(<i>x</i>), <i>S</i>(<i>x</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Existential_generalization">EXISTENTIAL INTRODUCTION</a>]</i></span></li><li><span>From NOT (THERE EXISTS <i>X</i>: (<i>R</i>(<i>X</i>) AND <i>S</i>(<i>X</i>))) [letting <i>x</i> be arbitrary, assuming <i>P</i>(<i>x</i>)]: deduce NOT (THERE EXISTS <i>X</i>: (<i>R</i>(<i>X</i>) AND <i>S</i>(<i>X</i>))) [letting <i>x</i> be arbitrary, assuming <i>P</i>(<i>x</i>), <i>S</i>(<i>x</i>)]. <i>[PUSH]</i></span></li><li><span>From THERE EXISTS <i>X</i>: (<i>R</i>(<i>X</i>) AND <i>S</i>(<i>X</i>)) [letting <i>x</i> be arbitrary, assuming <i>P</i>(<i>x</i>), <i>S</i>(<i>x</i>)], NOT (THERE EXISTS <i>X</i>: (<i>R</i>(<i>X</i>) AND <i>S</i>(<i>X</i>))) [letting <i>x</i> be arbitrary, assuming <i>P</i>(<i>x</i>), <i>S</i>(<i>x</i>)]: deduce NOT <i>S</i>(<i>x</i>) [letting <i>x</i> be arbitrary, assuming <i>P</i>(<i>x</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Reductio_ad_absurdum" target="_blank">REDUCTIO AD ABSURDUM</a> (separated form)]</i></span></li><li><span>From NOT <i>S</i>(<i>x</i>) [letting <i>x</i> be arbitrary, assuming <i>P</i>(<i>x</i>)]: deduce <i>P</i>(<i>x</i>) IMPLIES (NOT <i>S</i>(<i>x</i>)) [letting <i>x</i> be arbitrary]. <i>[<a href="https://en.wikipedia.org/wiki/Deduction_theorem" target="_blank">DEDUCTION THEOREM</a>]</i></span></li><li><span>From <i>P</i>(<i>x</i>) IMPLIES (NOT <i>S</i>(<i>x</i>)) [letting <i>x</i> be arbitrary]: deduce FOR ALL <i>X</i>: (<i>P</i>(<i>X</i>) IMPLIES (NOT <i>S</i>(<i>X</i>))). <i>[<a href="https://en.wikipedia.org/wiki/Universal_generalization" target="_blank"> UNIVERSAL INTRODUCTION</a>]</i></span></li><li><span>QED!</span></li>';

newSection("23", "Predicates and operators");

var Exercise231 = new Exercise("23.1(a)", "", [], forAll(forAll(IMPLIES(QXY,QXY),Y),X), 6);
Exercise231.unlockedBy(Exercise221);
Exercise231.revealOperatorsWindow = true;
Exercise231.notes = '<UL><LI> In previous exercises, formulas such as <I>Q(x,y)</I> were manually provided for those exercises where they were needed.  In this section, a new window has been unlocked that allows one to generate such formulas without manual intervention. </LI> <LI>  The <B>Predicates and operators</B> window contains all the predicates (and also operators - see the next few exercises) that appear in the exercise.  Predicates can be take one or more arguments, indicated here by em-dashes &mdash;.</LI> <LI> If one drags a term to each argument of a predicate, one creates a formula in the <B>Formulas</B> window (and the arguments of the predicate are then reset to em-dashes).  For instance, to create the formula <I>Q(x,y)</I>, drag the term <I>x</I> to the first argument of <I>Q</I>(&mdash;,&mdash;), and drag the term <I>y</I> to the second argument.</LI></UL>';
Exercise231.proof = '<li><span>Form environment [letting <i>x</i> be arbitrary]. <i>[FREE VARIABLE INTRODUCTION]</i></span></li><li><span>Form environment [letting <i>x</i>, <i>y</i> be arbitrary]. <i>[FREE VARIABLE INTRODUCTION]</i></span></li><li><span>Deduce <i>Q</i>(<i>x</i>, <i>y</i>) IMPLIES <i>Q</i>(<i>x</i>, <i>y</i>) [letting <i>x</i>, <i>y</i> be arbitrary]. <i>[IMPLIES IS <a href="https://en.wikipedia.org/wiki/Idempotence&quot;" target="_blank">IDEMPOTENT</a>]</i></span></li><li><span>From <i>Q</i>(<i>x</i>, <i>y</i>) IMPLIES <i>Q</i>(<i>x</i>, <i>y</i>) [letting <i>x</i>, <i>y</i> be arbitrary]: deduce FOR ALL <i>Y</i>: (<i>Q</i>(<i>x</i>, <i>Y</i>) IMPLIES <i>Q</i>(<i>x</i>, <i>Y</i>)) [letting <i>x</i> be arbitrary]. <i>[<a href="https://en.wikipedia.org/wiki/Universal_generalization" target="_blank"> UNIVERSAL INTRODUCTION</a>]</i></span></li><li><span>From FOR ALL <i>Y</i>: (<i>Q</i>(<i>x</i>, <i>Y</i>) IMPLIES <i>Q</i>(<i>x</i>, <i>Y</i>)) [letting <i>x</i> be arbitrary]: deduce FOR ALL <i>X</i>: (FOR ALL <i>Y</i>: (<i>Q</i>(<i>X</i>, <i>Y</i>) IMPLIES <i>Q</i>(<i>X</i>, <i>Y</i>))). <i>[<a href="https://en.wikipedia.org/wiki/Universal_generalization" target="_blank"> UNIVERSAL INTRODUCTION</a>]</i></span></li><li><span>QED!</span></li>';

var Exercise231b = new Exercise("23.1(b)", "", [], forAll(forAll(IMPLIES(gtXY,gtXY),Y),X), 6);
Exercise231b.unlockedBy(Exercise231);
Exercise231b.notes = '<UL><LI> Some predicates are customarily written in between their arguments, rather than to the left of the arguments.  The most familiar examples of these are the comparison predicates &lt;, &gt;, &le;, &ge; and the equality relation =.  </LI> <LI> However, this difference is purely notational, and these predicates otherwise follow all the laws of first-order logic that predicates such as <I>Q</I>(&mdash;, &mdash;) do.';
Exercise231b.proof = '';

var Exercise231c = new Exercise("23.1(c)", "", [], forAll(forAll(IMPLIES(PXplusY,PXplusY),Y),X), 6);
Exercise231c.unlockedBy(Exercise231);
Exercise231c.notes = '<UL><LI> In addition to predicates, first-order logic also allows the use of <I>operators</I>, also known as <I>function symbols</I>.  </LI> <LI> operators are symbols that take some number of terms to produce more complicated terms.  The most familiar examples of operators are the arithmetic operators +, -, x, /; thus for instance one could take the terms <I>x</I> and <I>y</I> and produce a new term <I>x</I>+<I>y</I>.  </LI> <LI> Operators closely resemble predicates, except that a predicate produces formulas, whereas an operator produces terms.  </LI> <LI> As such, we place operators in the same <B>Predicates and operators</B> window as predicates; the only difference is that the output of such operators goes into the <B>Terms</B> window rather than the <B>Formulas</B> window.</LI> <LI> Note that compound terms such as <I>x+y</I> are not free variables or bound variables, and so cannot be used for those laws of first-order logic that require such variables.  However, they are still perfectly good terms for use in such laws as universal specification or existential introduction.</LI> </UL>';
Exercise231c.proof = '<li><span>Form environment [letting <i>x</i> be arbitrary]. <i>[FREE VARIABLE INTRODUCTION]</i></span></li><li><span>Form environment [letting <i>x</i>, <i>y</i> be arbitrary]. <i>[FREE VARIABLE INTRODUCTION]</i></span></li><li><span>Deduce <i>P</i>(<i>x</i> <i>+</i> <i>y</i>) IMPLIES <i>P</i>(<i>x</i> <i>+</i> <i>y</i>) [letting <i>x</i>, <i>y</i> be arbitrary]. <i>[IMPLIES IS <a href="https://en.wikipedia.org/wiki/Idempotence&quot;" target="_blank">IDEMPOTENT</a>]</i></span></li><li><span>From <i>P</i>(<i>x</i> <i>+</i> <i>y</i>) IMPLIES <i>P</i>(<i>x</i> <i>+</i> <i>y</i>) [letting <i>x</i>, <i>y</i> be arbitrary]: deduce FOR ALL <i>Y</i>: (<i>P</i>(<i>x</i> <i>+</i> <i>Y</i>) IMPLIES <i>P</i>(<i>x</i> <i>+</i> <i>Y</i>)) [letting <i>x</i> be arbitrary]. <i>[<a href="https://en.wikipedia.org/wiki/Universal_generalization" target="_blank"> UNIVERSAL INTRODUCTION</a>]</i></span></li><li><span>From FOR ALL <i>Y</i>: (<i>P</i>(<i>x</i> <i>+</i> <i>Y</i>) IMPLIES <i>P</i>(<i>x</i> <i>+</i> <i>Y</i>)) [letting <i>x</i> be arbitrary]: deduce FOR ALL <i>X</i>: (FOR ALL <i>Y</i>: (<i>P</i>(<i>X</i> <i>+</i> <i>Y</i>) IMPLIES <i>P</i>(<i>X</i> <i>+</i> <i>Y</i>))). <i>[<a href="https://en.wikipedia.org/wiki/Universal_generalization" target="_blank"> UNIVERSAL INTRODUCTION</a>]</i></span></li><li><span>QED!</span></li>';

var Exercise232 = new Exercise("23.2", '<A HREF="https://en.wikipedia.org/wiki/Russell%27s_paradox" target="_blank">RUSSELL\'S PARADOX</A>', [thereExists(forAll(IFF(YinX,NOT(YinY)),Y),X)], NOT(TRUE()),13);
Exercise232.unlockedBy(Exercise231);
Exercise232.notes = '<UL><LI><A HREF="https://en.wikipedia.org/wiki/Russell%27s_paradox" target="_blank">Russell\'s paradox</A> is a famous paradox in set theory.  It asserts that there cannot exist a set that consists precisely of those sets that do not contain themselves.</LI><LI> It had a significant impact in set theory, showing that certain axioms of "<A HREF="https://en.wikipedia.org/wiki/Naive_set_theory" target="_blank">naive set theory</A>" were in fact inconsistent.  This eventually led to modern axiomatisations of set theory, such as <A HREF="https://en.wikipedia.org/wiki/Zermelo%E2%80%93Fraenkel_set_theory" target="_blank">Zermelo-Fraenkel-Choice (ZFC)</A></LI><LI> An informal version of the paradox involves a barber who shaves everyone who does not shave themselves.  Who shaves the barber?</LI></UL>';
Exercise232.proof = '<li><span>THERE EXISTS <i>X</i>: (FOR ALL <i>Y</i>: ((<i>Y</i> <i>‚àà</i> <i>X</i>) IFF (NOT (<i>Y</i> <i>‚àà</i> <i>Y</i>)))). <i>[given]</i></span></li><li><span>From THERE EXISTS <i>X</i>: (FOR ALL <i>Y</i>: ((<i>Y</i> <i>‚àà</i> <i>X</i>) IFF (NOT (<i>Y</i> <i>‚àà</i> <i>Y</i>)))): deduce FOR ALL <i>Y</i>: ((<i>Y</i> <i>‚àà</i> <i>x</i>) IFF (NOT (<i>Y</i> <i>‚àà</i> <i>Y</i>))) [setting <i>x</i> s.t. FOR ALL <i>Y</i>: ((<i>Y</i> <i>‚àà</i> <i>x</i>) IFF (NOT (<i>Y</i> <i>‚àà</i> <i>Y</i>)))]. <i>[<a href="https://en.wikipedia.org/wiki/Existential_instantiation" target="_blank">EXISTENTIAL INSTANTIATION</a>]</i></span></li><li><span>From FOR ALL <i>Y</i>: ((<i>Y</i> <i>‚àà</i> <i>x</i>) IFF (NOT (<i>Y</i> <i>‚àà</i> <i>Y</i>))) [setting <i>x</i> s.t. FOR ALL <i>Y</i>: ((<i>Y</i> <i>‚àà</i> <i>x</i>) IFF (NOT (<i>Y</i> <i>‚àà</i> <i>Y</i>)))]: deduce (<i>x</i> <i>‚àà</i> <i>x</i>) IFF (NOT (<i>x</i> <i>‚àà</i> <i>x</i>)) [setting <i>x</i> s.t. FOR ALL <i>Y</i>: ((<i>Y</i> <i>‚àà</i> <i>x</i>) IFF (NOT (<i>Y</i> <i>‚àà</i> <i>Y</i>)))]. <i>[<a href="https://en.wikipedia.org/wiki/Universal_instantiation" target="_blank">UNIVERSAL SPECIFICATION</a>]</i></span></li><li><span>Deduce (<i>x</i> <i>‚àà</i> <i>x</i>) OR (NOT (<i>x</i> <i>‚àà</i> <i>x</i>)) [setting <i>x</i> s.t. FOR ALL <i>Y</i>: ((<i>Y</i> <i>‚àà</i> <i>x</i>) IFF (NOT (<i>Y</i> <i>‚àà</i> <i>Y</i>)))]. <i>[<a href="https://en.wikipedia.org/wiki/Law_of_excluded_middle" target="_blank">EXCLUDED MIDDLE</a>]</i></span></li><li><span>From (<i>x</i> <i>‚àà</i> <i>x</i>) OR (NOT (<i>x</i> <i>‚àà</i> <i>x</i>)) [setting <i>x</i> s.t. FOR ALL <i>Y</i>: ((<i>Y</i> <i>‚àà</i> <i>x</i>) IFF (NOT (<i>Y</i> <i>‚àà</i> <i>Y</i>)))], (<i>x</i> <i>‚àà</i> <i>x</i>) IFF (NOT (<i>x</i> <i>‚àà</i> <i>x</i>)) [setting <i>x</i> s.t. FOR ALL <i>Y</i>: ((<i>Y</i> <i>‚àà</i> <i>x</i>) IFF (NOT (<i>Y</i> <i>‚àà</i> <i>Y</i>)))]: deduce (NOT (<i>x</i> <i>‚àà</i> <i>x</i>)) OR (NOT (<i>x</i> <i>‚àà</i> <i>x</i>)) [setting <i>x</i> s.t. FOR ALL <i>Y</i>: ((<i>Y</i> <i>‚àà</i> <i>x</i>) IFF (NOT (<i>Y</i> <i>‚àà</i> <i>Y</i>)))]. <i>[SUBSTITUTION FOR OR (left)]</i></span></li><li><span>From (NOT (<i>x</i> <i>‚àà</i> <i>x</i>)) OR (NOT (<i>x</i> <i>‚àà</i> <i>x</i>)) [setting <i>x</i> s.t. FOR ALL <i>Y</i>: ((<i>Y</i> <i>‚àà</i> <i>x</i>) IFF (NOT (<i>Y</i> <i>‚àà</i> <i>Y</i>)))]: deduce NOT (<i>x</i> <i>‚àà</i> <i>x</i>) [setting <i>x</i> s.t. FOR ALL <i>Y</i>: ((<i>Y</i> <i>‚àà</i> <i>x</i>) IFF (NOT (<i>Y</i> <i>‚àà</i> <i>Y</i>)))]. <i>[OR IS <a href="https://en.wikipedia.org/wiki/Idempotence" target="_blank">IDEMPOTENT</a> (right)]</i></span></li><li><span>From (<i>x</i> <i>‚àà</i> <i>x</i>) IFF (NOT (<i>x</i> <i>‚àà</i> <i>x</i>)) [setting <i>x</i> s.t. FOR ALL <i>Y</i>: ((<i>Y</i> <i>‚àà</i> <i>x</i>) IFF (NOT (<i>Y</i> <i>‚àà</i> <i>Y</i>)))]: deduce (NOT (<i>x</i> <i>‚àà</i> <i>x</i>)) IFF (<i>x</i> <i>‚àà</i> <i>x</i>) [setting <i>x</i> s.t. FOR ALL <i>Y</i>: ((<i>Y</i> <i>‚àà</i> <i>x</i>) IFF (NOT (<i>Y</i> <i>‚àà</i> <i>Y</i>)))]. <i>[IFF IS <a href="https://en.wikipedia.org/wiki/Symmetric_relation" target="_blank">SYMMETRIC</a>]</i></span></li><li><span>From (<i>x</i> <i>‚àà</i> <i>x</i>) OR (NOT (<i>x</i> <i>‚àà</i> <i>x</i>)) [setting <i>x</i> s.t. FOR ALL <i>Y</i>: ((<i>Y</i> <i>‚àà</i> <i>x</i>) IFF (NOT (<i>Y</i> <i>‚àà</i> <i>Y</i>)))], (NOT (<i>x</i> <i>‚àà</i> <i>x</i>)) IFF (<i>x</i> <i>‚àà</i> <i>x</i>) [setting <i>x</i> s.t. FOR ALL <i>Y</i>: ((<i>Y</i> <i>‚àà</i> <i>x</i>) IFF (NOT (<i>Y</i> <i>‚àà</i> <i>Y</i>)))]: deduce (<i>x</i> <i>‚àà</i> <i>x</i>) OR (<i>x</i> <i>‚àà</i> <i>x</i>) [setting <i>x</i> s.t. FOR ALL <i>Y</i>: ((<i>Y</i> <i>‚àà</i> <i>x</i>) IFF (NOT (<i>Y</i> <i>‚àà</i> <i>Y</i>)))]. <i>[SUBSTITUTION FOR OR (right)]</i></span></li><li><span>From (<i>x</i> <i>‚àà</i> <i>x</i>) OR (<i>x</i> <i>‚àà</i> <i>x</i>) [setting <i>x</i> s.t. FOR ALL <i>Y</i>: ((<i>Y</i> <i>‚àà</i> <i>x</i>) IFF (NOT (<i>Y</i> <i>‚àà</i> <i>Y</i>)))]: deduce <i>x</i> <i>‚àà</i> <i>x</i> [setting <i>x</i> s.t. FOR ALL <i>Y</i>: ((<i>Y</i> <i>‚àà</i> <i>x</i>) IFF (NOT (<i>Y</i> <i>‚àà</i> <i>Y</i>)))]. <i>[OR IS <a href="https://en.wikipedia.org/wiki/Idempotence" target="_blank">IDEMPOTENT</a> (right)]</i></span></li><li><span>From <i>x</i> <i>‚àà</i> <i>x</i> [setting <i>x</i> s.t. FOR ALL <i>Y</i>: ((<i>Y</i> <i>‚àà</i> <i>x</i>) IFF (NOT (<i>Y</i> <i>‚àà</i> <i>Y</i>)))], NOT (<i>x</i> <i>‚àà</i> <i>x</i>) [setting <i>x</i> s.t. FOR ALL <i>Y</i>: ((<i>Y</i> <i>‚àà</i> <i>x</i>) IFF (NOT (<i>Y</i> <i>‚àà</i> <i>Y</i>)))]: deduce (<i>x</i> <i>‚àà</i> <i>x</i>) AND (NOT (<i>x</i> <i>‚àà</i> <i>x</i>)) [setting <i>x</i> s.t. FOR ALL <i>Y</i>: ((<i>Y</i> <i>‚àà</i> <i>x</i>) IFF (NOT (<i>Y</i> <i>‚àà</i> <i>Y</i>)))]. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_introduction" target="_blank">CONJUNCTION INTRODUCTION</a>]</i></span></li><li><span>From (<i>x</i> <i>‚àà</i> <i>x</i>) AND (NOT (<i>x</i> <i>‚àà</i> <i>x</i>)) [setting <i>x</i> s.t. FOR ALL <i>Y</i>: ((<i>Y</i> <i>‚àà</i> <i>x</i>) IFF (NOT (<i>Y</i> <i>‚àà</i> <i>Y</i>)))]: deduce NOT TRUE [setting <i>x</i> s.t. FOR ALL <i>Y</i>: ((<i>Y</i> <i>‚àà</i> <i>x</i>) IFF (NOT (<i>Y</i> <i>‚àà</i> <i>Y</i>)))]. <i>[<a href="https://en.wikipedia.org/wiki/Principle_of_explosion" target="_blank">EX FALSO QUODLIBET</a>]</i></span></li><li><span>From NOT TRUE [setting <i>x</i> s.t. FOR ALL <i>Y</i>: ((<i>Y</i> <i>‚àà</i> <i>x</i>) IFF (NOT (<i>Y</i> <i>‚àà</i> <i>Y</i>)))]: deduce NOT TRUE. <i>[PULL]</i></span></li><li><span>QED!</span></li>';

var Exercise233 = new Exercise("23.3", 'NO LARGEST NATURAL NUMBER', [forAll(NOT(XgteX1),X)], NOT(thereExists(forAll(XgteY,Y),X)),11);
Exercise233.unlockedBy(Exercise231);
Exercise233.notes = '<UL><LI>If one takes the natural numbers as the universe of discourse, and interprets arithmetic symbols such as <I>&ge;</I>, <I>+</I>, <I>1</I> in the usual fashion, then this exercise is asking you to prove that there is no natural number that is greater than or equal to all natural numbers.  Your given information is that a natural number <I>X</I> is never greater than its successor <I>X+1</I>. </LI> <LI> While one could solve this exercise by randomly trying various laws of deduction, it is better to use your mathematical intuition and think first about <i>why</i> the above assertion about natural numbers is true.  Once you figure out why, convert your reasoning into a formal proof.</LI> </UL>';
Exercise233.proof = '<li><span>FOR ALL <i>X</i>: (NOT (<i>X</i> <i>‚â•</i> (<i>X</i> <i>+</i> 1))). <i>[given]</i></span></li><li><span>Deduce THERE EXISTS <i>X</i>: (FOR ALL <i>Y</i>: (<i>X</i> <i>‚â•</i> <i>Y</i>)) [assuming THERE EXISTS <i>X</i>: (FOR ALL <i>Y</i>: (<i>X</i> <i>‚â•</i> <i>Y</i>))]. <i>[IMPLICATION INTRODUCTION]</i></span></li><li><span>From THERE EXISTS <i>X</i>: (FOR ALL <i>Y</i>: (<i>X</i> <i>‚â•</i> <i>Y</i>)) [assuming THERE EXISTS <i>X</i>: (FOR ALL <i>Y</i>: (<i>X</i> <i>‚â•</i> <i>Y</i>))]: deduce FOR ALL <i>Y</i>: (<i>x</i> <i>‚â•</i> <i>Y</i>) [assuming THERE EXISTS <i>X</i>: (FOR ALL <i>Y</i>: (<i>X</i> <i>‚â•</i> <i>Y</i>)), setting <i>x</i> s.t. FOR ALL <i>Y</i>: (<i>x</i> <i>‚â•</i> <i>Y</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Existential_instantiation" target="_blank">EXISTENTIAL INSTANTIATION</a>]</i></span></li><li><span>From FOR ALL <i>Y</i>: (<i>x</i> <i>‚â•</i> <i>Y</i>) [assuming THERE EXISTS <i>X</i>: (FOR ALL <i>Y</i>: (<i>X</i> <i>‚â•</i> <i>Y</i>)), setting <i>x</i> s.t. FOR ALL <i>Y</i>: (<i>x</i> <i>‚â•</i> <i>Y</i>)]: deduce <i>x</i> <i>‚â•</i> (<i>x</i> <i>+</i> 1) [assuming THERE EXISTS <i>X</i>: (FOR ALL <i>Y</i>: (<i>X</i> <i>‚â•</i> <i>Y</i>)), setting <i>x</i> s.t. FOR ALL <i>Y</i>: (<i>x</i> <i>‚â•</i> <i>Y</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Universal_instantiation" target="_blank">UNIVERSAL SPECIFICATION</a>]</i></span></li><li><span>From FOR ALL <i>X</i>: (NOT (<i>X</i> <i>‚â•</i> (<i>X</i> <i>+</i> 1))): deduce FOR ALL <i>X</i>: (NOT (<i>X</i> <i>‚â•</i> (<i>X</i> <i>+</i> 1))) [assuming THERE EXISTS <i>X</i>: (FOR ALL <i>Y</i>: (<i>X</i> <i>‚â•</i> <i>Y</i>)), setting <i>x</i> s.t. FOR ALL <i>Y</i>: (<i>x</i> <i>‚â•</i> <i>Y</i>)]. <i>[DOUBLE PUSH (mixed III)]</i></span></li><li><span>From FOR ALL <i>X</i>: (NOT (<i>X</i> <i>‚â•</i> (<i>X</i> <i>+</i> 1))) [assuming THERE EXISTS <i>X</i>: (FOR ALL <i>Y</i>: (<i>X</i> <i>‚â•</i> <i>Y</i>)), setting <i>x</i> s.t. FOR ALL <i>Y</i>: (<i>x</i> <i>‚â•</i> <i>Y</i>)]: deduce NOT (<i>x</i> <i>‚â•</i> (<i>x</i> <i>+</i> 1)) [assuming THERE EXISTS <i>X</i>: (FOR ALL <i>Y</i>: (<i>X</i> <i>‚â•</i> <i>Y</i>)), setting <i>x</i> s.t. FOR ALL <i>Y</i>: (<i>x</i> <i>‚â•</i> <i>Y</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Universal_instantiation" target="_blank">UNIVERSAL SPECIFICATION</a>]</i></span></li><li><span>From <i>x</i> <i>‚â•</i> (<i>x</i> <i>+</i> 1) [assuming THERE EXISTS <i>X</i>: (FOR ALL <i>Y</i>: (<i>X</i> <i>‚â•</i> <i>Y</i>)), setting <i>x</i> s.t. FOR ALL <i>Y</i>: (<i>x</i> <i>‚â•</i> <i>Y</i>)], NOT (<i>x</i> <i>‚â•</i> (<i>x</i> <i>+</i> 1)) [assuming THERE EXISTS <i>X</i>: (FOR ALL <i>Y</i>: (<i>X</i> <i>‚â•</i> <i>Y</i>)), setting <i>x</i> s.t. FOR ALL <i>Y</i>: (<i>x</i> <i>‚â•</i> <i>Y</i>)]: deduce (<i>x</i> <i>‚â•</i> (<i>x</i> <i>+</i> 1)) AND (NOT (<i>x</i> <i>‚â•</i> (<i>x</i> <i>+</i> 1))) [assuming THERE EXISTS <i>X</i>: (FOR ALL <i>Y</i>: (<i>X</i> <i>‚â•</i> <i>Y</i>)), setting <i>x</i> s.t. FOR ALL <i>Y</i>: (<i>x</i> <i>‚â•</i> <i>Y</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Conjunction_introduction" target="_blank">CONJUNCTION INTRODUCTION</a>]</i></span></li><li><span>From (<i>x</i> <i>‚â•</i> (<i>x</i> <i>+</i> 1)) AND (NOT (<i>x</i> <i>‚â•</i> (<i>x</i> <i>+</i> 1))) [assuming THERE EXISTS <i>X</i>: (FOR ALL <i>Y</i>: (<i>X</i> <i>‚â•</i> <i>Y</i>)), setting <i>x</i> s.t. FOR ALL <i>Y</i>: (<i>x</i> <i>‚â•</i> <i>Y</i>)]: deduce TRUE AND (NOT TRUE) [assuming THERE EXISTS <i>X</i>: (FOR ALL <i>Y</i>: (<i>X</i> <i>‚â•</i> <i>Y</i>)), setting <i>x</i> s.t. FOR ALL <i>Y</i>: (<i>x</i> <i>‚â•</i> <i>Y</i>)]. <i>[<a href="https://en.wikipedia.org/wiki/Principle_of_explosion" target="_blank">EX FALSO QUODLIBET</a>]</i></span></li><li><span>From TRUE AND (NOT TRUE) [assuming THERE EXISTS <i>X</i>: (FOR ALL <i>Y</i>: (<i>X</i> <i>‚â•</i> <i>Y</i>)), setting <i>x</i> s.t. FOR ALL <i>Y</i>: (<i>x</i> <i>‚â•</i> <i>Y</i>)]: deduce TRUE AND (NOT TRUE) [assuming THERE EXISTS <i>X</i>: (FOR ALL <i>Y</i>: (<i>X</i> <i>‚â•</i> <i>Y</i>))]. <i>[PULL]</i></span></li><li><span>From TRUE AND (NOT TRUE) [assuming THERE EXISTS <i>X</i>: (FOR ALL <i>Y</i>: (<i>X</i> <i>‚â•</i> <i>Y</i>))]: deduce NOT (THERE EXISTS <i>X</i>: (FOR ALL <i>Y</i>: (<i>X</i> <i>‚â•</i> <i>Y</i>))). <i>[<a href="https://en.wikipedia.org/wiki/Reductio_ad_absurdum" target="_blank">REDUCTIO AD ABSURDUM</a>]</i></span></li><li><span>QED!</span></li>';

newSection("24", "Equality");

var reflexivity = new Law('EQUALITY IS <A HREF="https://en.wikipedia.org/wiki/Reflexive_relation" target="_blank">REFLEXIVE</A>', [alpha], equals(alpha,alpha));
var Exercise241 = new Exercise("24.1(a)", 'EQUALITY IS <A HREF="https://en.wikipedia.org/wiki/Symmetric_relation"> target="_blank">SYMMETRIC</A>', [equals(alpha,beta)], equals(beta,alpha), 4);
Exercise241.unlocks(reflexivity);
Exercise241.unlocks(indiscernability);
Exercise241.unlockedBy(Exercise231);
Exercise241.notes = '<UL><LI>Amongst all the predicates in first-order logic, there is a special one that obeys special rules: the equality predicate <I>=</I>.  This binary predicate is written as a relation, thus we write <I>&alpha;=&beta;</I> rather than <I>=(&alpha;,&beta;)</I>.</LI> <LI> Equality obeys two fundamental laws.  The first is <A HREF="https://en.wikipedia.org/wiki/Reflexive_relation" target="_blank">reflexivity</A>: if <I>&alpha;</I> is a term, then the statement <I>&alpha;=&\beta;</I> is true (assuming of course that this statement is well-formed in the target environment. </LI> <LI> The second law is the <A HREF="https://en.wikipedia.org/wiki/Identity_of_indiscernibles" target="_blank">indiscernability of identicals</A> (also known as Leibniz\'s law): if one knows that <I>&alpha;=&beta;</I>, and one knows that <I>P(&alpha;)</I> is true, then one can conclude that <I>P(&beta;)</I> is also true.</LI> <LI> To use the law of reflexivity, click on a term in the <B>Terms</B> window, or drag a term into a target environment. </LI> <LI> To use the indiscernability of identicals, drag an equation of the form <I>&alpha;=&beta;</I> to another statement in the same environment.</LI> <LI> As with the law of existential introduction, there can be multiple ways in which the indiscernability of identicals law can be applied to a given pair of statements.  However, the game removes the "trivial" deduction of concluding a statement from itself.</LI> <LI> With these two laws of equality, the  the set of rules of deduction for first-order logic used in this text is now complete.  (But this is not the only such set of rules; there are other deductive systems for first-order logic that use a different set of rules, though they still end up proving the same set of statements.)</LI> </UL>';
Exercise241.proof = '<li><span>Œ± <i>=</i> Œ≤. <i>[given]</i></span></li><li><span>Deduce Œ± <i>=</i> Œ±. <i>[EQUALITY IS REFLEXIVE]</i></span></li><li><span>From Œ± <i>=</i> Œ±, Œ± <i>=</i> Œ≤: deduce Œ≤ <i>=</i> Œ±. <i>[<a href="https://en.wikipedia.org/wiki/Identity_of_indiscernibles" target="_blank">INDISCERNABILITY OF IDENTICALS</a>]</i></span></li><li><span>QED!</span></li>';

var Exercise241b = new Exercise("24.1(b)", 'EQUALITY IS <A HREF="https://en.wikipedia.org/wiki/Transitive_relation">TRANSITIVE</A>', [equals(alpha,beta), equals(beta,gamma)], equals(alpha,gamma), 4);
Exercise241b.notes = '<UL> <LI> The fact that equality is reflexive, symmetric, and transitive can be summarised into the single observation that equality is an <A HREF="https://en.wikipedia.org/wiki/Equivalence_relation" target="_blank">equivalence relation</A>.</LI></UL>'
Exercise241b.unlockedBy(Exercise241);
Exercise241b.proof = '<li><span>Œ± <i>=</i> Œ≤. <i>[given]</i></span></li><li><span>Œ≤ <i>=</i> Œ≥. <i>[given]</i></span></li><li><span>From Œ± <i>=</i> Œ≤, Œ≤ <i>=</i> Œ≥: deduce Œ± <i>=</i> Œ≥. <i>[<a href="https://en.wikipedia.org/wiki/Identity_of_indiscernibles" target="_blank">INDISCERNABILITY OF IDENTICALS</a>]</i></span></li><li><span>QED!</span></li>';

var Exercise242 = new Exercise("24.2", 'SUBSTITUTION', [equals(alpha,beta)], equals(fa,fb), 4);
Exercise242.unlockedBy(Exercise241);
Exercise242.proof = '<li><span>Œ± <i>=</i> Œ≤. <i>[given]</i></span></li><li><span>Deduce <i>f</i>(Œ±) <i>=</i> <i>f</i>(Œ±). <i>[EQUALITY IS <a href="https://en.wikipedia.org/wiki/Reflexive_relation" target="_blank">REFLEXIVE</a>]</i></span></li><li><span>From <i>f</i>(Œ±) <i>=</i> <i>f</i>(Œ±), Œ± <i>=</i> Œ≤: deduce <i>f</i>(Œ±) <i>=</i> <i>f</i>(Œ≤). <i>[<a href="https://en.wikipedia.org/wiki/Identity_of_indiscernibles" target="_blank">INDISCERNABILITY OF IDENTICALS</a>]</i></span></li><li><span>QED!</span></li>';

var Exercise243 = new Exercise("24.3", 'LEFT IDENTITY EQUALS RIGHT IDENTITY', [forAll(equals(operatorTerm(times,[alpha,X]),X),X), forAll(equals(operatorTerm(times,[X,beta]),X),X)], equals(alpha,beta), 6);
Exercise243.notes = '<UL> <LI> Now that all the laws of first-order logic are unlocked, it is now possible (in principle at least ) to start proving statements in mathematics itself, rather than in logic. </LI> <LI> We illustrate this with one of the first results in group theory: if one has a left-identity <I>&alpha;</I> (so that <I>&alpha; * X = X</I> for all <I>X</I>) and a right-identity <I>&beta;</I> (so that <I>X * &beta; = X</I> for all <I>X</I>), then <I>&alpha;</I> and <I>&beta;</I> must be equal.</LI> </UL> '
Exercise243.unlockedBy(Exercise241);
Exercise243.proof = '<li><span>FOR ALL <i>X</i>: ((Œ± <i>*</i> <i>X</i>) <i>=</i> <i>X</i>). <i>[given]</i></span></li><li><span>FOR ALL <i>X</i>: ((<i>X</i> <i>*</i> Œ≤) <i>=</i> <i>X</i>). <i>[given]</i></span></li><li><span>From FOR ALL <i>X</i>: ((Œ± <i>*</i> <i>X</i>) <i>=</i> <i>X</i>): deduce (Œ± <i>*</i> Œ≤) <i>=</i> Œ≤. <i>[<a href="https://en.wikipedia.org/wiki/Universal_instantiation" target="_blank">UNIVERSAL SPECIFICATION</a>]</i></span></li><li><span>From FOR ALL <i>X</i>: ((<i>X</i> <i>*</i> Œ≤) <i>=</i> <i>X</i>): deduce (Œ± <i>*</i> Œ≤) <i>=</i> Œ±. <i>[<a href="https://en.wikipedia.org/wiki/Universal_instantiation" target="_blank">UNIVERSAL SPECIFICATION</a>]</i></span></li><li><span>From (Œ± <i>*</i> Œ≤) <i>=</i> Œ≤, (Œ± <i>*</i> Œ≤) <i>=</i> Œ±: deduce Œ± <i>=</i> Œ≤. <i>[<a href="https://en.wikipedia.org/wiki/Identity_of_indiscernibles" target="_blank">INDISCERNABILITY OF IDENTICALS</a>]</i></span></li><li><span>QED!</span></li>';


// this command has to be executed after all laws defined and all GUI elements are in place

 checkForUnlocks();


</script>
</body>
</html>
